{"meta":{"title":"我的博客","subtitle":null,"description":null,"author":"杨波","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"javascript react-router-dom","slug":"react-router-dom","date":"2017-08-11T16:00:00.000Z","updated":"2018-03-20T12:08:57.915Z","comments":true,"path":"2017/08/12/react-router-dom/","link":"","permalink":"http://yoursite.com/2017/08/12/react-router-dom/","excerpt":"","text":"","categories":[{"name":"原生js","slug":"原生js","permalink":"http://yoursite.com/categories/原生js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"javascript scope","slug":"scope","date":"2017-07-29T16:00:00.000Z","updated":"2018-03-20T12:11:13.743Z","comments":true,"path":"2017/07/30/scope/","link":"","permalink":"http://yoursite.com/2017/07/30/scope/","excerpt":"","text":"对作用域和作用域链概念的模糊是我们在开发中导致一些‘意外’状况发生的常见原因我们随便写一个例子来看一下123456789101112131415161718192021222324252627var name = &apos;bird&apos;;function fn()&#123; console.log(name); // 1、undefined var name = &apos;dog&apos; function temp()&#123; var name = &apos;cat&apos; console.log(name); // 2、cat &#125; function item()&#123; console.log(name); // 3、dog &#125; temp(); item(); console.log(name); // 4、dog return function()&#123; console.log(name); // 5、dog &#125;&#125;var fn1 = fn();fn1();如果的这些结果你还会产生疑问的话，那说明你对作用域和作用域链的概念很模糊我们先说一下在js中的作用域的概念：作用域指的是变量的适用范围； 基本分为全局作用域（window）和局部作用域（函数）作用域的特点: 1、js中是不存在动态作用域的; 2、es6之前是不存在块级作用域的;我们来了分析一下刚才的代码位置1 这个位置输出 undefined 是因为js中变量提升机制所导致的 当进入一个作用域范围的时候js会预先查询在当前作用域中的var和function关键字所创建的变量，然后将这些变量的声明提升到当前作用域的顶部，但是var只能提升声明，不能赋值；而function 是提升声明并且赋值；位置2 在当前作用域（temp函数）中可以查询到name属性；位置3 在当前作用域（item函数）中无法查询到name属性，js机制会继续向外层查询，如果查询到了即输出；如果依旧没有找到，则继续向上级查询，直到查找到全局作用域，如果仍然查找不到，就会报错。位置4 跟2同理位置5 这也是证明了js中没有动态作用域；因为我们已经将fn函数的返回的函数赋值到了fn1，如果存在动态作用域的话，那输出的结果应该是‘bird’，然而他依旧是输出的‘dog’，也就是说，作用域链的查找规则是根据函数声明的位置，为不是看函数的调用位置如果有任何疑问或者文章内有错误，可以发邮件到1043951234@qq.com 进行交流，如果有错误我会第一时间更正，感谢您的赐教","categories":[{"name":"原生js","slug":"原生js","permalink":"http://yoursite.com/categories/原生js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"javascript Prototype","slug":"prototype","date":"2017-07-14T16:00:00.000Z","updated":"2018-03-20T12:07:41.713Z","comments":true,"path":"2017/07/15/prototype/","link":"","permalink":"http://yoursite.com/2017/07/15/prototype/","excerpt":"","text":"W3C对prototype的描述是：prototype 属性使您有能力向对象添加属性和方法。语法：object.prototype.name=value让很多刚刚开始了解OOP思想的人很是迷茫。prototype 的出现主要是为了实现“继承”的设计理念12345678910111213141516function Fn(name)&#123; this.name = name this.type = &apos;string&apos;;&#125;var foo1 = new Fn(&apos;one&apos;);var foo2 = new Fn(&apos;two&apos;);console.log(foo1.type) // =&gt; stringconsole.log(foo2.type) // =&gt; stringfoo1.type = &apos;number&apos;;console.log(foo2.type) // =&gt; string// 同一个构造函数所生成的所有实例之间相互是没有影响的（this是构造函数所生成的实例）这是我们通过 new 命令去创造一个实例的方法，但是 new 命令有一个很大的弊端，就是构造函数生成实例的时候会是属性和方法无法共享；这不仅是数据无法共享，也是资源的一种浪费；考虑到这个问题，也就在构造函数中出现了‘prototype’这个属性1234567891011121314151617181920// 我们改写一下上面的方法function Fn(name)&#123; this.name = name this.fn = function()&#123;&#125;;&#125;Fn.prototype = &#123; type: &apos;string&apos;&#125;var foo1 = new Fn(&apos;one&apos;);var foo2 = new Fn(&apos;two&apos;);console.log(foo1.name) // =&gt; oneconsole.log(foo2.name) // =&gt; twoFn.prototype.type = &apos;number&apos;;console.log(foo2.type) // =&gt; number我们发现 type 这个属性变成了两个实例的共有属性，而构造函数修改‘prototype’属性时会影响这实例的属性；理解起来很像是构造函数内部this上的属性是实例的私有属性，而构造函数的‘prototype’上的属性是实例的共有属性；对 prototype 有了一些了解 我们在说一下 __proto__ 这个属性， 它可以称谓隐式原型；我们先对这两个属性抽象理解一下:1) 每一个函数都天生自带一个prototype（对象数据类型）属性 指向自身的原型2) 每一个对象都天生自带一个__proto__属性 指向所属构造函数（类）的原型3) 每一个原型都再带一个 constructor 属性 指向构造函数（类）（但是constructor这个属性是可以手动修改的）js中的原型链也是由这俩个属性来实现的；我们先了解一下函数的三种身份：1) 普通函数2) 构造函数3) 函数对象普通函数 ： 是我们做常用的，不管是封装也谢方法还是回调函数，都属于普通函数范围构造函数 ： new 命名后面跟的函数 归属于构造函数，并且我们为了更方便的区分普通函数还是构造函数，在声明函数的时候，构造函数通常会采用首字母大写的方式函数对象 ： 函数自身也是一个对象，可以有自己的属性这也不难理解为什么js中的函数可塑性如此的高;既然说了prototype和__proto__是为了共享属性和方法（继承）而诞生的属性，我们来看一看他们在实际中是怎么使用的123456789101112131415161718192021function Parent (name,age)&#123; this.name = name; this.age = age;&#125;Parent.prototype = &#123; getName : function()&#123; return this.name; &#125;&#125;function Child (name,age,sex)&#123; Parent.call(this,name,age) this.sex = sex;&#125;Child.prototype = new Parent();var child = new Child(&apos;李雷&apos;,18,&apos;男&apos;)console.log(child.getName()); // 李雷我们写了一个简单的继承方式，在这个例子中我们不难发现，在Child这个构造函数所产生的实例中，我们可以使用Parent上的方法，这就是继承的作用，当在一个已有的构造函数中已经写过我们需要的方法，我们在合适的需求下，我们完全可以将其拿来直接使用，而不是自己在写一段重复、冗余的代码，这样也就实现了资源的共享；__proto__ 这个属性在实际开发中我们很少直接使用，是因为这个属性牵扯的东西太多，而且IE（所有开发者的痛苦）浏览器是屏蔽开发者对这个属性的操作的；并且这个属性也是一直不被推荐使用的；__proto__ 默认是串联所有实例和类的原型1234var ary = new Array(3);console.dir(ary);// 在输出台里你可以看见 \\__proto__ 的指向顺序， ary -&gt; Array -&gt; Object（自身\\__proto__为null，因为它已经是根源了）；这就是为什么我们声明一个数组后，就可以调用Array和Object上的方法；这也是js中为什么说万物皆对象的原因；在ES6中给出了两个操作方法:1) Object.getPrototypeOf() 方法返回指定对象的原型2) Object.setPrototypeOf() 方法设置一个指定的对象的原型尽管如此，设置对象的__proto__是一个缓慢的操作，如果性能是一个问题，应该避免;如果看过有关原型继承的书籍的话，我们会发现有很多继承的方式，在这就不一一举例了，我们直说一下寄生组合式继承，应该是目前最为理想解决继承的方法，解决了以前原型继承，组合式继承等等方法的一些小bug和缺陷123456789101112131415161718192021222324252627// 借助一下上面的例子，改造一下function Parent (name,age)&#123; this.name = name; this.age = age;&#125;Parent.prototype.getName = function()&#123; return this.name; &#125;// 在考虑Object.create 这个方法的兼容性不够，所以采用自己模拟这个功能的写法，如果不需要考虑IE9一下版本的话可以直接使用虑Object.create 更简单一些function inherit(sub,sup)&#123; function Fn()&#123;&#125;; Fn.prototype = sup.prototype; var fn = new Fn(); Object.defineProperty(fn,&apos;constructor&apos;,&#123;value:sub&#125;) // 增强原型 sub.prototype = fn;&#125;function Child (name,age,sex)&#123; Parent.call(this,name,age) this.sex = sex;&#125;inherit(Child,Parent);var child = new Child(&apos;李雷&apos;,18,&apos;男&apos;)console.log(child.getName()); // 李雷希望对正在学习这方面只是的小伙伴们有帮助吧, 以上观点也是我总结的一些。如果有任何疑问或者文章内有错误，可以发邮件到1043951234@qq.com 进行交流，如果有错误我会第一时间更正，感谢您的赐教","categories":[{"name":"原生js","slug":"原生js","permalink":"http://yoursite.com/categories/原生js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"react 声明周期","slug":"reactLifeCycle","date":"2017-07-01T16:00:00.000Z","updated":"2018-03-18T11:16:24.612Z","comments":true,"path":"2017/07/02/reactLifeCycle/","link":"","permalink":"http://yoursite.com/2017/07/02/reactLifeCycle/","excerpt":"","text":"react 的声明周期先上一张图，我们会根据这张图来分析react的声明周期其实是可以分为两大类的，第一种是组件实例化时只执行一次的，第二种是组件存在时会跟着组件内部操作而触发的；那就让我们分别来看看他们在react的一个组件组件中所充当的角色一、getDefaultProps12345678910111213import React from 'react'; *以后的代码省略这行代码了import PropTypes from 'prop-types';class Component extends React.Component&#123; static defaultProps = &#123; name: 'yang' &#125; render() &#123; return ( &lt;div&gt;Hello, &#123;this.props.name&#125;&lt;/div&gt; ) &#125;&#125;当组件实例化的时候会执行defaultProps这个函数，作用是设置组件所需参数的默认值、也可以配合prop-types这个包来进行参数验证prop-types注释 ： extends 是 es6 中类继承的语法；123456789 // 例如： 你想让类A 继承类B 那么写法 就是class A extends B &#123; //(类的名字最好是首字母大写，保持这种良好的代码风格) constructor()&#123; super(); // 在es5 一个构造函数继承另外一个构造函数的时候，会有很多方法：call继承，原型继承，组合式继承，寄生组合式继承（如果不知道的小伙变要好好学习了） // 而es6 中类继承则是通过super来进行的 ，super的特性不属于本篇文章的讨论范围，如果感兴趣的话可以去翻查一下 &#125;&#125;二、getInitialState12345678class Component extends React.Component&#123; constructor()&#123; super(); this.state = &#123; render: true &#125; &#125;&#125;当组件实例化的时候会对实例的一些私有属性进行初始化，对es6语法了解的话，应该很容易理解，如果对es6的class类的语法不了解的话建议大家先去了解一下es6, state是组件内部状态，这个属性十分的重要，state的属性变更会直接影响这组件的渲染三、componentWillMount是组件挂载前的最后一个生命周期，只执行一次，最后修改state的机会四 render12345678910111213class Component extends React.Component&#123; constructor()&#123; super(); this.state = &#123; name: &apos;yang&apos; &#125; &#125; render()&#123; return ( &lt;div&gt; `hello $&#123;this.state.name&#125;`&lt;/div&gt; ) &#125;&#125;组件渲染，render方法会根据return 的返回结果生成虚拟的DOM，经过react内部机制的DOM Diff 比对后，渲染到页面上。在render函数中有几个注意事项:1) 必须存在一个根节点2) 不可以修改state3) 可以输出null，false五 componentDidMount组件挂载完成，通常我们会在这个生命周期函数内进行页面数据的请求操作， 只会执行一次六 componentWillReceiveProps1234567891011121314151617181920class Component extends React.Component&#123; constructor()&#123; super(); this.state = &#123; name: this.props.name || 'yang' &#125; &#125; componentWillReceiveProps(nextProps)&#123; if(typeof nextProps.name !== 'undefined')&#123; this.setState(&#123; name: nextProps.name &#125;) &#125; &#125; render()&#123; return ( &lt;div&gt; `hello $&#123;this.state.name&#125;`&lt;/div&gt; ) &#125;&#125;当外部传入的参数发生改变的时候会触发componentWillReceiveProps这个函数的执行，在函数里可以修改本组件的state值，不用担心会引起render的多次调用七 shouldComponentUpdate12345678910111213141516class Component extends React.Component&#123; constructor()&#123; super(); this.state = &#123; name: this.props.name || 'yang' &#125; &#125; shouldComponentUpdate(nextProps,nextState)&#123; return nextProps.name != this.props.name; &#125; render()&#123; return ( &lt;div&gt; `hello $&#123;this.state.name&#125;`&lt;/div&gt; ) &#125;&#125;这个生命周期函数是在props和state发生改变时必然会触发的，如果没有手动声明，默认为true ，如果手动设置为false 组件将不会在更新；这个生命周期是开发者在react开发的时候对性能优化上帮助最大的，很多开发这都轻视了这个函数。八 componentWillUpdatestate或者props发生改变时，在组件准备更新之前执行的生命周期函数，在这个生命周期内不要在去修改state和props 不然后果很严重九 componentDidUpdate组件重新渲染后会被调用，在这个函数中可以获取到更新之后的数据和dom元素十 componentWillUnmount当用户执行移除组件或者删除组件的操作后，在执行前触发的生命周期函数，但是react对善后工作做的不是很到位，如果你在组件中创建了计时器这种异步操作事件，在componentWillUnmount函数中一定要手动的移除这些事件，否则会报错123456789101112131415161718192021222324class Component extends React.Component&#123; constructor()&#123; super(); this.state = &#123; name: this.props.name || 'yang' &#125; &#125; componentDidMount()&#123; this.timer = setTimeout(()=&gt;&#123; this.setState(&#123;name:'我要卸载了'&#125;) &#125;,5000) &#125; componentWillUnmount()&#123; clearTimeout(this.timer) &#125; handelClick()&#123; ReactDom.unmountComponentAtNode(window.root) &#125; render()&#123; return ( &lt;div onClick=&#123;this.handelClick&#125;&gt; `hello $&#123;this.state.name&#125;`&lt;/div&gt; ) &#125;&#125;对react 生命周期的以一些理解，希望对您有帮助，图中conponentWillReceiveProps 应该是com 拼错了","categories":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/categories/前端框架/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"react 基础篇（三）","slug":"reactBase3","date":"2017-06-24T16:00:00.000Z","updated":"2018-03-18T11:15:53.165Z","comments":true,"path":"2017/06/25/reactBase3/","link":"","permalink":"http://yoursite.com/2017/06/25/reactBase3/","excerpt":"","text":"react 的基本语法首先我们要了解react 的jsx语法react 使用 jsx 语法来代替常规的javascript 使用起来很像 html+javascript的组合jsx的优点 ：1、执行更快，因为它在编译为 JavaScript 代码后进行了优化2、它是类型安全的，在编译过程中就能发现错误3、使用 JSX 编写模板更加简单快速注意事项 ： 1、 想要在jsx中使用js语法需要使用‘{}’ 例： { this.state.name }2、 在jsx 中不能使用if else 可以改用三元运算符3、 jsx 中的注释写法 ：{/*注释…*/}我们先看一下这么一段代码123456789101112131415// 本篇文章代码必须引入的两个组件，后面的代码中省略import React from 'react';import ReactDOM from 'react-dom';let str = '20170109';function build(str) &#123; return ( &lt;div&gt; &lt;h1&gt;&#123;str&#125;&lt;/h1&gt; &lt;h2&gt;&#123;true ? str : null&#125;&lt;/h2&gt; &lt;/div&gt; )&#125;let el = &lt;div&gt;&#123;build('react的基本语法！')&#125;&lt;/div&gt;;ReactDOM.render(el, document.getElementById('root'));下面我们看一下组件的写法123456789101112131415161718192021let student1 = &#123;name: '小明', age: 15&#125;;let student2 = &#123;name: '李雷', age: 16&#125;;class Achievement extends React.Component &#123; render()&#123; // 这个组件在调用时，默认会调用render方法 let &#123;name,age&#125; = this.props; // 使用解构的方法可以让我们在写参数的时候更少 return &lt;p&gt;&#123;name&#125; &#123;age&#125;&lt;/p&gt;; // 也可以 return &lt;p&gt;&#123;this.props.name&#125; &#123;this.props.age&#125;&lt;/p&gt; &#125;&#125;// 组件的传参的两种方法，可以使用es6的解构方式，也可以一个个传ReactDOM.render(&lt;div&gt; &lt;Achievement &#123;...student1&#125;/&gt; &lt;Achievement name=&#123;student2.name&#125; age=&#123;student2.age&#125;/&gt;&lt;/div&gt;, window.root);// 注意 ： &lt;Achievement age=9/&gt; 这样传递参数的时候，在组件内部调用this.props.age 的时候是字符串类型而不是数字类型---列表类的输出方式12345678910111213141516let students = [ &#123;name: '李雷', sex: '男'&#125;, &#123;name: '李华', sex: '男'&#125;, &#123;name: '小红', sex: '女'&#125;];ReactDOM.render(( &lt;ul&gt; &#123;lessons.map((item, index) =&gt; ( &lt;li key=&#123;index&#125;&gt;姓名：&#123;item.name&#125;;性别：&#123;item.sex&#125;&lt;/li&gt; ) )&#125; &lt;/ul&gt;), document.getElementById('root'));一定要注意的是 如果你有代码的格式洁癖，请用() 将代码包裹起来，防止react不能正常解析这段代码，在react中循环输出的时候一定要在输出的元素上添加 key 属性，否则会出现警报，虽然这个警报不会影响你代码的执行，但是会影响性能，因为在react 中保证性能的 DOM Diff 会使用到这个属性 ,不是本篇文章的讨论范围属性上的渲染123456789101112131415let style = &#123; backgroundColor : 'red', color : 'blue', fontSize : '20px'&#125;;ReactDOM.render(( &lt;ul style=&#123;style&#125;&gt; &lt;li className='aa'&gt;1&lt;/li&gt; &lt;li&gt;&lt;label htmlFor='aa'&gt;-&lt;/label&gt;&lt;input id='aa'/&gt;&lt;/li&gt; &lt;li dangerouslySetInnerHTML=&#123;&#123;__html:'&lt;span&gt;123&lt;/span&gt;'&#125;&#125;&gt;&lt;/li&gt; &lt;/ul&gt;),window.root);// 这里需要注意的是 这里的style是对象数据类型要了解是react中dom的属性有一些已经变成react中的关键字，所以写法上会和以前的写法不同，例如：class -&gt; className; for -&gt; htmlFor …如果你必不可免的要在一个结构中插入许多标签，可以使用dangerouslySetInnerHTML（安全插入），因为有可能不合时宜的使用innerHTML会导致XSS攻击；事件上的绑定1234567891011121314151617181920212223242526272829303132333435363738394041// 我们以input 来举例， 顺便也说以下react 实现双向数据绑定的方法// 写法一class Input extends React.Component&#123; constructor()&#123; super(); this.state = &#123;val:''&#125; &#125; handleFn(e)&#123; this.setState(&#123;val:e.target.value&#125;); &#125; render()&#123; return ( &lt;div&gt; &lt;input type=\"text\" value=&#123;this.state.val&#125; onChange=&#123;this.handleFn.bind(this)&#125;/&gt; &#123;this.state.val&#125; &lt;/div&gt; ) &#125;&#125;// 写法二class Input extends React.Component&#123; constructor()&#123; super(); this.state = &#123;val:''&#125; &#125; handleFn = (e)=&gt;&#123; this.setState(&#123;val:e.target.value&#125;); &#125; render()&#123; return ( &lt;div&gt; &lt;input type=\"text\" value=&#123;this.state.val&#125; onChange=&#123;this.handleFn&#125;/&gt; &#123;this.state.val&#125; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;Input/&gt;,window.root);上面有两种写法，当然第二种使用了es6和es7的语法所以写起来很简洁，也不用担心this错误的问题，所以在babel可以解析的语法，我们都可以在项目中使用我们简单说一下 react 的双向数据绑定，大家都知道react 是 MVC框架（单向数据绑定），所以我们想实现双向数据绑定就要借助其他的方法，react 能引起视图渲染的方法只有修改state和props，所以我们想要是想双向数据绑定，我们就要去操作state和props，那我们实现一下1234567891011121314151617181920212223242526272829303132333435363738class Parent extends React.Component &#123; constructor() &#123; super(); this.state = &#123;val: ''&#125; &#125; changeFn = (e) =&gt; &#123; this.setState(&#123;val: e.target.value&#125;); &#125;; render() &#123; return ( &lt;Input value=&#123;this.state.val&#125; changeFn=&#123;this.changeFn&#125;/&gt; ) &#125;&#125;class Input extends React.Component &#123; constructor() &#123; super(); this.state = &#123;val: ''&#125; &#125; handleFn = (e) =&gt; &#123; this.setState(&#123;val: e.target.value&#125;); &#125;; render() &#123; let &#123;value,changeFn&#125; = this.props; return ( &lt;div&gt; &lt;input type=\"text\" value=&#123;this.state.val&#125; onChange=&#123;this.handleFn&#125;/&gt; &#123;this.state.val&#125; &lt;input type=\"text\" value=&#123;value&#125; onChange=&#123;changeFn&#125;/&gt; &#123;value&#125; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;Parent/&gt;,window.root)需要用事件来触发state或者props的修改来让视图重新渲染，来实现双向绑定还有一种不提倡的方法，就是直接通过ref 来操作DOM也可以实现，不过既然使用react了，还在操作DOM 那就太low了。所以我们要习惯这种数据驱动视图的思想。","categories":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/categories/前端框架/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"react 基础篇（二）","slug":"reactBase2","date":"2017-06-17T16:00:00.000Z","updated":"2018-03-18T11:15:25.699Z","comments":true,"path":"2017/06/18/reactBase2/","link":"","permalink":"http://yoursite.com/2017/06/18/reactBase2/","excerpt":"","text":"webpack 的基本配置想要实现项目的自动化管理，还是需要依赖自动化构建工具，这篇文章主要讲述的是webpack的基本配置12$ npm install webpack webpack-dev-server --save-dev // 或者使用yarn$ npm install style-loader css-loader url-loader file-loader less-loader html-webpack-plugin --save-dev上面安装的的是一个项目基本必须要使用的一些依赖包安装完成之后我们来看一下webpack该如何配置12345678910111213141516171819202122232425// 这个插件是为了webpack打包后的代码可以插入到我们html中的let HtmlWebpackPlugin = require(\"html-webpack-plugin\");// 我们先配置一个文件配置module.exports = &#123; entry: \"./src/index.js\", // 入口文件 output: &#123; // 出口 filename: \"build.js\", // 文件名 path: require('path').resolve('/dist') // 文件路径，这个需要填写绝对路径，所以我们引用path插件，来将一个相对路径转换成绝对路径 &#125;, module: &#123; rules: [ // 配置文件解析规则， &#123;test: /\\.js$/, use: \"babel-loader\", exclude: /node_modules/&#125;, &#123;test: /\\.css$/, use: [\"style-loader\", \"css-loader\"]&#125;, &#123;test: /\\.less$/, use: [\"style-loader\", \"css-loader\", \"less-loader\"]&#125;, &#123;test: /\\.(jpg|png|gif|jpeg)$/, use: \"url-loader\"&#125;, ] &#125;, devtool: 'source-map', /*源码映射*/ plugins: [ // 插件 new HtmlWebpackPlugin(&#123; template: \"./index.html\" &#125;) ]&#125;;多个文件的配置方法1234567891011module.exports = &#123; entry: &#123; app: &apos;./src/app.js&apos;, search: &apos;./src/search.js&apos; &#125;, output: &#123; filename: &apos;[name].js&apos;, path: __dirname + &apos;/dist&apos; &#125; ......&#125;webpack还有更多的配置参数，我们先配置一个简单的当然我们想要将环境跑起来，还需要在package.json文件中的scripts中配置一些启动环境的指令123456// 截取部分代码\"scripts\": &#123; \"dev\": \"webpack-dev-server --config webpack.config.js\", \"start\": \"npm run dev\", \"build\": \"webpack --config webpack.config.js\" // 打包时使用的代码 &#125;,配置完成后，我们就可以执行 start 来开启一个本地端口来运行我们的代码了是不是很简单呢，快来写一写react代码来感受一下吧","categories":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/categories/前端框架/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"react 基础篇（一）","slug":"reactBase1","date":"2017-06-10T16:00:00.000Z","updated":"2018-03-18T11:14:37.145Z","comments":true,"path":"2017/06/11/reactBase1/","link":"","permalink":"http://yoursite.com/2017/06/11/reactBase1/","excerpt":"","text":"react 安装对于入门的人来说，是从无到有的过程，首先我们要先了解一下如何使用框架1、首先要安装node.js 在Node下载，node的版本会影响你可用的功能和一些语法支持，所以尽量使用高版本的node2、node会自带npm包管理器，Npm，使用npm的指令来安装react项目中需要用到的组件，插件，翻译官(babel)等,如果下载缓慢的话可以采用taobao镜像，也可以使用yarn来安装，速度会快一些。1$ npm install -g cnpm --registry=https://registry.npm.taobao.org3、创建一个新的文件夹，在这个文件夹中调用命令窗口（Shift+右键）调用cmd命令窗口输入指令12$ npm init // 生成一个package.json文件 ，一步步配置文件信息$ npm init -y // 自动提取文件信息生成一个默认的package.json文件如果想使用yarn 首先要通过1$ npm install yarn -g //来安装之后就可以使用yarn的语法了4、安装react：123$ npm install react react-dom//或者$ yarn add react react-dom在react项目中还需要很多辅助插件：babel 这个翻译官 是在框架项目中必备的，它可以将项目中的es2015(es6)-es2017(es8)的语法转换成现在所有浏览器支持程度最高的es5语法；【注意】：像Set、Map这种是不会被翻译的。babel 的核心包 babel-core5、安装babel123$ npm babel-core babel-preset-stage-0 babel-preset-react babel-loader babel-preset-env --save-dev// --save-dev 是将安装这些依赖包安装在开发环境中在现在流行的框架开发中，有开发环境和生产环境，所谓的开发环境就是项目在开发过程中所依赖的环境；生产环境就是上线之后，项目面对用户的真实环境6、配置文件我们还需要在根目录下创建一个 .babelrc 文件（没有文件名称）在里面配置一些东西12345// .babelrc 文件内[ &quot;presets&quot;:[&quot;react&quot;,&quot;env&quot;,&quot;stage-0&quot;]]** env是可以解析es6及以前的语法，但是在用的后发现，他无法解析es6以上的一些草案语法，所以为了可以使用更高级的语法，在后面加上stage-0 保险起见；完成以上操作其实你就已经开启了你的react之旅了","categories":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/categories/前端框架/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"javascript Ajax","slug":"ajax","date":"2017-05-06T16:00:00.000Z","updated":"2018-03-18T11:18:44.130Z","comments":true,"path":"2017/05/07/ajax/","link":"","permalink":"http://yoursite.com/2017/05/07/ajax/","excerpt":"","text":"在学习AJAX原理的时候我尝试这封装过自己的AJAX，作为我学习AJAX的纪念吧123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157/* * 参数 * url : 请求地址 * method : 请求类型 * data : 请求参数 * dataType : 数据类型 * async : 是否异步 * cache : 是否清缓存 * success : 成功执行函数 * error : 失败后执行函数 * timeoutTimer : 等待时长*/(function () &#123; class ajaxFn &#123; constructor(url, options) &#123; // 如果传入的是一个对象的话，options 就被 url 替换 if (typeof url === &apos;object&apos;) &#123; options = url; url = undefined; &#125; options = Object.prototype.toString.call(options).slice(8, -1) === &apos;Object&apos; ? options : &#123;&#125;; this.url = url || options.url; this.options = &#123; method: options.type || options.method || &apos;GET&apos;, data: options.data || null, dataType: options.dataType || &apos;JSON&apos;, async: options.async || true, cache: options.cache || true, success: typeof options.success === &apos;function&apos; ? options.success : function () &#123; &#125;, error: typeof options.error === &apos;function&apos; ? options.error : function () &#123; &#125;, timeoutTimer: options.timeoutTimer || null &#125;; this.isGet = /(^|\\s+)(head|detele|get)(\\s+|$)/i.test(this.options.method); this.isLocal = window.XMLHttpRequest; &#125; formatData() &#123; if (Object.prototype.toString.call(this.options.data).slice(8, -1) === &apos;Object&apos;) &#123; let obj = this.options.data, str = ``; for (let key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; str += `$&#123;key&#125;=$&#123;obj[key]&#125;&amp;` &#125; &#125; str = str.replace(/&amp;$/g, &apos;&apos;); this.options.data = str; &#125; &#125; queryURL() &#123; return this.url.indexOf(&quot;?&quot;) === -1 ? &quot;?&quot; : &quot;&amp;&quot;; &#125; cacheFn() &#123; return !this.cache ? `$&#123;this.queryURL()&#125;_=$&#123;Math.random()&#125;` : ``; &#125; createStandardXHR() &#123; try &#123; return new window.XMLHttpRequest(); &#125; catch (e) &#123; &#125; &#125; createActiveXHR() &#123; try &#123; return new window.ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; catch (e) &#123; &#125; &#125; serialize(form) &#123; let parts = [], field = null, option, optValue; for (let i = 0; i &lt; form.elements.length; i++) &#123; field = form.elements[i]; switch (field.type) &#123; case &quot;select-one&quot;: case &quot;select-multiple&quot;: if (field.name.length) &#123; for (let j = 0; j &lt; field.options.length; j++) &#123; option = field.options[j]; if (option.selected) &#123; optValue = &apos;&apos;; if (optioin.hasAttribute) &#123; optValue = (option.hasAttribute(&apos;value&apos;) ? option.value : option.text); &#125; else &#123; optValue = (option.attributes[&apos;value&apos;].specified ? option.value : option.text); &#125; parts.push(encodeURIComponent(field.name) + &apos;=&apos; + encodeURIComponent(optValue)); &#125; &#125; &#125; break; case undefined: //字段集 case &apos;file&apos;: //文件输入 case &apos;submit&apos;: //提交按钮 case &apos;reset&apos;: //重置按钮 case &apos;button&apos;: //自定义按钮 break; case &apos;radio&apos;: //单选按钮 case &apos;checkbox&apos;: //复选框 if (!field.checked) &#123; break; &#125; break; default: if (field.name.length) &#123; parts.push(encodeURIComponent(field.name) + &apos;=&apos; + encodeURIComponent(field.value)); &#125; &#125; &#125; return parts.join(&apos;&amp;&apos;); &#125; &#125; window.ajax = function (url, options) &#123; let example = new ajaxFn(url, options); url = example.url || null; options = example.options || &#123;&#125;; let xhr = example.isLocal ? example.createStandardXHR() : example.createActiveXHR(); xhr.onreadystatechange = function () &#123; if (xhr.readyState === 2) &#123; let response = xhr.responseText; &#125; if (xhr.readyState === 4) &#123; if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status === 304) &#123; let response = xhr.responseText; options.success(response); &#125; if (xhr.status &gt;= 400 &amp;&amp; xhr.status &lt; 600) &#123; let response = xhr.responseText; options.error(response); &#125; &#125; &#125;; if (options.data != null) &#123; example.formatData(); if (example.isGet) &#123; url += example.queryURL() + encodeURIComponent(options.data); options.data = null; &#125; &#125; example.isGet &amp;&amp; (url += example.cacheFn()); xhr.open(options.method, url, options.async); xhr.send(options.data); &#125;;&#125;)();","categories":[{"name":"原生js","slug":"原生js","permalink":"http://yoursite.com/categories/原生js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"javascript Utils","slug":"jsCommonFn","date":"2017-05-05T16:00:00.000Z","updated":"2018-03-18T11:18:44.120Z","comments":true,"path":"2017/05/06/jsCommonFn/","link":"","permalink":"http://yoursite.com/2017/05/06/jsCommonFn/","excerpt":"","text":"平时在工作中我们在使用javascript开发的时候会很怀念jQuery，因为Jquery中很多的方法都非常的好用，而且还能兼容ie的低版本浏览器，虽然大家现在都在慢慢的抛弃ie低版本的浏览器，不过一些方法的封装思想还是要常常回顾一下，温故而知新嘛！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341var utils = (function () &#123; var _flag = /MSIE [678]/i.test(navigator.userAgent); var toTrim = function (str) &#123; return str.replace(/^\\s+|\\s+$/g, &apos;&apos;); &#125;; var toJSON = function (str) &#123; return window.JSON ? JSON.parse(str) : eval(&apos;(&apos; + str + &apos;)&apos;); &#125;; var toArray = function (classAry) &#123; var ary = []; if (!_flag) &#123; ary = Array.prototype.slice.call(classAry); &#125; else &#123; for (var i = 0; i &lt; classAry.length; i++) &#123; ary[ary.length] = classAry[i]; &#125; &#125; return ary; &#125;; var getEleClassName = function (strClass, context) &#123; context = context || document; if (!_flag) &#123; getEleClassName = function (strClass, context) &#123; context = context || document; return toArray(context.getElementsByClassName(strClass)); &#125; &#125; else &#123; getEleClassName = function (strClass, context) &#123; context = context || document; var result = [], classNode = context.getElementsByTagName(&apos;*&apos;); strClass = strClass.replace(/^\\s+|\\s+$/g, &apos;&apos;).split(/\\s+/); for (var i = 0; i &lt; classNode.length; i++) &#123; var item = classNode[i], itemClass = item.className, flag = true; for (var j = 0; j &lt; strClass.length; j++) &#123; var reg = new RegExp(&apos;(^|\\\\s)&apos; + strClass[j] + &apos;(\\\\s+|$)&apos;); if (!reg.test(itemClass)) &#123; flag = false; break; &#125; &#125; flag ? result.push(item) : null; &#125; return result; &#125; &#125; return getEleClassName(strClass, context); &#125;; var getEleChildren = function (curEle, tagName) &#123; var result = [], childNode = curEle.childNodes; for (var i = 0; i &lt; childNode.length; i++) &#123; var item = childNode[i]; if (item.nodeType === 1) &#123; if (tagName) &#123; if (item.nodeName === tagName.toLocaleUpperCase()) &#123; result.push(item); &#125; continue; &#125; result.push(item); &#125; &#125; return result; &#125;; var getCss = function (curEle, attr) &#123; if (!_flag) &#123; getCss = function (curEle, attr) &#123; var value = window.getComputedStyle(curEle, null)[attr]; var reg = /^-?\\d+(\\.\\d+)?(px|pt|em|rem)?$/g; reg.test(value) ? value = parseFloat(value) : null; return value; &#125; &#125; else &#123; getCss = function (curEle, attr) &#123; var value = null; if (attr === &apos;opacity&apos;) &#123; value = curEle.currentStyle[&apos;filter&apos;]; value = (value === &apos;&apos;) ? 1 : value.replace(/(?:=)(.+)(?:\\))/g, function () &#123; return arguments[1] / 100; &#125;) &#125; else &#123; value = curEle.currentStyle[attr]; &#125; var reg = /^-?\\d+(\\.\\d+)?(px|pt|em|rem)?$/g; reg.test(value) ? value = parseFloat(value) : null; return value; &#125; &#125; return getCss(curEle, attr); &#125;; var setCss = function (curEle, attr, value) &#123; if (attr === &apos;opacity&apos;) &#123; curEle.style[&apos;opacity&apos;] = value; curEle.style[&apos;filter&apos;] = &apos;alpha(opacity=&apos; + value * 100 + &apos;)&apos;; return; &#125; !isNaN(value) &amp;&amp; !/^(zIndex|zoom|fontWeight|lineHeight)$/i.test(attr) ? value += &apos;px&apos; : null; curEle.style[attr] = value; &#125;; var setGroupCss = function (curEle, options) &#123; if (Object.prototype.toString.call(options).slice(8, -1) !== &apos;Object&apos;) return; for (var key in options) &#123; if (options.hasOwnProperty(key)) &#123; setCss(curEle, key, options[key]); &#125; &#125; &#125;; var css = function () &#123; var len = arguments.length, fn = getCss, type = Object.prototype.toString.call(arguments[1]).slice(8, -1); len &gt;= 3 ? fn = setCss : (len === 2 &amp;&amp; type === &apos;Object&apos;) ? fn = setGroupCss : null; return fn.apply(this, arguments); &#125;; var offset = function (curEle) &#123; var $t = curEle.offsetTop, $l = curEle.offsetLeft, $p = curEle.offsetParent; while ($p.nodeName !== &apos;BODY&apos;) &#123; if (/MSIE 8/i.test(navigator.userAgent)) &#123; $t += $p.clientTop; $l += $p.clientLeft; &#125; $t += $p.offsetTop; $l += $p.offsetLeft; $p = $p.offsetParent; &#125; return &#123;top: $t, left: $l&#125;; &#125;; var winBox = function (attr, value) &#123; if (typeof value !== &apos;undefined&apos;) &#123; document.documentElement[attr] = value; document.body[attr] = value; return; &#125; return document.documentElement[attr] || document.body[attr] &#125;; var hasClass = function (curEle, cls) &#123; var flag = true, reg = null, curClassName = curEle.className; cls = toTrim(cls).split(/\\s+/); if (cls.length &lt;= 1) &#123; reg = new RegExp(&apos;(?:^|\\\\s+)&apos; + cls + &apos;(?:\\\\s+|$)&apos;); return curClassName.match(reg); &#125; else &#123; for (var i = 0; i &lt; cls.length; i++) &#123; reg = new RegExp(&apos;(?:^|\\\\s+)&apos; + cls[i] + &apos;(?:\\\\s+|$)&apos;); if (!reg.test(curClassName)) &#123; flag = false; break; &#125; &#125; return flag; &#125; &#125;; var addClass = function (curEle, cls) &#123; cls = toTrim(cls).split(/\\s+/); for (var i = 0; i &lt; cls.length; i++) &#123; if (!hasClass(curEle, cls[i])) &#123; curEle.className += &apos; &apos; + cls[i]; &#125; &#125; curEle.className = toTrim(curEle.className).replace(/\\s+/g, &apos; &apos;); &#125;; var removeClass = function (curEle, cls) &#123; cls = toTrim(cls).split(/\\s+/); for (var i = 0; i &lt; cls.length; i++) &#123; if (hasClass(curEle, cls[i])) &#123; var reg = new RegExp(&apos;(?:^|\\\\s)&apos; + cls[i] + &apos;(?:\\\\s|$)&apos;); curEle.className = curEle.className.replace(reg, &apos; &apos;); &#125; &#125; curEle.className = toTrim(curEle.className).replace(/\\s+/g, &apos; &apos;); &#125;; var addEventHandler = function (target, type, fn) &#123; if (target.addEventListener) &#123; target.addEventListener(type, fn); &#125; else &#123; target.attachEvent(&quot;on&quot; + type, fn); &#125; &#125;; var removeEventHandler = function (target, type, fn) &#123; if (target.removeEventListener) &#123; target.removeEventListener(type, fn); &#125; else &#123; target.detachEvent(&quot;on&quot; + type, fn); &#125; &#125;; var siblings = function (curEle, tagName) &#123; var result = []; var previous = curEle.previousSibling; var next = curEle.nextSibling; if (tagName) &#123; tagName = toTrim(tagName); if (/\\.[\\w-]/g.test(tagName)) &#123; tagName = tagName.replace(/\\./g, &apos;&apos;); var reg = new RegExp(&apos;(?:^|\\\\s+)&apos; + tagName + &apos;(?:\\\\s+|$)&apos;); while (previous) &#123; if (reg.test(previous.className)) &#123; result.unshift(previous); &#125; previous = previous.previousSibling; &#125; while (next) &#123; if (reg.test(next.className)) &#123; result.push(next) &#125; next = next.nextSibling; &#125; &#125; else &#123; while (previous) &#123; if (previous.nodeName === tagName.toLocaleUpperCase()) &#123; result.unshift(previous); &#125; previous = previous.previousSibling; &#125; while (next) &#123; if (next.nodeName === tagName.toLocaleUpperCase()) &#123; result.push(next) &#125; next = next.nextSibling; &#125; &#125; &#125; else &#123; while (previous) &#123; if (previous.nodeType === 1) &#123; result.unshift(previous); &#125; previous = previous.previousSibling; &#125; while (next) &#123; if (next.nodeType === 1) &#123; result.push(next); &#125; next = next.nextSibling; &#125; &#125; return result; &#125;; var find = function (curEle, cls) &#123; var result = []; var nodeList = curEle.getElementsByTagName(&apos;*&apos;); if (cls) &#123; cls = toTrim(cls); if (/\\.[\\w-]/g.test(cls)) &#123; cls = cls.replace(/\\./, &apos;&apos;); for (var i = 0; i &lt; nodeList.length; i++) &#123; var reg = new RegExp(&apos;(?:^|\\\\s+)&apos; + cls + &apos;(?:\\\\s+|$)&apos;); if (reg.test(nodeList[i].className)) &#123; result.push(nodeList[i]); &#125; &#125; &#125; else &#123; for (var j = 0; j &lt; nodeList.length; j++) &#123; if (nodeList[j].nodeName === cls.toLocaleUpperCase()) &#123; result.push(nodeList[j]); &#125; &#125; &#125; &#125; return result; &#125;; var getPrevEle = function (curEle) &#123; var item = curEle.previousSibling; while (item) &#123; if (item.nodeType === 1) &#123; return item; &#125; item = item.previousSibling; &#125; &#125;; var getPrevAll = function (curEle) &#123; var result = []; var previous = curEle.previousSibling; while (previous) &#123; if (previous.nodeName === 1) &#123; result.unshift(previous); &#125; previous = previous.previousSibling; &#125; return result; &#125;; var getNextEle = function (curEle) &#123; var item = curEle.nextSibling; while (item) &#123; if (item.nodeType === 1) &#123; return item; &#125; item = item.nextSibling; &#125; &#125;; var getNextAll = function (curEle) &#123; var result = []; var next = curEle.nextSibling; while (next) &#123; if (next.nodeName === 1) &#123; result.push(next); &#125; next = next.nextSibling; &#125; return result; &#125;; var getFirstChild = function(curEle)&#123; return getEleTagName(curEle)[0]; &#125;; var getLastChild = function(curEle)&#123; return getEleTagName(curEle)[getEleTagName(curEle).length-1]; &#125;; return &#123; toTrim: toTrim, toJSON: toJSON, toArray: toArray, getEleClassName: getEleClassName, getEleChildren: getEleChildren, css: css, offset: offset, winBox: winBox, hasClass: hasClass, addClass: addClass, removeClass: removeClass, addEventHandler: addEventHandler, removeEventHandler: removeEventHandler, siblings: siblings, find: find, getPrevEle:getPrevEle, getPrevAll:getPrevAll, getNextEle:getNextEle, getNextAll:getNextAll, getFirstChild:getFirstChild, getLastChild:getLastChild &#125;&#125;)();封装一些我们常用的方法，可以让我们的开发更具有效率。","categories":[{"name":"原生js","slug":"原生js","permalink":"http://yoursite.com/categories/原生js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]}]}