{"meta":{"title":"我的博客","subtitle":null,"description":null,"author":"杨波","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"react 基础篇（三）","slug":"reactBase3","date":"2018-03-16T02:47:05.659Z","updated":"2018-03-16T07:18:35.231Z","comments":true,"path":"2018/03/16/reactBase3/","link":"","permalink":"http://yoursite.com/2018/03/16/reactBase3/","excerpt":"","text":"react 的基本语法首先我们要了解react 的jsx语法react 使用 jsx 语法来代替常规的javascript 使用起来很像 html+javascript的组合jsx的优点 ：1、执行更快，因为它在编译为 JavaScript 代码后进行了优化2、它是类型安全的，在编译过程中就能发现错误3、使用 JSX 编写模板更加简单快速注意事项 ： 1、 想要在jsx中使用js语法需要使用‘{}’ 例： { this.state.name }2、 在jsx 中不能使用if else 可以改用三元运算符3、 jsx 中的注释写法 ：{/*注释…*/}我们先看一下这么一段代码123456789101112131415// 本篇文章代码必须引入的两个组件，后面的代码中省略import React from 'react';import ReactDOM from 'react-dom';let str = '20170109';function build(str) &#123; return ( &lt;div&gt; &lt;h1&gt;&#123;str&#125;&lt;/h1&gt; &lt;h2&gt;&#123;true ? str : null&#125;&lt;/h2&gt; &lt;/div&gt; )&#125;let el = &lt;div&gt;&#123;build('react的基本语法！')&#125;&lt;/div&gt;;ReactDOM.render(el, document.getElementById('root'));下面我们看一下组件的写法123456789101112131415161718192021let student1 = &#123;name: '小明', age: 15&#125;;let student2 = &#123;name: '李雷', age: 16&#125;;class Achievement extends React.Component &#123; render()&#123; // 这个组件在调用时，默认会调用render方法 let &#123;name,age&#125; = this.props; // 使用解构的方法可以让我们在写参数的时候更少 return &lt;p&gt;&#123;name&#125; &#123;age&#125;&lt;/p&gt;; // 也可以 return &lt;p&gt;&#123;this.props.name&#125; &#123;this.props.age&#125;&lt;/p&gt; &#125;&#125;// 组件的传参的两种方法，可以使用es6的解构方式，也可以一个个传ReactDOM.render(&lt;div&gt; &lt;Achievement &#123;...student1&#125;/&gt; &lt;Achievement name=&#123;student2.name&#125; age=&#123;student2.age&#125;/&gt;&lt;/div&gt;, window.root);// 注意 ： &lt;Achievement age=9/&gt; 这样传递参数的时候，在组件内部调用this.props.age 的时候是字符串类型而不是数字类型---列表类的输出方式12345678910111213141516let students = [ &#123;name: '李雷', sex: '男'&#125;, &#123;name: '李华', sex: '男'&#125;, &#123;name: '小红', sex: '女'&#125;];ReactDOM.render(( &lt;ul&gt; &#123;lessons.map((item, index) =&gt; ( &lt;li key=&#123;index&#125;&gt;姓名：&#123;item.name&#125;;性别：&#123;item.sex&#125;&lt;/li&gt; ) )&#125; &lt;/ul&gt;), document.getElementById('root'));一定要注意的是 如果你有代码的格式洁癖，请用() 将代码包裹起来，防止react不能正常解析这段代码，在react中循环输出的时候一定要在输出的元素上添加 key 属性，否则会出现警报，虽然这个警报不会影响你代码的执行，但是会影响性能，因为在react 中保证性能的 DOM Diff 会使用到这个属性 ,不是本篇文章的讨论范围属性上的渲染123456789101112131415let style = &#123; backgroundColor : 'red', color : 'blue', fontSize : '20px'&#125;;ReactDOM.render(( &lt;ul style=&#123;style&#125;&gt; &lt;li className='aa'&gt;1&lt;/li&gt; &lt;li&gt;&lt;label htmlFor='aa'&gt;-&lt;/label&gt;&lt;input id='aa'/&gt;&lt;/li&gt; &lt;li dangerouslySetInnerHTML=&#123;&#123;__html:'&lt;span&gt;123&lt;/span&gt;'&#125;&#125;&gt;&lt;/li&gt; &lt;/ul&gt;),window.root);// 这里需要注意的是 这里的style是对象数据类型要了解是react中dom的属性有一些已经变成react中的关键字，所以写法上会和以前的写法不同，例如：class -&gt; className; for -&gt; htmlFor …如果你必不可免的要在一个结构中插入许多标签，可以使用dangerouslySetInnerHTML（安全插入），因为有可能不合时宜的使用innerHTML会导致XSS攻击；事件上的绑定1234567891011121314151617181920212223242526272829303132333435363738394041// 我们以input 来举例， 顺便也说以下react 实现双向数据绑定的方法// 写法一class Input extends React.Component&#123; constructor()&#123; super(); this.state = &#123;val:''&#125; &#125; handleFn(e)&#123; this.setState(&#123;val:e.target.value&#125;); &#125; render()&#123; return ( &lt;div&gt; &lt;input type=\"text\" value=&#123;this.state.val&#125; onChange=&#123;this.handleFn.bind(this)&#125;/&gt; &#123;this.state.val&#125; &lt;/div&gt; ) &#125;&#125;// 写法二class Input extends React.Component&#123; constructor()&#123; super(); this.state = &#123;val:''&#125; &#125; handleFn = (e)=&gt;&#123; this.setState(&#123;val:e.target.value&#125;); &#125; render()&#123; return ( &lt;div&gt; &lt;input type=\"text\" value=&#123;this.state.val&#125; onChange=&#123;this.handleFn&#125;/&gt; &#123;this.state.val&#125; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;Input/&gt;,window.root);上面有两种写法，当然第二种使用了es6和es7的语法所以写起来很简洁，也不用担心this错误的问题，所以在babel可以解析的语法，我们都可以在项目中使用我们简单说一下 react 的双向数据绑定，大家都知道react 是 MVC框架（单向数据绑定），所以我们想实现双向数据绑定就要借助其他的方法，react 能引起视图渲染的方法只有修改state和props，所以我们想要是想双向数据绑定，我们就要去操作state和props，那我们实现一下1234567891011121314151617181920212223242526272829303132333435363738class Parent extends React.Component &#123; constructor() &#123; super(); this.state = &#123;val: ''&#125; &#125; changeFn = (e) =&gt; &#123; this.setState(&#123;val: e.target.value&#125;); &#125;; render() &#123; return ( &lt;Input value=&#123;this.state.val&#125; changeFn=&#123;this.changeFn&#125;/&gt; ) &#125;&#125;class Input extends React.Component &#123; constructor() &#123; super(); this.state = &#123;val: ''&#125; &#125; handleFn = (e) =&gt; &#123; this.setState(&#123;val: e.target.value&#125;); &#125;; render() &#123; let &#123;value,changeFn&#125; = this.props; return ( &lt;div&gt; &lt;input type=\"text\" value=&#123;this.state.val&#125; onChange=&#123;this.handleFn&#125;/&gt; &#123;this.state.val&#125; &lt;input type=\"text\" value=&#123;value&#125; onChange=&#123;changeFn&#125;/&gt; &#123;value&#125; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;Parent/&gt;,window.root)需要用事件来触发state或者props的修改来让视图重新渲染，来实现双向绑定还有一种不提倡的方法，就是直接通过ref 来操作DOM也可以实现，不过既然使用react了，还在操作DOM 那就太low了。所以我们要习惯这种数据驱动视图的思想。","categories":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/categories/前端框架/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"react 基础篇（二）","slug":"reactBase2","date":"2018-03-15T12:06:02.222Z","updated":"2018-03-15T16:15:52.404Z","comments":true,"path":"2018/03/15/reactBase2/","link":"","permalink":"http://yoursite.com/2018/03/15/reactBase2/","excerpt":"","text":"webpack 的基本配置想要实现项目的自动化管理，还是需要依赖自动化构建工具，这篇文章主要讲述的是webpack的基本配置12$ npm install webpack webpack-dev-server --save-dev // 或者使用yarn$ npm install style-loader css-loader url-loader file-loader less-loader html-webpack-plugin --save-dev上面安装的的是一个项目基本必须要使用的一些依赖包，现在新出webpack4 还需要安装webpack-cli（必须安装的）安装完成之后我们来看一下webpack该如何配置1234567891011121314151617181920212223242526// 这个插件是为了webpack打包后的代码可以插入到我们html中的let HtmlWebpackPlugin = require(\"html-webpack-plugin\");// 我们先配置一个文件配置module.exports = &#123; entry: \"./src/index.js\", // 入口文件 output: &#123; // 出口 filename: \"build.js\", // 文件名 path: require('path').resolve('/dist') // 文件路径，这个需要填写绝对路径，所以我们引用path插件，来将一个相对路径转换成绝对路径 &#125;, module: &#123; rules: [ // 配置文件解析规则， &#123;test: /\\.js$/, use: \"babel-loader\", exclude: /node_modules/&#125;, &#123;test: /\\.css$/, use: [\"style-loader\", \"css-loader\"]&#125;, &#123;test: /\\.less$/, use: [\"style-loader\", \"css-loader\", \"less-loader\"]&#125;, &#123;test: /\\.(jpg|png|gif|jpeg)$/, use: \"url-loader\"&#125;, ] &#125;, devtool: 'source-map', /*源码映射*/ plugins: [ // 插件 new HtmlWebpackPlugin(&#123; template: \"./index.html\" &#125;) ]&#125;;多个文件的配置方法1234567891011module.exports = &#123; entry: &#123; app: &apos;./src/app.js&apos;, search: &apos;./src/search.js&apos; &#125;, output: &#123; filename: &apos;[name].js&apos;, path: __dirname + &apos;/dist&apos; &#125; ......&#125;webpack还有更多的配置参数，我们先配置一个简单的当然我们想要将环境跑起来，还需要在package.json文件中的scripts中配置一些启动环境的指令123456// 截取部分代码\"scripts\": &#123; \"dev\": \"webpack-dev-server --config webpack.config.js\", \"start\": \"npm run dev\", \"build\": \"webpack --config webpack.config.js\" // 打包时使用的代码 &#125;,配置完成后，我们就可以执行 start 来开启一个本地端口来运行我们的代码了是不是很简单呢，快来写一写react代码来感受一下吧","categories":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/categories/前端框架/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"react 声明周期","slug":"reactLifeCycle","date":"2018-03-14T12:51:51.282Z","updated":"2018-03-15T07:04:38.831Z","comments":true,"path":"2018/03/14/reactLifeCycle/","link":"","permalink":"http://yoursite.com/2018/03/14/reactLifeCycle/","excerpt":"","text":"react 的声明周期先上一张图，我们会根据这张图来分析react的声明周期其实是可以分为两大类的，第一种是组件实例化时只执行一次的，第二种是组件存在时会跟着组件内部操作而触发的；那就让我们分别来看看他们在react的一个组件组件中所充当的角色一、getDefaultProps12345678910111213import React from 'react'; *以后的代码省略这行代码了import PropTypes from 'prop-types';class Component extends React.Component&#123; static defaultProps = &#123; name: 'yang' &#125; render() &#123; return ( &lt;div&gt;Hello, &#123;this.props.name&#125;&lt;/div&gt; ) &#125;&#125;当组件实例化的时候会执行defaultProps这个函数，作用是设置组件所需参数的默认值、也可以配合prop-types这个包来进行参数验证prop-types注释 ： extends 是 es6 中类继承的语法；123456789 // 例如： 你想让类A 继承类B 那么写法 就是class A extends B &#123; //(类的名字最好是首字母大写，保持这种良好的代码风格) constructor()&#123; super(); // 在es5 一个构造函数继承另外一个构造函数的时候，会有很多方法：call继承，原型继承，组合式继承，寄生组合式继承（如果不知道的小伙变要好好学习了） // 而es6 中类继承则是通过super来进行的 ，super的特性不属于本篇文章的讨论范围，如果感兴趣的话可以去翻查一下 &#125;&#125;二、getInitialState12345678class Component extends React.Component&#123; constructor()&#123; super(); this.state = &#123; render: true &#125; &#125;&#125;当组件实例化的时候会对实例的一些私有属性进行初始化，对es6语法了解的话，应该很容易理解，如果对es6的class类的语法不了解的话建议大家先去了解一下es6, state是组件内部状态，这个属性十分的重要，state的属性变更会直接影响这组件的渲染三、componentWillMount是组件挂载前的最后一个生命周期，只执行一次，最后修改state的机会四 render12345678910111213class Component extends React.Component&#123; constructor()&#123; super(); this.state = &#123; name: &apos;yang&apos; &#125; &#125; render()&#123; return ( &lt;div&gt; `hello $&#123;this.state.name&#125;`&lt;/div&gt; ) &#125;&#125;组件渲染，render方法会根据return 的返回结果生成虚拟的DOM，经过react内部机制的DOM Diff 比对后，渲染到页面上。在render函数中有几个注意事项:1) 必须存在一个根节点2) 不可以修改state3) 可以输出null，false五 componentDidMount组件挂载完成，通常我们会在这个生命周期函数内进行页面数据的请求操作， 只会执行一次六 componentWillReceiveProps1234567891011121314151617181920class Component extends React.Component&#123; constructor()&#123; super(); this.state = &#123; name: this.props.name || 'yang' &#125; &#125; componentWillReceiveProps(nextProps)&#123; if(typeof nextProps.name !== 'undefined')&#123; this.setState(&#123; name: nextProps.name &#125;) &#125; &#125; render()&#123; return ( &lt;div&gt; `hello $&#123;this.state.name&#125;`&lt;/div&gt; ) &#125;&#125;当外部传入的参数发生改变的时候会触发componentWillReceiveProps这个函数的执行，在函数里可以修改本组件的state值，不用担心会引起render的多次调用七 shouldComponentUpdate12345678910111213141516class Component extends React.Component&#123; constructor()&#123; super(); this.state = &#123; name: this.props.name || 'yang' &#125; &#125; shouldComponentUpdate(nextProps,nextState)&#123; return nextProps.name != this.props.name; &#125; render()&#123; return ( &lt;div&gt; `hello $&#123;this.state.name&#125;`&lt;/div&gt; ) &#125;&#125;这个生命周期函数是在props和state发生改变时必然会触发的，如果没有手动声明，默认为true ，如果手动设置为false 组件将不会在更新；这个生命周期是开发者在react开发的时候对性能优化上帮助最大的，很多开发这都轻视了这个函数。八 componentWillUpdatestate或者props发生改变时，在组件准备更新之前执行的生命周期函数，在这个生命周期内不要在去修改state和props 不然后果很严重九 componentDidUpdate组件重新渲染后会被调用，在这个函数中可以获取到更新之后的数据和dom元素十 componentWillUnmount当用户执行移除组件或者删除组件的操作后，在执行前触发的生命周期函数，但是react对善后工作做的不是很到位，如果你在组件中创建了计时器这种异步操作事件，在componentWillUnmount函数中一定要手动的移除这些事件，否则会报错123456789101112131415161718192021222324class Component extends React.Component&#123; constructor()&#123; super(); this.state = &#123; name: this.props.name || 'yang' &#125; &#125; componentDidMount()&#123; this.timer = setTimeout(()=&gt;&#123; this.setState(&#123;name:'我要卸载了'&#125;) &#125;,5000) &#125; componentWillUnmount()&#123; clearTimeout(this.timer) &#125; handelClick()&#123; ReactDom.unmountComponentAtNode(window.root) &#125; render()&#123; return ( &lt;div onClick=&#123;this.handelClick&#125;&gt; `hello $&#123;this.state.name&#125;`&lt;/div&gt; ) &#125;&#125;对react 生命周期的以一些理解，希望对您有帮助，图中conponentWillReceiveProps 应该是com 拼错了","categories":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/categories/前端框架/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"react 基础篇（一）","slug":"reactBase1","date":"2018-03-14T12:10:53.348Z","updated":"2018-03-16T06:33:26.650Z","comments":true,"path":"2018/03/14/reactBase1/","link":"","permalink":"http://yoursite.com/2018/03/14/reactBase1/","excerpt":"","text":"react 安装对于入门的人来说，是从无到有的过程，首先我们要先了解一下如何使用框架1、首先要安装node.js 在Node下载，node的版本会影响你可用的功能和一些语法支持，所以尽量使用高版本的node2、node会自带npm包管理器，Npm，使用npm的指令来安装react项目中需要用到的组件，插件，翻译官(babel)等,如果下载缓慢的话可以采用taobao镜像，也可以使用yarn来安装，速度会快一些。3、创建一个新的文件夹，在这个文件夹中调用命令窗口（Shift+右键）， 输入指令 npm init 初始化项目；如果想使用yarn 首先要通过 npm install yarn -g 来安装 之后就科一是用yarn的语法了4、安装react：npm install react react-dom / yarn add react react-dom 两者效果是等同的在react项目中还需要很多辅助插件：babel 这个翻译官 是在框架项目中必备的，它可以将项目中的es2015(es6)-es2017(es8)的语法转换成现在所有浏览器支持程度最高的es5语法；【注意】：像Set、Map这种是不会被翻译的。babel 的核心包 babel-core 和相关依赖 babel-preset-stage-0 babel-preset-react babel-loader babel-preset-env –save-dev 都是会被用到的, –save-dev 是将安装这些依赖包安装在开发环境中我们还需要在根目录下创建一个 .babelrc 文件（没有文件名称）在里面配置[“presets”:[“react”,”env”,”stage-0”]]** env是可以解析es6及以前的语法，但是在用的后发现，他无法解析es6以上的一些草案语法，所以为了可以使用更高级的语法，在后面加上stage-0 保险起见；那什么是开发环境呢？在现在流行的框架开发中，有开发环境和生产环境，所谓的开发环境就是项目在开发过程中所依赖的环境；生产环境就是上线之后，项目面对用户的真实环境完成以上操作其实你就已经开启了你的react之旅了","categories":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/categories/前端框架/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]}]}