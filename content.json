{"meta":{"title":"我的博客","subtitle":null,"description":null,"author":"杨波","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"ant Design（1）","slug":"antDesign","date":"2018-07-16T16:00:00.000Z","updated":"2018-07-17T08:41:30.370Z","comments":true,"path":"2018/07/17/antDesign/","link":"","permalink":"http://yoursite.com/2018/07/17/antDesign/","excerpt":"","text":"ant Design栅格布局 (24 栅格布局)概述布局的栅格化系统，我们是基于行（row）和列（col）来定义信息区块的外部框架，以保证页面的每个区域能够稳健地排布起来。下面简单介绍一下它的工作原理：通过row在水平方向建立一组column（简写col）你的内容应当放置于col内，并且，只有col可以作为row的直接元素栅格系统中的列是指1到24的值来表示其跨越的范围。例如，三个等宽的列可以使用.col-8来创建如果一个row中的col总和超过 24，那么多余的col会作为一个整体另起一行排列使用方式1234567891011121314151617181920212223242526272829import React from &apos;react&apos;import ReactDOM from &apos;react-dom&apos;import &#123; Row, Col &#125; from &apos;antd&apos;;// (n 是自然数)// 栅格常常需要和间隔进行配合，你可以使用 Row 的 gutter 属性，我们推荐使用 (16+8n)px 作为栅格间隔。// Col 的 span 属性是指 Col 在 Row 中 n 份// Col 的 offset 属性是指元素向右偏移 n 列的宽度ReactDOM.render( &lt;div&gt; &lt;Row gutter=&#123;16&#125;&gt; // 样例 &lt;Col span=&#123;12&#125;&gt;col-12&lt;/Col&gt; &lt;Col span=&#123;6&#125; offset=&#123;6&#125;&gt;col-12&lt;/Col&gt; &lt;/Row&gt; &lt;Row&gt; &lt;Col span=&#123;8&#125;&gt;col-8&lt;/Col&gt; &lt;Col span=&#123;8&#125;&gt;col-8&lt;/Col&gt; &lt;Col span=&#123;8&#125;&gt;col-8&lt;/Col&gt; &lt;/Row&gt; &lt;Row&gt; &lt;Col span=&#123;6&#125;&gt;col-6&lt;/Col&gt; &lt;Col span=&#123;6&#125;&gt;col-6&lt;/Col&gt; &lt;Col span=&#123;6&#125;&gt;col-6&lt;/Col&gt; &lt;Col span=&#123;6&#125;&gt;col-6&lt;/Col&gt; &lt;/Row&gt; &lt;/div&gt;, mountNode);Row 和 Col 的参数Rowalign：flex 布局下的垂直对齐方式：top middle bottom类型：string默认值： topgutter：栅格间隔；默认值：0类型：number默认值： 0justify ：flex 布局下的水平排列方式：start end center space-around space-between类型：string默认值： starttype：布局模式，可选 flex，现代浏览器下有效类型：stringColoffset：栅格左侧的间隔格数，间隔内不可以有栅格类型：number默认值： 0order：栅格栅格顺序，flex 布局模式下有效类型：number默认值： 0pull：栅格栅格向左移动格数类型：number默认值： 0push：栅格向右移动格数类型：number默认值： 0span：栅格占位格数，为 0 时相当于 display: none类型：numberxs：&lt;768px 响应式栅格，可为栅格数或一个包含其他属性的对象类型：number | objectsm：≥768px 响应式栅格，可为栅格数或一个包含其他属性的对象类型：numbermd：≥992px 响应式栅格，可为栅格数或一个包含其他属性的对象类型：number | objectlg：≥1200px 响应式栅格，可为栅格数或一个包含其他属性的对象类型：number | objectxl：≥1600px 响应式栅格，可为栅格数或一个包含其他属性的对象类型：number | objectLayout 布局设计规划尺寸顶部导航（大部分系统）：一级导航高度 64px，二级导航 48px顶部导航（展示类页面）：一级导航高度 80px，二级导航 56px顶部导航高度的范围计算公式为：48+8n侧边导航宽度的范围计算公式：200+8n交互一级导航和末级的导航需要在可视化的层面被强调出来；当前项应该在呈现上优先级最高；当导航收起的时候，当前项的样式自动赋予给它的上一个层级；左侧导航栏的收放交互同时支持手风琴和全展开的样式，根据业务的要求进行适当的选择。Layout 及 组件成员Layout：布局容器，其下可嵌套 Header Sider Content Footer 或 Layout 本身，可以放在任何父容器中。Header：顶部布局，自带默认样式，其下可嵌套任何元素，只能放在 Layout 中。Sider：侧边栏，自带默认样式及基本功能，其下可嵌套任何元素，只能放在 Layout 中。Content：内容部分，自带默认样式，其下可嵌套任何元素，只能放在 Layout 中。Footer：底部布局，自带默认样式，其下可嵌套任何元素，只能放在 Layout 中。用法123456789101112131415161718192021222324252627282930313233// 最基本的上中下布局import &#123; Layout, Menu, Breadcrumb &#125; from &apos;antd&apos;;const &#123; Header, Content, Footer &#125; = Layout;ReactDOM.render( &lt;Layout className=&quot;layout&quot;&gt; &lt;Header&gt; &lt;div className=&quot;logo&quot; /&gt; &lt;Menu theme=&quot;dark&quot; mode=&quot;horizontal&quot; defaultSelectedKeys=&#123;[&apos;2&apos;]&#125; style=&#123;&#123; lineHeight: &apos;64px&apos; &#125;&#125; &gt; &lt;Menu.Item key=&quot;1&quot;&gt;nav 1&lt;/Menu.Item&gt; &lt;Menu.Item key=&quot;2&quot;&gt;nav 2&lt;/Menu.Item&gt; &lt;Menu.Item key=&quot;3&quot;&gt;nav 3&lt;/Menu.Item&gt; &lt;/Menu&gt; &lt;/Header&gt; &lt;Content style=&#123;&#123; padding: &apos;0 50px&apos; &#125;&#125;&gt; &lt;Breadcrumb style=&#123;&#123; margin: &apos;16px 0&apos; &#125;&#125;&gt; &lt;Breadcrumb.Item&gt;Home&lt;/Breadcrumb.Item&gt; &lt;Breadcrumb.Item&gt;List&lt;/Breadcrumb.Item&gt; &lt;Breadcrumb.Item&gt;App&lt;/Breadcrumb.Item&gt; &lt;/Breadcrumb&gt; &lt;div style=&#123;&#123; background: &apos;#fff&apos;, padding: 24, minHeight: 280 &#125;&#125;&gt;Content&lt;/div&gt; &lt;/Content&gt; &lt;Footer style=&#123;&#123; textAlign: &apos;center&apos; &#125;&#125;&gt; Ant Design ©2016 Created by Ant UED &lt;/Footer&gt; &lt;/Layout&gt;, mountNode);Layout 参数className ：容器 className类型： stringstyle ：指定样式类型： objectLayout.Siderbreakpoint：触发响应式布局的断点类型： Enum { ‘xs’, ‘sm’, ‘md’, ‘lg’, ‘xl’ }className：容器 className类型： stringcollapsed：当前收起状态类型： booleancollapsedWidth：收缩宽度，设置为 0 会出现特殊 trigger类型： numbercollapsible：是否可收起类型： booleandefaultCollapsed：是否默认收起类型： booleanreverseArrow：翻转折叠提示箭头的方向，当 Sider 在右边时可以使用类型： booleanstyle：指定样式类型： objecttrigger：自定义 trigger，设置为 null 时隐藏 trigger类型： string | ReactNodewidth：宽度类型： number | stringonCollapse：展开-收起时的回调函数，有点击 trigger 以及响应式反馈两种方式可以触发类型：(collapsed, type) =&gt; {}Affix 固钉使用方法1234567891011121314151617import &#123; Affix, Button &#125; from &apos;antd&apos;;ReactDOM.render( &lt;div&gt; &lt;Affix offsetTop=&#123;10&#125; onChange=&#123;affixed =&gt; console.log(affixed)&#125;&gt; &lt;Button type=&quot;primary&quot;&gt;Affix top&lt;/Button&gt; &lt;/Affix&gt; &lt;br /&gt; &lt;Affix offsetBottom=&#123;0&#125;&gt; &lt;Button type=&quot;primary&quot;&gt;Affix bottom&lt;/Button&gt; &lt;/Affix&gt; &lt;/div&gt;, mountNode);// 官方滚动容器demo是有一些小问题的，当容器内滚动定位后，再滚动页面的滚动条后，定位的元素会脱离滚动容器的限制，问题原因是因为使用了fix定位导致的，当窗口是一屏的时候不会出现这个问题，但是如果页面超过一屏的时候，fix 相对于浏览器窗口定位的问题就出现了，使用的时候要慎重使用// 官方给出的解决方案是&lt;Affix style=&#123;&#123; position: &apos;absolute&apos;, top: y, left: x&#125;&#125;&gt;&lt;/Affix&gt;；我们可以手动将 fix 定位改成 absolute 定位Affix 参数offsetBottom ： 距离窗口底部达到指定偏移量后触发类型 ：numberoffsetTop ： 距离窗口顶部达到指定偏移量后触发类型 ：numbertarget ： 设置 Affix 需要监听其滚动事件的元素，值为一个返回对应 DOM 元素的函数类型 ： () =&gt; HTMLElement默认值 ： () =&gt; windowonChange ： 固定状态改变时触发的回调函数类型 ： Function(affixed)Breadcrumb面包屑使用方法12345678910import &#123; Breadcrumb &#125; from &apos;antd&apos;;ReactDOM.render( &lt;Breadcrumb&gt; &lt;Breadcrumb.Item&gt;Home&lt;/Breadcrumb.Item&gt; &lt;Breadcrumb.Item&gt;&lt;a href=&quot;&quot;&gt;Application Center&lt;/a&gt;&lt;/Breadcrumb.Item&gt; &lt;Breadcrumb.Item&gt;&lt;a href=&quot;&quot;&gt;Application List&lt;/a&gt;&lt;/Breadcrumb.Item&gt; &lt;Breadcrumb.Item&gt;An Application&lt;/Breadcrumb.Item&gt; &lt;/Breadcrumb&gt;, mountNode);1234567891011121314151617181920212223242526272829303132333435363738// 配合react-router@3 搭建面包屑import &#123; Router, Route, Link, hashHistory &#125; from &apos;react-router&apos;;import &#123; Breadcrumb, Alert &#125; from &apos;antd&apos;;const Apps = () =&gt; ( &lt;ul className=&quot;app-list&quot;&gt; &lt;li&gt; &lt;Link to=&quot;/apps/1&quot;&gt;Application1&lt;/Link&gt;：&lt;Link to=&quot;/apps/1/detail&quot;&gt;Detail&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&quot;/apps/2&quot;&gt;Application2&lt;/Link&gt;：&lt;Link to=&quot;/apps/2/detail&quot;&gt;Detail&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt;);const Home = (&#123; routes, params, children &#125;) =&gt; ( &lt;div className=&quot;demo&quot;&gt; &lt;div className=&quot;demo-nav&quot;&gt; &lt;Link to=&quot;/&quot;&gt;Home&lt;/Link&gt; &lt;Link to=&quot;/apps&quot;&gt;Application List&lt;/Link&gt; &lt;/div&gt; &#123;children || &apos;Home Page&apos;&#125; &lt;Alert style=&#123;&#123; margin: &apos;16px 0&apos; &#125;&#125; message=&quot;Click the navigation above to switch:&quot; /&gt; &lt;Breadcrumb routes=&#123;routes&#125; params=&#123;params&#125; /&gt; &lt;/div&gt;);ReactDOM.render( &lt;Router history=&#123;hashHistory&#125;&gt; &lt;Route name=&quot;home&quot; breadcrumbName=&quot;Home&quot; path=&quot;/&quot; component=&#123;Home&#125;&gt; &lt;Route name=&quot;apps&quot; breadcrumbName=&quot;Application List&quot; path=&quot;apps&quot; component=&#123;Apps&#125;&gt; &lt;Route name=&quot;app&quot; breadcrumbName=&quot;Application:id&quot; path=&quot;:id&quot;&gt; &lt;Route name=&quot;detail&quot; breadcrumbName=&quot;Detail&quot; path=&quot;detail&quot; /&gt; &lt;/Route&gt; &lt;/Route&gt; &lt;/Route&gt; &lt;/Router&gt;, mountNode);123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 配合react-router@4 搭建面包屑import &#123; HashRouter as Router, Route, Switch, Link, withRouter &#125; from &apos;react-router-dom&apos;;import &#123; Breadcrumb, Alert &#125; from &apos;antd&apos;;const Apps = () =&gt; ( &lt;ul className=&quot;app-list&quot;&gt; &lt;li&gt; &lt;Link to=&quot;/apps/1&quot;&gt;Application1&lt;/Link&gt;：&lt;Link to=&quot;/apps/1/detail&quot;&gt;Detail&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&quot;/apps/2&quot;&gt;Application2&lt;/Link&gt;：&lt;Link to=&quot;/apps/2/detail&quot;&gt;Detail&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt;);const breadcrumbNameMap = &#123; &apos;/apps&apos;: &apos;Application List&apos;, &apos;/apps/1&apos;: &apos;Application1&apos;, &apos;/apps/2&apos;: &apos;Application2&apos;, &apos;/apps/1/detail&apos;: &apos;Detail&apos;, &apos;/apps/2/detail&apos;: &apos;Detail&apos;,&#125;;const Home = withRouter((props) =&gt; &#123; const &#123; location &#125; = props; const pathSnippets = location.pathname.split(&apos;/&apos;).filter(i =&gt; i); const extraBreadcrumbItems = pathSnippets.map((_, index) =&gt; &#123; const url = `/$&#123;pathSnippets.slice(0, index + 1).join(&apos;/&apos;)&#125;`; return ( &lt;Breadcrumb.Item key=&#123;url&#125;&gt; &lt;Link to=&#123;url&#125;&gt; &#123;breadcrumbNameMap[url]&#125; &lt;/Link&gt; &lt;/Breadcrumb.Item&gt; ); &#125;); const breadcrumbItems = [( &lt;Breadcrumb.Item key=&quot;home&quot;&gt; &lt;Link to=&quot;/&quot;&gt;Home&lt;/Link&gt; &lt;/Breadcrumb.Item&gt; )].concat(extraBreadcrumbItems); return ( &lt;div className=&quot;demo&quot;&gt; &lt;div className=&quot;demo-nav&quot;&gt; &lt;Link to=&quot;/&quot;&gt;Home&lt;/Link&gt; &lt;Link to=&quot;/apps&quot;&gt;Application List&lt;/Link&gt; &lt;/div&gt; &lt;Switch&gt; &lt;Route path=&quot;/apps&quot; component=&#123;Apps&#125; /&gt; &lt;Route render=&#123;() =&gt; &lt;span&gt;Home Page&lt;/span&gt;&#125; /&gt; &lt;/Switch&gt; &lt;Alert style=&#123;&#123; margin: &apos;16px 0&apos; &#125;&#125; message=&quot;Click the navigation above to switch:&quot; /&gt; &lt;Breadcrumb&gt; &#123;breadcrumbItems&#125; &lt;/Breadcrumb&gt; &lt;/div&gt; );&#125;);ReactDOM.render( &lt;Router&gt; &lt;Home /&gt; &lt;/Router&gt;, mountNode);12345678910111213141516171819// 配合 browserHistory 搭建面包屑导航import &#123; Link &#125; from &apos;react-router&apos;;const routes = [&#123; path: &apos;index&apos;, breadcrumbName: &apos;首页&apos;&#125;, &#123; path: &apos;first&apos;, breadcrumbName: &apos;一级面包屑&apos;&#125;, &#123; path: &apos;second&apos;, breadcrumbName: &apos;当前页面&apos;&#125;];function itemRender(route, params, routes, paths) &#123; const last = routes.indexOf(route) === routes.length - 1; return last ? &lt;span&gt;&#123;route.breadcrumbName&#125;&lt;/span&gt; : &lt;Link to=&#123;paths.join(&apos;/&apos;)&#125;&gt;&#123;route.breadcrumbName&#125;&lt;/Link&gt;;&#125;return &lt;Breadcrumb itemRender=&#123;itemRender&#125; routes=&#123;routes&#125;/&gt;;Breadcrumb 参数itemRender ： 自定义链接函数，和 react-router 配置使用类型 ：(route, params, routes, paths) =&gt; ReactNodeparams ： 路由的参数类型 ： objectroutes ： router 的路由栈信息类型 ： object[]separator ： 分隔符自定义类型 ： string | ReactNode默认值 ： ‘ / ‘Dropdown下拉菜单使用方法123456789101112131415161718192021222324252627282930313233import &#123; Menu, Dropdown, Icon &#125; from &apos;antd&apos;;const onClick = function (&#123; key &#125;) &#123; message.info(`Click on item $&#123;key&#125;`);&#125;;// 如果需要在点击选项的时候触发处理一些事情可以在 Menu 组件的 onClick 中处理const menu = ( &lt;Menu onClick=&#123;onClick&#125;&gt; &lt;Menu.Item key=&apos;1&apos;&gt; &lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;http://www.alipay.com/&quot;&gt;1st menu item&lt;/a&gt; &lt;/Menu.Item&gt; &lt;Menu.Item key=&apos;2&apos;&gt; &lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;http://www.taobao.com/&quot;&gt;2nd menu item&lt;/a&gt; &lt;/Menu.Item&gt; &lt;Menu.Divider /&gt; // 下拉分割线 &lt;Menu.Item key=&apos;3&apos;&gt; &lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;http://www.tmall.com/&quot;&gt;3rd menu item&lt;/a&gt; &lt;/Menu.Item&gt; &lt;SubMenu title=&quot;sub menu&quot;&gt; // 多级菜单 &lt;Menu.Item&gt;3rd menu item&lt;/Menu.Item&gt; &lt;Menu.Item&gt;4th menu item&lt;/Menu.Item&gt; &lt;/SubMenu&gt; &lt;/Menu&gt;);ReactDOM.render( &lt;Dropdown overlay=&#123;menu&#125;&gt; &lt;a className=&quot;ant-dropdown-link&quot; href=&quot;#&quot;&gt; Hover me &lt;Icon type=&quot;down&quot; /&gt; &lt;/a&gt; &lt;/Dropdown&gt;, mountNode);Dropdown 参数disabled ： 菜单是否禁用类型 ： booleangetPopupContainer ： 菜单渲染父节点。默认渲染到 body 上，如果你遇到菜单滚动定位问题，试试修改为滚动的区域，并相对其定位类型 ： Function(triggerNode)默认值 ： () =&gt; document.bodyoverlay ： 菜单类型 ： Menuplacement ： 菜单弹出位置：bottomLeft bottomCenter bottomRight topLeft topCenter topRight类型 ： String默认值 ： bottomLefttrigger ： 触发下拉的行为类型 ： Array&lt;’click’|’hover’&gt;visible ： 菜单是否显示类型 ： boolean默认值 ： ‘hover’onVisibleChange ： 菜单显示状态改变时调用，参数为 visible类型 ： Function(visible)Dropdown.Buttondisabled ： 菜单是否禁用类型 ： booleanoverlay： 菜单类型 ： Menuplacement： 菜单弹出位置：bottomLeft bottomCenter bottomRight topLeft topCenter topRight类型 ： String默认值 ： bottomLeftsize： 按钮大小，和 Button 一致类型 ： String默认值 ： ‘default’trigger： 按触发下拉的行为类型 ： Array&lt;’click’|’hover’&gt;默认值 ： ‘’hover’type： 按钮类型，和 Button 一致类型 ： String默认值 ： ‘default’visible： 菜单是否显示类型 ： booleanonClick： 点击左侧按钮的回调，和 Button 一致类型 ： FunctiononVisibleChange ： 菜单显示状态改变时调用，参数为 visible类型 ： FunctionMenu使用方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546import &#123; Menu, Icon &#125; from &apos;antd&apos;;const SubMenu = Menu.SubMenu;const MenuItemGroup = Menu.ItemGroup;class App extends React.Component &#123; state = &#123; current: &apos;mail&apos;, // 当前选中项的 key 值 &#125; handleClick = (e) =&gt; &#123; console.log(&apos;click &apos;, e); this.setState(&#123; current: e.key, &#125;); &#125; render() &#123; return ( &lt;Menu onClick=&#123;this.handleClick&#125; selectedKeys=&#123;[this.state.current]&#125; // 选中项 mode=&quot;horizontal&quot; &gt; &lt;Menu.Item key=&quot;mail&quot;&gt; &lt;Icon type=&quot;mail&quot; /&gt;Navigation One &lt;/Menu.Item&gt; &lt;Menu.Item key=&quot;app&quot; disabled&gt; &lt;Icon type=&quot;appstore&quot; /&gt;Navigation Two &lt;/Menu.Item&gt; &lt;SubMenu title=&#123;&lt;span&gt;&lt;Icon type=&quot;setting&quot; /&gt;Navigation Three - Submenu&lt;/span&gt;&#125;&gt; &lt;MenuItemGroup title=&quot;Item 1&quot;&gt; // 多级餐单分类 &lt;Menu.Item key=&quot;setting:1&quot;&gt;Option 1&lt;/Menu.Item&gt; &lt;Menu.Item key=&quot;setting:2&quot;&gt;Option 2&lt;/Menu.Item&gt; &lt;/MenuItemGroup&gt; &lt;MenuItemGroup title=&quot;Item 2&quot;&gt; &lt;Menu.Item key=&quot;setting:3&quot;&gt;Option 3&lt;/Menu.Item&gt; &lt;Menu.Item key=&quot;setting:4&quot;&gt;Option 4&lt;/Menu.Item&gt; &lt;/MenuItemGroup&gt; &lt;/SubMenu&gt; &lt;Menu.Item key=&quot;alipay&quot;&gt; &lt;a href=&quot;https://ant.design&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Navigation Four - Link&lt;/a&gt; &lt;/Menu.Item&gt; &lt;/Menu&gt; ); &#125;&#125;ReactDOM.render(&lt;App /&gt;, mountNode);参考网址 ：MenuMenu 参数defaultOpenKeys ：初始展开的 SubMenu 菜单项 key 数组defaultSelectedKeys ：初始选中的菜单项 key 数组类型 ：string[]inlineCollapsed ：inline 时菜单是否收起状态类型 ：booleaninlineIndent ：inline 模式的菜单缩进宽度类型 ：number默认值 ：24mode ：菜单类型，现在支持垂直、水平、和内嵌模式三种类型 ：string （vertical horizontal inline）默认值 ：verticalmultiple ：是否允许多选类型 ：boolean默认值 ：falseopenKeys：当前展开的 SubMenu 菜单项 key 数组类型 ：string[]selectable：是否允许多选类型 ：boolean默认值 ：trueselectedKeys ：当前选中的菜单项 key 数组类型 ：string[]style ： 根节点样式类型 ：objecttheme ： 主题颜色类型 ：string （ light dark）默认值 ：lightonClick： 点击 MenuItem 调用此函数类型 ：function({ item, key, keyPath })onDeselect： 取消选中时调用，仅在 multiple 生效类型 ：function({ item, key, selectedKeys })onOpenChange： SubMenu 展开/关闭的回调类型 ：function(openKeys: string[])默认值 ：nooponSelect： 被选中时调用类型 ：function({ item, key, selectedKeys })Menu.Item 参数disabled ： 是否禁用类型 ：boolean默认值 ：falsekey ： item 的唯一标志类型 ：stringMenu.SubMenu 参数children ：子菜单的菜单项类型 ：Array&lt;MenuItem|SubMenu&gt;disabled ：是否禁用类型 ：boolean默认值 ：falsekey ：唯一标志类型 ：stringtitle ：子菜单项值类型 ：string|ReactNodeonTitleClick ：点击子菜单标题类型 ：function({ key, domEvent })Menu.ItemGroup 参数children ：分组的菜单项类型 ： MenuItem[]title ： 分组标题类型 ：string | ReactNodePagination分页Pagination 用法123import &#123; Pagination &#125; from &apos;antd&apos;;ReactDOM.render(&lt;Pagination defaultCurrent=&#123;1&#125; total=&#123;50&#125; /&gt;, mountNode);Pagination 参数current ：当前页数类型 ：numberdefaultCurrent：当前页默认的当前页数类型 ：number默认值 ： 1defaultPageSize：默认的每页条数类型 ：number默认值 ： 10itemRender：用于自定义页码的结构，可用于优化 SEO类型 ：(page, type: ‘page’ | ‘prev’ | ‘next’, originalElement) =&gt; React.ReactNodepageSize：每页条数类型 ：numberpageSizeOptions：指定每页可以显示多少条类型 ：string[]默认值 ： ‘10’, ‘20’, ‘30’, ‘40’showQuickJumper：是否可以快速跳转至某页类型 ：boolean默认值 ：falseshowSizeChanger：是否可以改变 pageSize类型 ：boolean默认值 ：falseshowTotal：用于显示数据总量和当前数据顺序类型 ：Function(total, range) / range ：Arraysimple：当添加该属性时，显示为简单分页类型 ：booleansize：当为「small」时，是小尺寸分页类型 ：string默认值 ：“”total：数据总数类型 ：number默认 ： 0onChange：页码改变的回调，参数是改变后的页码及每页条数类型 ：Function(page, pageSize)默认 ： nooponShowSizeChange：页码pageSize 变化的回调类型 ：Function(current, size)默认 ： noopSteps步骤条Steps 使用方法12345678910import &#123; Steps &#125; from &apos;antd&apos;;const Step = Steps.Step;ReactDOM.render( &lt;Steps current=&#123;1&#125;&gt; &lt;Step title=&quot;Finished&quot; description=&quot;This is a description.&quot; /&gt; &lt;Step title=&quot;In Progress&quot; description=&quot;This is a description.&quot; /&gt; &lt;Step title=&quot;Waiting&quot; description=&quot;This is a description.&quot; /&gt; &lt;/Steps&gt;, mountNode);Steps 参数current ： 指定当前步骤，从 0 开始记数。在子 Step 元素中，可以通过 status 属性覆盖状态类型 ：number默认值 ：0direction：指定步骤条方向 horizontal vertical类型 ：string默认值 ：horizontalprogressDot：点状步骤条，可以设置为一个 function类型 ：Boolean or (iconDot, {index, status, title, description}) =&gt; ReactNode默认值 ：falsesize：指定大小，目前支持普通 default 和迷你 small类型 ：string默认值 ：defaultstatus：指指定当前步骤的状态，可选 wait process finish error类型 ：string默认值 ：processSteps.Step 参数description ：步骤的详情描述，可选类型 ：string | ReactNodeicon ：步骤图标的类型，可选类型 ：string | ReactNodestatus：指定状态。当不配置该属性时，会使用 Steps 的 current 来自动指定状态。可选：wait process finish error类型 ：sstring默认值 ：waittitle：标题类型 ：string | ReactNodeAutoComplete 输入框自动完成用法123456789101112131415161718192021222324252627282930313233343536import &#123; AutoComplete &#125; from &apos;antd&apos;;function onSelect(value) &#123; console.log(&apos;onSelect&apos;, value);&#125;class Complete extends React.Component &#123; state = &#123; dataSource: [], &#125; handleSearch = (value) =&gt; &#123; this.setState(&#123; dataSource: !value ? [] : [ value, value + value, value + value + value, ], &#125;); &#125; render() &#123; const &#123; dataSource &#125; = this.state; return ( &lt;AutoComplete dataSource=&#123;dataSource&#125; style=&#123;&#123; width: 200 &#125;&#125; onSelect=&#123;onSelect&#125; onSearch=&#123;this.handleSearch&#125; placeholder=&quot;input here&quot; /&gt; ); &#125;&#125;ReactDOM.render(&lt;Complete /&gt;, mountNode);AutoComplete 参数allowClear ： 支持清除, 单选模式有效类型 ：boolean默认值：falsebackfill ： 使用键盘选择选项的时候把选中项回填到输入框中类型 ：boolean默认值：falsechildren ： 自动完成的数据源类型 ：React.ReactElement / Array&lt;React.ReactElement&gt;children ： 自定义输入框类型 ：HTMLInputElement / HTMLTextAreaElement / React.ReactElement默认值：dataSource： 自动完成的数据源类型 ：DataSourceItemType[]defaultActiveFirstOption：是否默认高亮第一个选项。类型 ：boolean默认值：truedefaultValue ： 指定默认选中的条目类型 ：string|string[] | { key: string, label: string | ReactNode } | Array&lt;{ key: string, label: string | ReactNode}&gt;disabled ： 是否禁用类型 ：boolean默认值：falsefilterOption ： 是否根据输入项进行筛选。当其为一个函数时，会接收 inputValue option 两个参数，当 option 符合筛选条件时，应返回 true，反之则返回 false类型 ：boolean or function(inputValue, option)默认值：trueoptionLabelProp ： 回填到选择框的 Option 的属性值，默认是 Option 的子元素。比如在子元素需要高亮效果时，此值可以设为 value类型 ：stringplaceholder： 输入框提示类型 ：boolean默认值：falsevalue： 指定当前选中的条目类型 ：string|string[] | { key: string, label: string|ReactNode } | Array&lt;{ key: string, label: string | ReactNode }&gt;onChange： 选中 option，或 input 的 value 变化时，调用此函数类型 ：function(value)onSearch ： 搜索补全项的时候调用类型 ：function(value)默认值：falseonSelect ： 被选中时调用，参数为选中项的 value 值类型 ：function(value, option)CascaderCascader 使用方法123456789101112131415161718192021222324252627282930313233import &#123; Cascader &#125; from &apos;antd&apos;;const options = [&#123; value: &apos;zhejiang&apos;, label: &apos;Zhejiang&apos;, children: [&#123; value: &apos;hangzhou&apos;, label: &apos;Hangzhou&apos;, children: [&#123; value: &apos;xihu&apos;, label: &apos;West Lake&apos;, &#125;], &#125;],&#125;, &#123; value: &apos;jiangsu&apos;, label: &apos;Jiangsu&apos;, children: [&#123; value: &apos;nanjing&apos;, label: &apos;Nanjing&apos;, children: [&#123; value: &apos;zhonghuamen&apos;, label: &apos;Zhong Hua Men&apos;, &#125;], &#125;],&#125;];function onChange(value) &#123; console.log(value);&#125;ReactDOM.render( &lt;Cascader options=&#123;options&#125; onChange=&#123;onChange&#125; placeholder=&quot;Please select&quot; /&gt;, mountNode);Cascader 参数allowClear ： 是否支持清除类型：boolean默认值：truechangeOnSelect：当此项为 true 时，点选每级菜单选项值都会发生变化类型：boolean默认值：trueclassName： 自定义类名类型：stringdefaultValue： 默认的选中项类型：CascaderOptionType[]默认值：[]disabled： 是否禁用类型：boolean默认值：falsedisplayRender： 选择后展示的渲染函数类型：(label, selectedOptions) =&gt; ReactNode默认值：label =&gt; label.join(‘ / ‘)expandTrigger： 次级菜单的展开方式，可选 ‘click’ 和 ‘hover’类型：string默认值：’click’getPopupContainer： 菜单渲染父节点。默认渲染到 body 上，如果你遇到菜单滚动定位问题，试试修改为滚动的区域，并相对其定位类型：Function(triggerNode)默认值：() =&gt; document.bodyloadData： 用于动态加载选项，无法与 showSearch 一起使用类型：(selectedOptions) =&gt; voidnotFoundContent ： 当下拉列表为空时显示的内容类型：string默认值：’Not Found’placeholder： 输入框占位文本类型：string默认值：’请选择’popupClassName： 自定义浮层类名类型：stringpopupPlacement： 浮层预设位置：bottomLeft bottomRight topLeft topRight类型：Enum默认值：bottomLeftshowSearch ： 在选择框中显示搜索框类型：boolean默认值：falsesize： 输入框大小，可选 large default small类型：string默认值：defaultstyle：自定义样式类型：objectvalue ： 指定选中项类型：CascaderOptionType[]onChange： 选择完成后的回调类型：(value, selectedOptions) =&gt; voidonPopupVisibleChange：显示/隐藏浮层的回调类型：(value) =&gt; voidpopupVisible： 控制浮层显隐类型：booleanshowSearch 为对象时，其中的字段filter ： 接收 inputValue path 两个参数，当 path 符合筛选条件时，应返回 true，反之则返回 false。类型 ： function(inputValue, path): booleanmatchInputWidth ： 搜索结果列表是否与输入框同宽类型 ： booleanrender ： 用于渲染 filter 后的选项类型 ：function(inputValue, path): ReactNodesort ： 用于排序 filter 后的选项类型 ： function(a, b, inputValue)Checkbox 多选框Checkbox 使用方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546import &#123; Checkbox &#125; from &apos;antd&apos;;const CheckboxGroup = Checkbox.Group;const plainOptions = [&apos;Apple&apos;, &apos;Pear&apos;, &apos;Orange&apos;];const defaultCheckedList = [&apos;Apple&apos;, &apos;Orange&apos;];class App extends React.Component &#123; state = &#123; checkedList: defaultCheckedList, indeterminate: true, checkAll: false, &#125;; render() &#123; return ( &lt;div&gt; &lt;div style=&#123;&#123; borderBottom: &apos;1px solid #E9E9E9&apos; &#125;&#125;&gt; &lt;Checkbox indeterminate=&#123;this.state.indeterminate&#125; onChange=&#123;this.onCheckAllChange&#125; checked=&#123;this.state.checkAll&#125; &gt; Check all &lt;/Checkbox&gt; &lt;/div&gt; &lt;br /&gt; &lt;CheckboxGroup options=&#123;plainOptions&#125; value=&#123;this.state.checkedList&#125; onChange=&#123;this.onChange&#125; /&gt; &lt;/div&gt; ); &#125; onChange = (checkedList) =&gt; &#123; this.setState(&#123; checkedList, indeterminate: !!checkedList.length &amp;&amp; (checkedList.length &lt; plainOptions.length), checkAll: checkedList.length === plainOptions.length, &#125;); &#125; onCheckAllChange = (e) =&gt; &#123; this.setState(&#123; checkedList: e.target.checked ? plainOptions : [], indeterminate: false, checkAll: e.target.checked, &#125;); &#125;&#125;ReactDOM.render(&lt;App /&gt;, mountNode);Checkbox 参数checked ：指定当前是否选中类型 ：boolean默认值 ： falsedefaultChecked ：初始是否选中类型 ：boolean默认值 ： falseindeterminate：设置 indeterminate 状态，只负责样式控制类型 ：boolean默认值 ： falseonChange：变化时回调函数类型 ：Function(e：Event)Checkbox Group 参数defaultValue ：默认选中的选项类型 ：string[]默认值 ： []options：指定可选项类型 ：string[]默认值 ： []value ：指定选中的选项类型 ：string[]默认值 ： []onChange ：变化时回调函数类型 ：Function(checkedValue)","categories":[{"name":"ant Design","slug":"ant-Design","permalink":"http://yoursite.com/categories/ant-Design/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"jQuery.cropper 插件","slug":"jQuery.cropper","date":"2018-07-06T16:00:00.000Z","updated":"2018-07-17T08:40:18.825Z","comments":true,"path":"2018/07/07/jQuery.cropper/","link":"","permalink":"http://yoursite.com/2018/07/07/jQuery.cropper/","excerpt":"","text":"基于 jQuery.cropper 上传可裁剪图片12345678910111213141516// HTML 部分&lt;div class=&quot;cropper-box&quot;&gt; &lt;div class=&quot;cropper-pos&quot;&gt; &lt;div class=&quot;cropper-container&quot;&gt; &lt;img src=&quot;../img/m/chenrong.jpg&quot; id=&quot;image&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;clearfix control&quot;&gt; &lt;span class=&quot;cancel-file&quot;&gt; 取消上传 &lt;/span&gt; &lt;span class=&quot;up-file&quot; data-method=&quot;getCroppedCanvas&quot;&gt; 上传头像 &lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// sass 部分// 注释：如果插件容器在初始化的时候，容器本身是隐藏的，那会导致无法获取宽度和高度，需要注意，在此我采用透明度和层级来控制的.cropper-box &#123; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.6); z-index: -1; opacity: 0; .cropper-pos &#123; position: absolute; top: 40%; left: 0; transform: translateY(-60%); width: 100%; height: rem(300); .cropper-container &#123; width: 100%; height: rem(300); margin-bottom: rem(40); img &#123; width: 100%; &#125; &#125; .control &#123; display: flex; justify-content: space-around; &#125; .cancel-file, .up-file &#123; padding: rem(6) rem(14); line-height: rem(40); text-align: center; font-size: rem(22); border-radius: rem(4); background-color: #eee; &#125; .up-file &#123; background-color: #ffd100; &#125; &#125;&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122// JS 部分// 等比缩放图片function AutoResizeImage (maxWidth, maxHeight, imgw, imgh) &#123; let hRatio let wRatio let Ratio = 1 wRatio = maxWidth / imgw hRatio = maxHeight / imgh if (maxWidth === 0 &amp;&amp; maxHeight === 0) &#123; Ratio = 1 &#125; else if (maxWidth === 0) &#123; if (hRatio &lt; 1) Ratio = hRatio &#125; else if (maxHeight === 0) &#123; if (wRatio &lt; 1) Ratio = wRatio &#125; else if (wRatio &lt; 1 || hRatio &lt; 1) &#123; Ratio = wRatio &lt;= hRatio ? wRatio : hRatio &#125; if (Ratio &lt; 1) &#123; imgw = imgw * Ratio imgh = imgh * Ratio &#125; return &#123;width: imgw, height: imgh&#125;&#125;// 图片的 dataurl 转 blobconst dataURLtoBlob = (dataurl) =&gt; &#123; let arr = dataurl.split(&apos;,&apos;) let mime = arr[0].match(/:(.*?);/)[1] let bstr = atob(arr[1]) let n = bstr.length let u8arr = new Uint8Array(n) while (n--) &#123; u8arr[n] = bstr.charCodeAt(n) &#125; return new Blob([u8arr], &#123;type: mime&#125;) &#125; // 使用的是 cropper插件 基于jQuery// Git 地址 ： https://github.com/fengyuanchen/cropper// 初始化插件$(&apos;.cropper-container &gt; img&apos;).cropper(&#123; aspectRatio: 1, viewMode: 1, dragMode: &apos;move&apos;, autoCrop: false, zoomable: false, minCropBoxWidth: 80, minCropBoxHeight: 80, ready: function () &#123; $(this).cropper(&apos;crop&apos;) &#125;, crop: function (data) &#123; $(&apos;.cropper-container&apos;).css(&#123;&apos;width&apos;: &apos;100%&apos;, &apos;height&apos;: &apos;500px&apos;&#125;) &#125; &#125;)// 上传头像$(document).on(&apos;click&apos;, &apos;.up-file&apos;, function (e) &#123; let formData = new FormData() let cropperImg = $(&apos;.cropper-container &gt; img&apos;).cropper(&apos;getCroppedCanvas&apos;) let dataUrl = cropperImg.toDataURL(&apos;image/jpeg&apos;) let blobUrl = dataURLtoBlob(dataUrl) let fileTime = new Date().getTime() + blobUrl.type.split(&apos;/&apos;)[1] let token = Cookie.get(&apos;hx_forum_token&apos;) let passportid = Cookie.get(&apos;hx_forum_passportId&apos;) // 限制上传图片大小 let imgSize = blobUrl.size / (1024 * 1024) if (imgSize &gt; 5) &#123; // 提示语 使用的是 layer 插件 layer.msg(&apos;图片裁剪区域最大不能超过5M！&apos;) return &#125; let obj = &#123; type: &apos;user&apos;, data: JSON.stringify(&#123;passportid, token&#125;) &#125; for (let key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; formData.append(key, obj[key]) &#125; &#125; formData.append(&apos;uploadFile&apos;, blobUrl, fileTime)// 上传图片的时候，所有的参数都要变成流传输，所以要借用 FormData 对象 axiosAjax(&#123; type: &apos;POST&apos;, url: ``, contentType: &apos;multipart/form-data&apos;, // *参数格式设置 params: formData, fn: function (data) &#123; if (parseInt(data.code) === 1) &#123; $(&apos;.portrait-img &gt; img&apos;).attr(&apos;src&apos;, newImg) &#125; &#125; &#125;) $(&apos;.cropper-box&apos;).css(&#123;&apos;opacity&apos;: 0, &apos;z-index&apos;: -1&#125;)&#125;)// 切换图片$(&apos;.portrait-img&apos;).on(&apos;change&apos;, &apos;.file-update&apos;, function (e) &#123; let width = $(&apos;.cropper-container&apos;).width() let height = $(&apos;.cropper-container&apos;).height() if (window.FileReader) &#123; let ReaderObj = new FileReader() ReaderObj.readAsDataURL(e.target.files[0]) ReaderObj.onload = function (res) &#123; let imageObj = new Image() imageObj.src = res.target.result imageObj.onload = function () &#123; let proInfo = AutoResizeImage(width, height, imageObj.width, imageObj.height) $(&apos;#image&apos;).cropper(&apos;replace&apos;, res.target.result, false) $(&apos;#image&apos;).css(&#123;&apos;width&apos;: proInfo.width, &apos;height&apos;: proInfo.height&#125;) $(&apos;.cropper-box&apos;).css(&#123;&apos;opacity&apos;: 1, &apos;z-index&apos;: 301&#125;) &#125; &#125; &#125;&#125;)","categories":[{"name":"cropper","slug":"cropper","permalink":"http://yoursite.com/categories/cropper/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"gulp","slug":"gulp","date":"2018-06-16T16:00:00.000Z","updated":"2018-07-17T08:41:30.386Z","comments":true,"path":"2018/06/17/gulp/","link":"","permalink":"http://yoursite.com/2018/06/17/gulp/","excerpt":"","text":"gulpglup 语法gulp.src(globs[, options]) 输出（Emits）符合所提供的匹配模式（glob）或者匹配模式的数组（array of globs）的文件。 将返回一个 Vinyl files 的 stream 它可以被 piped 到别的插件中globs : String 或 Arrayoptions ：Objectoptions.buffer ： Boolean 默认值： trueoptions.read ： Boolean 默认值： trueoptions.base ： Stringgulp.dest(path[, options]) 能被 pipe 进来，并且将会写文件。并且重新输出（emits）所有数据，因此你可以将它 pipe 到多个文件夹。如果某文件夹不存在，将会自动创建它path : String or Function 文件将被写入的路径（输出目录）options : Objectoptions.cwd : String 默认值： process.cwd() 输出目录的 cwd 参数，只在所给的输出目录是相对路径时候有效options.mode : String 默认值： 0777 八进制权限字符，用以定义所有在输出目录中所创建的目录的权限。gulp.task(name[, deps], fn) 定义一个使用 编排器 实现的任务（task）name ：String 任务的名字，如果你需要在命令行中运行你的某些任务，那么，请不要在名字中使用空格deps ： Array 一个包含任务列表的数组，这些任务会在你当前任务运行之前完成【前置依赖】fn ： func 该函数定义任务所要执行的一些操作【支持异步任务】1234567891011121314151617181920212223242526272829&gt; gulp.task(&apos;somename&apos;, function() &#123; var stream = gulp.src(&apos;client/**/*.js&apos;) .pipe(minify()) .pipe(gulp.dest(&apos;build&apos;)); return stream;&#125;)&gt; gulp.task(&apos;somename&apos;, function() &#123; var deferred = Q.defer(); // 执行异步的操作 setTimeout(function() &#123; deferred.resolve(); &#125;, 1); return deferred.promise;&#125;);&gt; // 在gulp 执行任务的时候，task会以最大的并发数执行，也就是gulp 会一次性的执行所有的task 并且不会等待，所以如果你想创建一个序列化的task队列，并想按顺序执行，你需要做两步：&gt; // 1、给出一个提示，告诉task什么时候执行完毕&gt; // 2、给出一个提示，告知task 一来另外一个task 的完成&gt; &gt; // 返回一个 callback，因此系统可以知道它什么时候完成gulp.task(&apos;one&apos;, function(cb) &#123; // 做一些事 -- 异步的或者其他的 cb(err); // 如果 err 不是 null 或 undefined，则会停止执行，且注意，这样代表执行失败了&#125;);// 定义一个所依赖的 task 必须在这个 task 执行之前完成gulp.task(&apos;two&apos;, [&apos;one&apos;], function() &#123; // &apos;one&apos; 完成后&#125;);gulp.task(&apos;default&apos;, [&apos;one&apos;, &apos;two&apos;]); // 创建一个有序执行的任务&gt;gulp.watch(glob [, opts], tasks) 或 gulp.watch(glob [, opts, cb])gulp.watch(glob[, opts], tasks)glob : String or Array 用来指定具体监控哪些文件的变动opts : Object 传给 监视者 的参数task : Array 需要在文件变动后执行的一个或者多个通过 gulp.task() 创建的 task 的名字gulp.watch(glob [, opts, cb])glob : String or Array 用来指定具体监控哪些文件的变动opts : Object 传给 监视者 的参数cb(event) : 每次变动需要执行的 callbackcallback 会被传入一个名为 event 的对象。这个对象描述了所监控到的变动event.type ： String 发生的变动的类型：added, changed 或者 deletedevent.path ： String 触发了该事件的文件的路径使用技巧 https://www.gulpjs.com.cn/docs/recipes/ （官网）gulp 在项目中用到的一些插件gulp-stylelint （代码校验）参数failAfterError ： 当设置为true时，如果出现错误级别的警告，进程将以非零错误代码结束。默认值为truereportOutputDir ：用于将lint结果写入文件系统的基本目录。当前工作目录的默认值reporters ：配置对象列表。默认为空数组formatter ：结果格式化程序save ：将格式化的结果保存到一个文件中console ：格式化结果到控制台debug ：当设置为true时，错误处理程序将打印错误堆栈跟踪。默认值为假fix : 为true选项指示stylelint尽可能多地解决问题。这些修正被应用到gulp流中。可以将固定的内容保存到文件中1234567891011121314151617181920const stylelint = require(&apos;gulp-stylelint&apos;)// stylelint检测 // 作用： 统一代码风格，检查语法错误； 减少错误语法的出现率和git管理中代码冲突的情况gulp.task(&apos;lintCss&apos;, () =&gt; &#123; return gulp .src([&apos;assets/css/*.scss&apos;, &apos;assets/css/*/*.scss&apos;]) // 单路径：String，多路径：Array .pipe(stylelint(&#123; // 调用 有点想node express 里面的use failAfterError: true, reportOutputDir: &apos;reports/lint&apos;, fix: true, reporters: [ &#123;formatter: &apos;string&apos;, console: true&#125;, &#123;formatter: &apos;json&apos;, save:&apos;text.txt&apos;, console:true&#125; ]， debug: true &#125;)) .pipe(gulp.dest(&apos;src&apos;)); // 只有在fix 设置为true 的时候加这项操作&#125;)gulp-sass 和 gulp-sourcemaps （sass编译，源映射）1234567891011var sass = require(&apos;gulp-sass&apos;); // 编译sass -&gt; cssvar sourcemaps = require(&apos;gulp-sourcemaps&apos;); // 将编译、压缩后的 css 显示成原始代码，映射到调试工具中// sass处理gulp.task(&apos;sass&apos;, [&apos;lintCss&apos;], () =&gt; &#123; // 第二个参数是依赖进程 return gulp.src(&apos;assets/css/*.scss&apos;) .pipe(sourcemaps.init()) //初始化 .pipe(sass().on(&apos;error&apos;, sass.logError)) // .pipe(sass。sync().on(&apos;error&apos;, sass.logError)) 同步编译 .pipe(sourcemaps.write(&apos;&apos;)) // 编写源映射 .pipe(gulp.dest(&apos;public/css&apos;))&#125;)gulp-clean-css （css压缩）用于压缩css文件，减少文件大小，并给引用的url添加版本号避免缓存123456789101112131415161718cleanCSS= require(&apos;gulp-clean-css&apos;)cssver = require(&apos;gulp-make-css-url-version&apos;); // 给css文件中的引用文件添加版本号（MD5），避免缓存参数：useDate : true 使用时间戳制作 assetsDir: __dirname + &apos;/public&apos; 在某些特定的情况下，指定公共目录来正确地计算MD5gulp.task(&apos;minifyCss&apos;, function () &#123; gulp.src(&apos;src/css/*.css&apos;) .pipe(cssver()) .pipe(cleanCSS(&#123; advanced: false,//类型：Boolean 默认：true [是否开启高级优化（合并选择器等）] compatibility: &apos;ie7&apos;,//保留ie7及以下兼容写法 类型：String 默认：&apos;&apos;or&apos;*&apos; [启用兼容模式； &apos;ie7&apos;：IE7兼容模式，&apos;ie8&apos;：IE8兼容模式，&apos;*&apos;：IE9+兼容模式] keepBreaks: true,//类型：Boolean 默认：false [是否保留换行] keepSpecialComments: &apos;*&apos; //保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀 &#125;)) .pipe(gulp.dest(&apos;dist/css&apos;));&#125;);gulp-imagemin （图片压缩）12345678910111213141516const imagemin = require(&apos;gulp-imagemin&apos;)const pngquant = require(&apos;imagemin-pngquant&apos;) // 深度压缩png格式图片gulp.task(&apos;minifyImg&apos;, () =&gt; &#123; return gulp.src([&apos;assets/img/*&apos;, &apos;assets/img/*/*&apos;]) .pipe(imagemin(&#123; optimizationLevel: 5, //类型：Number 默认：3 取值范围：0-7（优化等级） progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片 interlaced: true, //类型：Boolean 默认：false 隔行扫描gif进行渲染 multipass: true //类型：Boolean 默认：false 多次优化svg直到完全优化 svgoPlugins: [&#123;removeViewBox: false&#125;], //不要移除svg的viewbox属性 深度压缩时参数 use: [pngquant()] //使用pngquant深度压缩png图片的imagemin插件 深度压缩时参数 &#125;)) .pipe(gulp.dest(&apos;public/img&apos;)) .pipe(connect.reload()) // 配合gulp-connect使用， 可以捕获根目录下的子目录变化&#125;)gulp-clean （清除文件/文件夹）1234567const clean = require(&apos;gulp-clean&apos;)// 删除文件及文件夹，在执行打包的时候，一般都需要先清理目标文件夹，以保证每次打包时，都是最新的文件gulp.task(&apos;cleanPublic&apos;, () =&gt; &#123; return gulp.src([&apos;public/css&apos;, &apos;public/js&apos;, &apos;public/img&apos;], &#123;read: false&#125;) // read:false 阻止gulp读取文件的内容，并使这个任务更快。如果在同一条流中清除后需要文件及其内容，则不要将read选项设置为false .pipe(clean(&#123;force: true&#125;)) //对于安全文件和文件夹，在当前工作目录之外，只能用option force设置为true&#125;)gulp-connect （动态监控文件变化）1234567891011121314151617181920212223242526const connect = require(&apos;gulp-connect&apos;) // 可以开启多个服务gulp.task(&apos;connect1&apos;, () =&gt; &#123; connect.server(&#123; root: [&apos;public&apos;,&apos;img&apos;], // 需要监控的根目录 host: 192.168.90.188, // IP地址 port: 3000, // 端口号 livereload: true // 重新加载 &#125;)&#125;)gulp.task(&apos;connect2&apos;, () =&gt; &#123; connect.server(&#123; root: &apos;css&apos;, // 需要监控的根目录 host: 192.168.90.188, // IP地址 port: 3001, // 端口号 livereload: true // 重新加载 &#125;)&#125;)// 监听gulp.task(&apos;watch&apos;, () =&gt; &#123; gulp.watch([&apos;assets/css/*.scss&apos;, &apos;assets/css/*/*.scss&apos;], [&apos;minifyCss&apos;]) // 参数1 ： 监听文件 ， 参数2 ： 所监听的文件发生改变后执行的任务 （原理很像发布订阅） gulp.watch([&apos;assets/js/*.js&apos;, &apos;assets/js/*/*.js&apos;], [&apos;buildJs&apos;]) gulp.watch([&apos;assets/img/*&apos;, &apos;assets/img/*/*&apos;], [&apos;minifyImg&apos;])&#125;)gulp-postcss (插件平台) [类似于webpack中的plugins]1234567891011121314const postcss = require(&apos;gulp-postcss&apos;)const autoprefixer = require(&apos;autoprefixer&apos;) // 前缀补充gulp.task(&apos;postcss&apos;, [&apos;sass&apos;], () =&gt; &#123; const plugins = [ autoprefixer(&#123;browsers: [&apos;last 2 versions&apos;, &apos;ie &gt;= 8&apos;, &apos;&gt; 5% in CN&apos;]&#125;) // 参数: [主流浏览器的最近2个版本，IE8以上，中国市场占有量大于5%] ] return gulp.src(&apos;public/css/*.css&apos;) .pipe(sourcemaps.init()) .pipe(postcss(plugins)) // 参数是个Array .pipe(sourcemaps.write(&apos;&apos;)) .pipe(gulp.dest(&apos;public/css&apos;)) .pipe(connect.reload())&#125;)","categories":[{"name":"gulp","slug":"gulp","permalink":"http://yoursite.com/categories/gulp/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"RegExp","slug":"regExp","date":"2017-11-25T16:00:00.000Z","updated":"2018-03-23T10:24:08.721Z","comments":true,"path":"2017/11/26/regExp/","link":"","permalink":"http://yoursite.com/2017/11/26/regExp/","excerpt":"","text":"正则释义： 具有全等正多边形各面的以及多面体的所有角均相等的用途： 通常用于字符串的处理；指定一种规则，来验证字符串是否符合我们的要求；最多的应用在表单验证，路径解析，用户输入内容格式等；语法： js中有两种方式创建一个正则表达式1、var reg = new RegExp(‘abc’,’g’) 或者 var reg = new RegExp(/abc/g); // 构造函数 ES6之前是允许混用的，如：new RegExp(/abc/，’g’); ES6 修改了这种行为，如果 new RegExp(/abc/i，’g’) 第二个参数会覆盖第一个参数中的修饰符2、var reg = /abc/g // 字面量使用方法String.prototype.search() 查找符合正则的字符串出现的位置 ，如果查询不到返回 -11&apos;abcregexp&apos;.search(/abc/); // =&gt; 0 首次出现的位置String.prototype.replace(n,m) 替换符合正则的字符串1234567891011121314151617181920&apos;abcregexp&apos;.replace(/abc/,&apos;def&apos;); // =&gt; defregexp 如果第二个参数不传，会用undefined替代// 当replace 的第二个参数是func的时候，用法就改变了&apos;abcregabcexp&apos;.replace(/abc/,function()&#123; console.log(arguments);&#125;) // 虽然有两项符合条件，但是依然只会匹配第一个，这也是正则惰性一种表现，想取出这种惰性，需要加全局修饰符/* =&gt; Arguments(3) [&quot;abc&quot;, 0, &quot;abcregexp&quot;, callee: ƒ, Symbol(Symbol.iterator): ƒ] 0 : &quot;abc&quot; // 匹配结果 1 : 0 // 匹配的开始索引 2 : &quot;abcregabcexp&quot; // 原字符串 callee : ƒ () length : 3 // 数组长度 ... */ &apos;abcregabcexp&apos;.replace(/abc/g,function()&#123; console.log(arguments); &#125;) // 不要以为是返回一次结果，依然是一次匹配只能返回一次结果，但是 replace 方法，会主动的去循环查找，知道没有符合条件后结束匹配。String.prototype.split(reg) 替换符合正则的字符串1&apos;abcaregaexp&apos;.split(/a/); // =&gt; [&apos;&apos;,&apos;bc&apos;,&apos;reg&apos;,&apos;exp&apos;] 如果切割的字符串出现在了开始或者最后，数组中会出现一项为空字符串String.prototype.match(reg) 用来捕获字符串中符合正则的字符串到一个数组中。默认情况下只捕获第一个符合的结果到数组中(正则的惰性，下面我们会说到)，正则表达式有”全局捕获“的修饰符时(定义正则表达式的时候添加参数g)，会捕获所有结果到数组中12&apos;abcregabcexpabc&apos;.match(/abc/); // =&gt; [&apos;abc&apos;]&apos;abcregabcexpabc&apos;.match(/abc/g); // =&gt; [&apos;abc&apos;,&apos;abc&apos;,&apos;abc&apos;]RegExp.prototype.test(reg) 用来测试字符串中是否含有子字符串1/abc/.test(&apos;abcaregaexp&apos;); // =&gt; true 是否存在，存在：true 不存在: falseRegExp.prototype.exec(reg) 和match方法相似，也是从字符串中捕获满足条件的字符串到数组中，但是也有区别。1/abc/.exec(&apos;abcaregaexp&apos;); // =&gt; [[&quot;abc&quot;, index: 0, input: &quot;abcaregaexp&quot;, groups: undefined]当执行reg.exec(str) 先去验证当前字符串是否匹配，如果不匹配返回结果是null，如果匹配，从字符串最左边开始向右边查找匹配内容，并且把匹配内容返回。捕获的返回结果格式：数组格式，数组中的第一项当前本次大正则在字符串中匹配的结果index 记录的本次捕获到结果起始索引input 当前正则操作的原始字符串如果当前正则中有分组，获取的数组中，从第二项开始都是每个小分组，本次匹配到的结果（通过exec可以把分组中的内容捕获到）执行一次exec只能把符合条件的第一项捕获到，如果还有其他符合规则的，需要在此执行exec才能有可能会捕获到正则捕获的懒惰型：执行一次exec捕获到第一个符合规则的内容，第一次执行exec，捕获到的依然是第一个匹配内容，后面匹配的内容不管执行多少次exec都无法捕获（解决正则捕获的懒惰型：在正则的末尾加修饰符g [全局匹配]）正则为什么会存在懒惰型呢？正则本身有一个属性：lastIndex（下一次匹配的的起始位置）默认值是0， 默认不管指定多少遍exec方法，正则的lastIndex的值都不会改变（也就是为什么始终查找的都是第一个匹配内容）,并且程序不识别我们手动改变的值为什么加上修饰符g就能解决懒惰型呢？加了修饰符g之后，每次执行exec之后，浏览器会自动修改lastIndex的值，下一次从上一次结束的位置开始所以如果想一次匹配到所有结果，需要自己封装一个方法，目的是执行一次这个方法，可以捕获所有符合匹配的内容元字符和修饰符修饰符g（global）：全局匹配（查找所有匹配而非在找到第一个匹配后停止）i （ignoreCase）：忽略大小写匹配m（multiline）：多行匹配ES6 还推出了新的修饰符，在这里就不做介绍了，感兴趣的话自己去看吧元字符[量词元字符]+：让前面的元字符出现一到多次？：出现零到一次*：出现零到多次{n}：出现n次{n,}：出现n到多次{n,m}：出现n到m次[特殊意义的元字符]\\ ：转义字符（把一个普通字符转变成有特殊意义的字符，或者把一个有意义的字符转换为普通字符）. ：除了\\n（换行符）以外的任意字符\\d ： 匹配一个0-9之间的数字\\D ： 匹配一个任意非0-9之间的数字（大写字母和小写字母的组合正好是反向的）\\w ： 匹配一个0-9或者字母或者 _ 之间的字符\\W ： 非\\w\\s ： 匹配一个任意空白字符串\\S ： 匹配一个非空白字符串[\\b] 匹配一个退格符\\b ： 匹配一个边界符\\B ： 匹配一个单词的非边界\\t ： 匹配一个制表符\\n ： 匹配一个换行符\\r ： 匹配一个回车符\\v ： 匹配一个重直制表符x|y ：匹配x或者y中的一个[a-z] ：匹配a-z之中的任意一个字符[^a-z] ：匹配一个非a-z的字符[xyz] ： 匹配x或者y或者z中的一个[^xyz] ： 匹配除了xyz以外的任意字符() ： 正则的小分组，匹配一个分组（小分组可以理解为一个大分组中的一个小分组）^ ：以某一个元字符开始$ ：以某一个元字符结束?: ：只匹配不捕获（断言）?= ：正向预查?! ：负向预查元字符详解1234567891011121314151617\\ ：有一些符号在正则中室友特殊含义的，我们在想使用他本身意思的时候需要进行转义，例如 /./g（这个时候.所匹配的是除了\\n（换行符）以外的任意字符），而我们只是希望匹配‘.’，写法：/\\./g ；() ：正则中的分组，也可以理解为一个大正则中的一个正则（包起来的部分是一个整体，在正则中我们可以使用小括号改变一些默认的优先级）[] ：在其中的任意一个，具有消磁作用，特殊意义的符号，在[]中，恢复正常含义 - 分组引用 ：\\1,\\2,……出现和第N个分组一模一样的内容 - 分组捕获 ： 分组不仅可以匹配，而且以后捕获的时候，不仅可以把大正则匹配的结果捕获到，里面每一个小分组匹配的结果也可以单独的捕获到。// 非断言的情况 /hello\\s(world)/.exec(&apos;hello world hello today&apos;) =&gt; [&quot;hello world&quot;, &quot;world&quot;, index: 0, input: &quot;hello world hello today&quot;, groups: undefined]?: ：断言， 正则表达式 /hello\\s(?:world)/.exec(&apos;hello world hello today&apos;) // =&gt; [&quot;hello world&quot;, index: 0, input: &quot;hello world hello today&quot;, groups: undefined] 但是不给此分组分配组号，也不会出现在返回结果中，?= ：正则表达式 /hello\\s(?=world)/.exec(&apos;hello world hello today&apos;) // =&gt; [&quot;hello &quot;, index: 0, input: &quot;hello world hello today&quot;, groups: undefined] // 只会捕获 (?=world) 中world 之前符合匹配条件，同样不给此分组分配组号，也不会出现在返回结果中；?! ：正则表达式 /hello\\s(?!world)/.exec(&apos;hello world hello today&apos;) // =&gt; [&quot;hello &quot;, index: 12, input: &quot;hello world hello today&quot;, groups: undefined] // 只会捕获 (?=world) 中world 后面符合匹配条件，同样不给此分组分配组号，也不会出现在返回结果中；事实上 正则能做的事情远远超出你的想想，越研究你会越喜欢正则的","categories":[{"name":"正则","slug":"正则","permalink":"http://yoursite.com/categories/正则/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"MiddleWare","slug":"middleWare","date":"2017-11-11T16:00:00.000Z","updated":"2018-03-23T07:01:38.197Z","comments":true,"path":"2017/11/12/middleWare/","link":"","permalink":"http://yoursite.com/2017/11/12/middleWare/","excerpt":"","text":"React 中间件在Redux 中为我们提供了一个 applyMiddleware 的接口函数，来处理我们需要使用的中间件；react 有那些中间件redux-logger — 操作日志redux-thunk — 将 dispatch 的控制权交给开发者，允许在 action 中返回一个函数，接收一个 dispatch 参数，并且可以异步调用它redux-promise — 支持 dispatch 一个异步 Promise action 并且等待结果后 dispatch 一个 action中间件函数签名 ({ getState, dispatch }) =&gt; next =&gt; actionredux-logger123456789101112131415let logger = store =&gt; dispatch =&gt; action=&gt;&#123; console.log(store.getState().number); dispatch(action); console.log(store.getState().number)&#125;;let applyMiddleWare = middleware =&gt; createStore =&gt; reducer =&gt;&#123; let store = createStore(reducer); let middle = middleware(store); let dispatch = middle(store.dispatch); return &#123; //将中间返回的dispatch方法覆盖掉原有store中的dispatch ...store, dispatch &#125;&#125;;export default applyMiddleWare(logger)(createStore)(reducer);redux-thunk123456let reduxThunk = store =&gt; dispatch =&gt; action=&gt;&#123; if(typeof action === &apos;function&apos;)&#123; //如果是函数将派发的权限传递给函数 return action(dispatch,store.getState); &#125; dispatch(action);&#125;;redux-promise1234567891011121314let reduxPromise = store =&gt; dispatch =&gt; action=&gt;&#123; if(action.then)&#123; return action.then(dispatch); //只支持成功 &#125; else if(action.payload&amp;&amp;action.payload.then)&#123; // 如果payload是一个promise 会对成功和失败都进行捕获并且将成功或失败的数据放到payload中进行派发 return action.payload.then(function (data) &#123; dispatch(&#123;...action,payload:data&#125;); &#125;,function (data) &#123; dispatch(&#123;...action,payload:data&#125;); &#125;) &#125; dispatch(action);&#125;;实现 composecompose 也是 redux 提供的5个函数之一（createStore,combineReducers,applyMiddleware,bindActionCreators,compose）只不过我们最常用的就是加粗的3个函数；bindActionCreators,compose 是 redux 内部可以自主触发的函数，所以我们主动用到的机会比较少123456789101112131415161718// compose 的主要职责就是将传入的参数（func）： compose(funcA, funcB, funcC) 转换成 compose(funcA(funcB(funcC())))，你可以理解为把这些独立的函数&apos;串联&apos;到一起后执行；function combineStr(str1,str2)&#123; return str1+str2;&#125;function strLen(str)&#123; return str.length;&#125;;let compose = (...fns)=&gt;(...args)=&gt; &#123; let last = fns.pop(); return fns.reduceRight(function (prev,next) &#123; return next(prev); &#125;,last(...args))&#125;; // 将上一个函数当做参数传给下一个函数；console.log(compose(strLen, combineStr)(&apos;hello&apos;, &apos; world&apos;));实现 combineReducers原理非常的简单，将创建的多个 reducer 合并成一个 reducer，之前的 reducer 都变成新对象属性存在123456let combineReducers = (reducers) =&gt; (newState = &#123;&#125;, action) =&gt; &#123; for (let key in reducers) &#123; newState[key] = reducers[key](newState[key], action) &#125; return newState;&#125;;最终实现的结果：export default createStore(reducer,applyMiddleware(reduxThunk,reduxPromise));基本上 redux 中的方法的思想已经明白了，redux 仅仅是 react 中的一部分，想更深入的了解 react 框架思想和原理，这是一个比较漫长的路，加油吧所有走在 react 的开发者们。","categories":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/categories/前端框架/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"Express","slug":"express","date":"2017-10-27T16:00:00.000Z","updated":"2018-03-22T13:45:53.392Z","comments":true,"path":"2017/10/28/express/","link":"","permalink":"http://yoursite.com/2017/10/28/express/","excerpt":"","text":"什么是ExpressExpress 是一个简洁、灵活的 node.js Web 应用开发框架,它提供一系列强大的特性，并且提供一些供客户端调用的api接口（支持中间件、支持路由处理等）,还有一个框架和它类似，叫做koa(有时间我也会写一篇);123456/** express：express核心框架* body-parser：用来快速解析请求主体中内容的* express-session / cookie-parser：方便我们在express中操作session的*/$ npm install express body-parser express-session cookie-parser创建服务，监听端口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 基于NODE内置模块，使用原生JS代码实现WEB服务let http = require('http'), fs = require('fs'), url = require('url');http.createServer((req, res)=&gt; &#123; let &#123;url:reqURL, method, headers&#125;=req, &#123;pathname, query&#125;= url.parse(reqURL, true); if (pathname === '/login' &amp;&amp; method=='GET') &#123; &#125; if(pathname==='/register' &amp;&amp; method=='POST')&#123; &#125;&#125;).listen(8888, ()=&gt; &#123; console.log(`server is success~`);&#125;);&lt;*------------*&gt;// 基于express框架完成// express就是把我们自己用原生写的封装好了，我们以后直接调取使用即可（方便开发，有点类似于JQ）let express = require('express'), app = express();app.listen(8888, ()=&gt; &#123; console.log(`server is success~`);&#125;);app.get(`/login`, (req, res)=&gt; &#123; //=&gt;等价于原生 //req.url 请求的地址+问号传参 //req.method 请求的方式(大写) //req.headers 请求头(小写) //=&gt;EXPRESS新提供的 //req.path 相当于我们原生中通过url.parse方法解析出来的pathname //req.query 相当于解析出来的query //=&gt;等价于原生 //res.writeHead 重写响应头 //res.write 响应主体 //res.end 结束响应(响应主体) //=&gt;只能返回字符串或者Buffer格式数据 //=&gt;EXPRESS独有的 //res.sendFile('./index.html',&#123;root:__dirname&#125;); 读取指定的文件，并且把内容响应给客户端 //res.json(&#123;\"id\":1,\"name\":\"李雷\"&#125;); 我们可以直接放JSON,EXPRESS帮我们把它转换为字符串返回给客户端（并且设置好了响应头信息） //res.send() 综合体 //res.statusCode = 200; 设置状态码 //res.redirect() 重定向(对应状态码中的302/301) //res.sendStatus(404); 返回状态码并且附带一些状态码的描述信息 //...&#125;);app.post(`/register`, (req, res)=&gt; &#123;&#125;);Express中间件使用中间件的两大作用：1、想要提取部分公共代码2、想要在主体API逻辑处理前，做一些特殊处理（把传递的参数做特殊的处理）123456789101112131415161718192021222324252627let express = require('express'), app = express();app.listen(8888, ()=&gt; &#123; console.log(`server is success~`);&#125;);//=&gt;所有的客户端请求都会先执行这个中间件(然后执行NEXT后在进入下一个处理程序)app.use((req, res, next)=&gt; &#123; //next:执行下一个处理(当前这个中间件根据情况，如果需要走到下一个操作，必须执行NEXT，如果不需要，直接响应内容即可) if (req.query.name) &#123; req.userName = req.query.name;//=&gt;把获取的内容写在了userName自定义属性上 next(); &#125; else &#123; res.send(`name必须传递`); &#125;&#125;);//=&gt;只有请求的地址中包含`/user`的才会进入这个中间件app.use(`/user`, (req, res, next)=&gt; &#123; req.userName += '@'; next();&#125;);app.get(`/user`, (req, res)=&gt; &#123; res.send(`My name is $&#123;req.userName&#125;`);&#125;);app.get(`/article`, (req, res)=&gt; &#123; res.send(`Article author is $&#123;req.userName&#125;`);&#125;);###Express中的路由router当请求变得越来越多的时候，我们为了方便后期的管理和维护，我们会把相同功能体系的接口进行归类；在实现的时候，也会分类实现（分组管理）；例如：/user/signin/user/signup/product/query/product/search/log/infoGET获取POST请求设置同一个地址，因为请求方式不一样，实现不一样的功能…对于上面的操作我们可以基于Express中的路由来完成1、我们创建一个routers文件夹，在这个文件夹中存储所有功能模块的接口信息（分类存储）格式 ： routers- user.js - product.js - login.js 2、在每一个路由模块中完成相关API接口的编写（举例：user模块）12345678910111213let express = require(&apos;express&apos;), router = express.Router(); //=&gt;router和app其实差不多router.use((req, res, next)=&gt; &#123; console.log(`ok`); next();&#125;);router.post(`/signin`, (req, res)=&gt; &#123; res.send(&apos;login success&apos;);&#125;);router.post(`/signup`, (req, res)=&gt; &#123; res.send(&apos;register success&apos;);&#125;);module.exports = router; //=&gt;把创建的路由导出,方便后续调取使用3、在server中需要调取使用12345let express = require(&apos;express&apos;), app = express();...app.use(`/user`, require(&apos;./routers/user&apos;));Express 中获取客户端传递的信息客户端把信息传递给服务器：1、问号传参（GET请求）2、设置请求主体（POST请求）3、设置请求头（cookie等信息传送）…问号传参 &amp; 请求头123456app.get(`/query`, (req, res)=&gt; &#123; console.log(req.headers);//=&gt; 通过 req 的 header 可以直接的获取请求头信息(想获取其中的某一个:req.headers.host...) res.send(req.query);//=&gt;通过 req 中的 query 就可以获取问号传递的参数值(并且存储的方式是 KEY : VALUE)&#125;);请求主体1234567891011121314151617181920//=&gt;基于传统的内置模块自己实现app.use(`/reg`, (req, res, next)=&gt; &#123; //=&gt;POST请求获取请求主体内容,需要基于事件完成 let str = ``; req.on('data', chunk=&gt; &#123; //=&gt;正在接收请求主体中的内容(一般内容偏多) str += chunk; &#125;); req.on('end', ()=&gt; &#123; //=&gt;接收结束,此时STR存储的就是传递进来的信息 //=&gt;客户端传递给服务器的信息一般都是字符串格式的(JSON字符串或者普通的FORMAT-DATA字符串[xxx=xxx&amp;xxx=xxx]) let data = require('querystring').parse(str);//=&gt;这个内置模块就是把FORMAT-DATA变为对象键值对的方式存储 req.body = data;//=&gt;把解析后的数据放到REQ的自定义属性上,在其它的方法中可以获取使用 next(); &#125;);&#125;);app.post(`/reg`, (req, res)=&gt; &#123; res.send(req.body);&#125;);但是这种方式太麻烦了，我们可以使用第三方插件搞定刚才处理的事情：body-parser12345678let bodyParser = require('body-parser');app.use(bodyParser.urlencoded(&#123;extended: false&#125;));app.use(bodyParser.json());app.use(bodyParser.raw());app.use(bodyParser.text());app.post(`/reg`, (req, res)=&gt; &#123; res.send(req.body);&#125;);","categories":[{"name":"node","slug":"node","permalink":"http://yoursite.com/categories/node/"}],"tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"Node 基本语法","slug":"node","date":"2017-10-13T16:00:00.000Z","updated":"2018-03-22T11:30:48.194Z","comments":true,"path":"2017/10/14/node/","link":"","permalink":"http://yoursite.com/2017/10/14/node/","excerpt":"","text":"Node 的特点NODE只是一个工具（或者环境），我们可以把NODE安装在服务器上，NODE提供的环境可以运行JS代码，这样我们就可以在服务器端使用JavaScript编写一些处理服务器相关操作的程序，也可以理解为JS变为了后台编程语言。1、NODE是基于V8引擎来渲染JS的（V8是谷歌的引擎）渲染JS的速度会很快我们在使用JS开发后台程序的时候，不需要考虑浏览器兼容了，使用JS的最新标准即可（ECMAScript）2、单线程、无阻塞I/O操作、事件驱动（event-driven）首先要安装node，下载地址Node.js 下载最新的即可，因为node也在不断更新语法和处理方式；Node和客户端的主要区别在于全局对象浏览器全局对象: windowNODE全局对象: globalNODE天生就是基于模块化开发的NODE中模块这个概念非常强（强到我们每创建一个新的JS，都相当于创建了一个新的模块）NODE是基于commonjs规范来完成模块设计的（如何创建模块、如何调取模块、如何导出模块 这些就是规范里提及的内容）CMD模块开发思想：seajs （按需导入：用到的时候在导入进来使用）AMD模块开发思想：requirejs （提前导入所有需要的依赖）1、自定义模块：自己创建的2、第三方模块：别人写好的我来用3、内置模块：天生自带的12345678910111213//=&gt;NODE为了实现模块之间的独立，会自动包一层闭包，而且给每一个模块传递五个值(function (exports, require, module, __filename, __dirname) &#123; /* * module模块:NODE模块管理的对象 * exports叫做导出，等同于module.exports，用来把模块进行导出的 * require是导入的方法，通过这个方法可以把一些模块导入到当前模块中使用 */ //=&gt;内部代码中有一个类似于这样的操作，可以把一些想要供别人使用的属性和方法暴露出来 module.exports=exports=this=&#123; fn:()=&gt;&#123;&#125; &#125;;&#125;)();module.exports把当前模块中的某些属性和方法导出123456789101112module.exports.fn=fn;module.exports.a=12;//=&gt;上面写起来麻烦（上面属于向原有内置对象的堆内存中增加属性和方法，下面属于导出一个新的堆内存）module.exports=&#123; fn:fn, a:12&#125;;---//=&gt;直接使用exports也可以，但是这种模式只能使用原有内置内容，自己开辟新内存不行exports.fn=fn;exports=&#123;&#125;;//=&gt;这种方式不行require导入某个模块，目的是使用其它模块中的属性和方法。在导入自定义模块和第三方模块语法上是有一些区别需要注意的1234require(&apos;./xxx&apos;) ： 指定目录的情况下，都是为了要导入自己定义的模块require(&apos;xxx&apos;)：不指定目录情况下，可能是导入第三方安装的模块，也可能是导入内置模块。// 查找规则: 首先到node_modules文件夹中找第三方模块，有的话，导入的就是第三方模块，没有的话，看内置模块中有没有，内置中这个模块，导入的就是内置模块，内置中没有就会报错。Path 模块用于处理文件路径path.normalize(p) 路径解析，得到规范路径path.join 路径合并path.resolve([from …], to) 获取绝对路径path.relative(from, to) 获取相对路径path.isAbsolute(path) 判定是否为绝对路径path.dirname(p) 返回路径中文件夹的名称path.basename(p, [ext]) 返回路径中的最后一部分path.extname(p) 返回路径中文件的扩展名, 在从最后一部分中的最后一个’.’到字符串的末尾。 如果在路径的最后一部分没有’.’，或者第一个字符是’.’，就返回一个 空字符串path.parse(pathString) 解析路径 (返回一个对象：{ root : “/“, dir : “/home/user/dir”, base : “file.txt”, ext : “.txt”, name : “file” })Http 模块用于和服务器交互http.createServer(function(req,res){}); 创建服务http.get(‘path’,callback); 发送get请求。http.request(options,callback); 发送请求。12345678910111213141516171819var http=require(&apos;http&apos;);var querystring=require(&apos;querystring&apos;);//启动服务http.createServer((req,res)=&gt;&#123; console.log(&quot;request already come&quot;); var post = &quot;&quot;; req.on(&apos;data&apos;,(chunk)=&gt;&#123; post += chunk; &#125;); req.on(&apos;end&apos;,()=&gt;&#123; //querystring.parse 将字符串转换为json的格式 post = querystring.parse(post); console.log(&apos;complete complished&apos;); //返回请求者一个信息 res.write(post.name); res.end(); &#125;);&#125;).listen(3000);FS 模块主要作用就是进行I/O操作（对服务器端的文件进行增删改查等操作）123// 导入fs模块let fs = require(&apos;fs&apos;);//=&gt;接下来就可以使用它里面提供的方法了我们发现FS中提供的方法一般都是两套：同步操作和异步操作各一套例如：fs.readFile 异步读取文件中的内容fs.readFileSync 同步读取文件中的内容同步和异步的区别在于：同步读取文件，文件内容没有读取完成，后面的任务无法处理，而异步不是，数据没有读取完成，下面的任务先去执行（我们也把这个特点叫做 “无阻塞的I/O操作”）readFile &amp;&amp; readFileSync12345678//=&gt;同步读取let con = fs.readFileSync(&apos;./index.html&apos;);console.log(con); //=&gt;BUFFERcon = fs.readFileSync(&apos;./index.html&apos;, &apos;utf8&apos;);console.log(con); //=&gt;STRING 设置UTF8后,会自动把BUFFER格式的数据转换为字符串格式的数据console.log(&apos;ok&apos;);//=&gt;最后执行:同步读取,需要等内容读取完成才会执行下面的任务12345678910111213141516//=&gt;异步读取console.time(&apos;readFile&apos;);let con = fs.readFile(&apos;./index2.html&apos;, &apos;utf8&apos;, (err, result)=&gt; &#123; //=&gt;回调函数就是NODE的事件驱动机制:当文件读取成功或者失败的时候,会触发回调函数执行(并且传递两个实参值) //=&gt;err(error):当读取出错,信息保存在err中,如果没有出错,err为null //=&gt;result:当读取成功,信息保存在result中(第二个参数不设置utf8,获取的结果依然是Buffer格式的数据) console.timeEnd(&apos;readFile&apos;); if (err) &#123; //=&gt;出错了:真实项目中我们会把错误信息记录在错误日志中 console.log(err); return; &#125; console.log(result);&#125;);console.log(&apos;ok&apos;);//=&gt;OK是先输出的fs.writeFile &amp;&amp; fs.writeFileSync同步或者异步向某个文件中写入内容特点：1、如果当前文件没有，我们会自动创建文件，然后再写入内容（但是并不是万能的：如果指定的地址中不存在这个文件夹，NODE无法自动帮你创建文件夹，需要我们自己手动检测并创建）2、文件写入属于覆盖式写入（新写入的内容会覆盖原有的内容）3、写入的内容需要是字符串或者BUFFER格式的数据123456789// 同步写入let res = fs.writeFileSync(&apos;./TEMP.txt&apos;, &apos;HELLO&apos;, &apos;utf8&apos;);console.log(res); //=&gt;undefined 写入的方法没有返回值// 异步写入fs.writeFile(&apos;./TEMP.txt&apos;, &apos;珠峰培训&apos;, &apos;utf8&apos;, (error)=&gt; &#123; //=&gt;这里面只有ERROR一个参数:代表写入成功还是失败 console.log(error);&#125;);appendFile &amp;&amp; appendFileSync用法和writeFile类似,不一样的地方在于：appendFile写入属于追加式写入（原有内容不改变），而writeFile输入覆盖式写入（覆盖原有的内容）123456789fs.appendFileSync(&apos;./TEMP.txt&apos;, &apos;HELLO&apos;, &apos;utf8&apos;);fs.appendFile(&apos;./TEMP.txt&apos;, &apos;HELLO&apos;, &apos;utf8&apos;, error=&gt; &#123; if (error) &#123; console.log(error); return; &#125; console.log(&apos;success&apos;);&#125;);readdir &amp;&amp; readdirSync同步或者异步读取某一个目录下所有的文件和文件夹信息12345678910let dirList = fs.readdirSync(&apos;./&apos;);console.log(dirList);fs.readdir(&apos;./&apos;, (error, result)=&gt; &#123; if (error) &#123; console.log(error); return; &#125; console.log(result); //=&gt;获取一个数组集合,集合中包含当前目录中(./)所有的文件及文件夹信息&#125;);mkdir &amp;&amp; mkdirSync创建文件夹特点:1、可以创建文件夹，如果当前文件夹已经存在，返回的是错误的信息，不会重新的创建2、不能一次创建多级结构目录，例如：./TEMP/DAY1/CSS 这样的多级目录无法一次创建，需要先创建TEMP，然后再创建DAY1…1234567fs.mkdir(&apos;./TEMP&apos;, (error)=&gt; &#123; if (error) &#123; console.log(&apos;error&apos;); return; &#125; console.log(&apos;success&apos;);&#125;);自己实现一个方法，可以一次创建多级结构目录123456789101112131415161718192021/* * 创建文件夹 * path: &apos;./TEMP&apos; 、&apos;./TEMP/DAY1&apos; 、&apos;./TEMP/DAY1/CSS&apos; ... */let makeDir = function (path) &#123; let pathAry = path.split(&apos;/&apos;), [root,...arg]=pathAry; root = root + &apos;/&apos;; let make = n=&gt; &#123; if (n &gt;= arg.length) return; let curPath = arg[n]; fs.mkdir(root + curPath, error=&gt; &#123; root += curPath + &apos;/&apos;; make(n + 1); &#125;); &#125;; make(0);&#125;;makeDir(&apos;./TEMP/DAY1/CSS/LESS&apos;);除了上述方法以外，还有很多其它的方法，例如：copyFile、rmdir… ，大家可以观看NODE中文文档（http://nodejs.cn/api/）","categories":[{"name":"node","slug":"node","permalink":"http://yoursite.com/categories/node/"}],"tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"react 高阶组件","slug":"reduxApp","date":"2017-09-16T16:00:00.000Z","updated":"2018-03-22T11:04:35.947Z","comments":true,"path":"2017/09/17/reduxApp/","link":"","permalink":"http://yoursite.com/2017/09/17/reduxApp/","excerpt":"","text":"为什么要使用高阶组件我们先看一个demo1234567891011121314151617export default class Username extends React.Component &#123; constructor()&#123; super(); this.state = &#123;val:&apos;&apos;&#125; &#125; componentDidMount()&#123; let username = localStorage.getItem(&apos;username&apos;)||&apos;&apos;; this.setState(&#123; val:username &#125;) &#125; render()&#123; return &lt;div&gt; &lt;input type=&quot;text&quot; value=&#123;this.state.val&#125; onChange=&#123;()=&gt;&#123;&#125;&#125;/&gt; &lt;/div&gt; &#125;&#125;在本地缓存中获取用户的姓名，并且将数据作为输入框的默认值，很简单的一个逻辑，不过中情况可能我们还会在密码输入框中用到； 也就是说这一段获取本地缓存数据的操作可能是一段公共逻辑，当然我们可以在每一个组件中写这样的一段逻辑，但是这就失去了组件复用性，这个时候我们就可以使用高阶组件来完成这样的操作（有没有瞬间想到node里面的中间件用法）；123456789101112131415161718192021222324252627282930313233343536// 我们来实现一下这个功能// local.jsimport React from &apos;react&apos;;let local = (key) =&gt; (Component) =&gt; &#123; return class extends React.Component &#123; constructor()&#123; super(); this.state = &#123; val : &apos;&apos;&#125;; &#125; componentDidMount()&#123; let temp = localStorage.getItem(key) || &apos;&apos;; this.getState(&#123; val : temp &#125;) &#125; render()&#123; return &lt;Component &#123;...this.state&#125; /&gt; &#125; &#125;&#125;export default local;// index.jsimport Local from &apos;./local&apos;;class Username extends React.Component &#123; render()&#123; return &lt;div&gt; &lt;input type=&quot;text&quot; value=&#123;this.props.val&#125; onChange=&#123;()=&gt;&#123;&#125;&#125;/&gt; &lt;/div&gt; &#125;&#125;export default Local(&apos;username&apos;)(Username);将公共的逻辑拿到外层组件中处理，将处理完成的数据在传入到原本组件中，所以高阶组件也就是一个React组件接收一个组件，然后返回另外一个组件context的用法react 是单向数据流， 我们想传递数据需要一层层向下传递，数据传递变得非常的麻烦，我们可以用context实现数据的交互父级组件 childContextTypes getChildContext函数子级组件 contextTypes跨组建数据交互1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 组件顺序 App -&gt; Header -&gt; Title// App.jsimport React from &apos;react&apos;;import PropTypes from &apos;prop-types&apos;import Header from &quot;./Header&quot;;export default class App extends React.Component &#123; constructor()&#123; super(); this.state = &#123;color:&apos;red&apos;&#125; &#125; static childContextTypes = &#123; //定义子组件上下文的类型 color:PropTypes.string, setColor:PropTypes.func &#125;; setColor = (color) =&gt;&#123; this.setState(&#123; color &#125;) &#125;; getChildContext()&#123; // 定义子组件上下文的数据 return &#123; color:this.state.color, setColor:this.setColor &#125; &#125; render()&#123; return ( &lt;div&gt; &lt;Header/&gt; &lt;/div&gt; ) &#125;&#125;// Header.jsexport default class Header extends React.Component &#123; static contextTypes = &#123; setColor:PropTypes.func &#125;; render()&#123; return &lt;div&gt; &lt;button onClick=&#123;()=&gt;&#123; this.context.setColor(&apos;green&apos;); &#125;&#125;&gt;变绿&lt;/button&gt; &lt;Title/&gt; &lt;/div&gt; &#125;&#125;// Title.jsexport default class Title extends React.Component &#123; static contextTypes = &#123; color:PropTypes.string &#125;; render()&#123; // 通过context获取父组件定义的数据 return &lt;div style=&#123;&#123;color:this.context.color&#125;&#125;&gt;Title&lt;/div&gt; &#125;&#125;实现 react-redux 库1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import React from &apos;react&apos;;import PropTypes from &apos;prop-types&apos;;class Provider extends React.Component&#123; static childContextTypes = &#123; store:PropTypes.object &#125;; getChildContext()&#123; return &#123; store:this.props.store &#125; &#125; constructor()&#123; super(); &#125; render()&#123; return this.props.children; &#125;&#125;let connect = (mapStateToProps,mapDispatchToProps) =&gt; (Component) =&gt;&#123; //如果第二个参数传递一个actions(一个对象)；做如下处理（与bindActionCreators处理方式相同） if(&#123;&#125;.toString.call(mapDispatchToProps).slice(8,-1)===&apos;Object&apos;)&#123; let actions=mapDispatchToProps; mapDispatchToProps=(dispatch)=&gt;&#123; let obj=&#123;&#125;; for (let key in actions) &#123; if (actions.hasOwnProperty(key)) &#123; obj[key]=(...args)=&gt;&#123; dispatch(actions[key](...args)); &#125; &#125; &#125; return obj; &#125; &#125; return class Proxy extends React.Component&#123; static contextTypes = &#123; store:PropTypes.object &#125;; constructor(props,context)&#123; super(); this.state = mapStateToProps(context.store.getState()); &#125; componentDidMount()&#123; this.unsubscribe = this.context.store.subscribe(()=&gt;&#123; this.setState(mapStateToProps(this.context.store.getState())) &#125;); &#125; componentWillUnmount()&#123; this.unsubscribe(); &#125; render()&#123; return &lt;Component &#123;...this.state&#125; &#123;...mapDispatchToProps(this.context.store.dispatch)&#125;/&gt; &#125; &#125;&#125;;export &#123;Provider,connect&#125;bindActionCreators 方法1234567891011let bindActionCreators = (actionCreators,dispatch) =&gt; &#123; let obj = &#123;&#125; for(let key in actionCreators)&#123; obj[key] = (...args)=&gt;&#123; dispatch(actionCreators[key](...args)) &#125; &#125; return obj&#125;;export default connect(state=&gt;(&#123;...state&#125;),dispatch=&gt;bindActionCreators(actionCreators,dispatch))(Counter)顺手献上源码1234567891011121314151617181920212223242526function bindActionCreator(actionCreator, dispatch) &#123; return function () &#123; return dispatch(actionCreator.apply(undefined, arguments)); &#125;;&#125;export default function bindActionCreators(actionCreators, dispatch) &#123; if (typeof actionCreators === &apos;function&apos;) &#123; return bindActionCreator(actionCreators, dispatch); &#125; if (typeof actionCreators !== &apos;object&apos; || actionCreators === null) &#123; throw new Error(&apos;&apos;); &#125; var keys = Object.keys(actionCreators); var boundActionCreators = &#123;&#125;; for (var i = 0; i &lt; keys.length; i++) &#123; var key = keys[i]; var actionCreator = actionCreators[key]; if (typeof actionCreator === &apos;function&apos;) &#123; boundActionCreators[key] = bindActionCreator(actionCreator, dispatch); &#125; &#125; return boundActionCreators;&#125;","categories":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/categories/前端框架/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"redux","slug":"redux","date":"2017-09-08T16:00:00.000Z","updated":"2018-03-22T11:04:35.940Z","comments":true,"path":"2017/09/09/redux/","link":"","permalink":"http://yoursite.com/2017/09/09/redux/","excerpt":"","text":"什么是Redux我们一直通过属性来进行组件中的数据传递,这种模式是非常脆弱的。在日常的开发中经常会遇到非父子组件传递的场景。原来的方式是找到共同的父级进行数据交互，这时通信就变得比较麻烦 我们先通过一个简单的例子实现一下redux的工作模式:一、统一数据管理1234567891011121314151617181920212223let state = &#123; title:&#123;color:&apos;red&apos;,text:&apos;标题&apos;&#125;, content:&#123;color:&apos;green&apos;,text:&apos;内容&apos;&#125;&#125;;function renderContent() &#123; let content = document.querySelector(&apos;.content&apos;); content.innerHTML = state.content.text; content.style.color = state.content.color;&#125;function renderTitle() &#123; let title = document.querySelector(&apos;.title&apos;); title.innerHTML = state.title.text; title.style.color = state.title.color;&#125;function renderApp() &#123; renderContent(); renderTitle()&#125;renderApp();这里我们可以将renderContent,renderTitle看成两个组件将所需的数据提取到state中统一进行管理。当渲染后我们希望更改状态，封装更改状态的方法(dispatch)二、实现dispatch1234567891011let CHANGE_TITLE_TEXT = &apos;CHANGE_TITLE_TEXT&apos;;function dispatch(action) &#123; switch (action.type)&#123; case CHANGE_TITLE_TEXT: state = &#123;...state,title:&#123;...state.title,text:action.text&#125;&#125;; &#125;&#125;setTimeout(()=&gt;&#123; dispatch(&#123;type:CHANGE_TITLE_TEXT,text:&apos;hello&apos;&#125;); renderApp();&#125;,1000);不要直接更改状态而是使用dispatch方法进行状态的更改,派发一个带有type的属性来进行状态的更改，仅仅是这样依然无法阻止用户更改状态。三、createStore的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546let CHANGE_TITLE_TEXT = &apos;CHANGE_TITLE_TEXT&apos;;function createStore() &#123; let state = &#123; title:&#123;color:&apos;red&apos;,text:&apos;标题&apos;&#125;, content:&#123;color:&apos;green&apos;,text:&apos;内容&apos;&#125; &#125;; let getState = () =&gt; JSON.parse(JSON.stringify(state)); // 创造一份和状态同样的对象给外界来用 function dispatch(action) &#123; switch (action.type)&#123; case CHANGE_TITLE_TEXT: state = &#123;...state,title:&#123;...state.title,text:action.text&#125;&#125;; &#125; &#125; return &#123; dispatch, getState &#125;&#125;let store = createStore(); // 拿到createStore中返回的对象function renderContent() &#123; let content = document.querySelector(&apos;.content&apos;); content.innerHTML = store.getState().content.text; content.style.color = store.getState().content.color;&#125;function renderTitle() &#123; let title = document.querySelector(&apos;.title&apos;); title.innerHTML = store.getState().title.text; title.style.color = store.getState().title.color;&#125;function renderApp() &#123; renderContent(); renderTitle()&#125;renderApp();setTimeout(()=&gt;&#123; store.dispatch(&#123;type:CHANGE_TITLE_TEXT,text:&apos;hello&apos;&#125;); renderApp();&#125;,1000);我们将状态放到了createStore函数中，目的是隔离作用域，并且再内部返回深度克隆的对象，这样用户无法再通过外界更改状态。但是状态应该由我们自身来控制，应该是外界传入的，所以要将状态拿出createStore。并且判断的逻辑也应该由我们自己来编写四、reducer的实现12345678910111213141516171819202122232425262728const CHANGE_TITLE_TEXT = &apos;CHANGE_TITLE_TEXT&apos;;function createStore(reducer) &#123; let state; let getState = () =&gt; JSON.parse(JSON.stringify(state)); function dispatch(action) &#123; state = reducer(state,action);//获取对应的状态覆盖掉store中的状态 &#125; dispatch(&#123;&#125;); // 默认传入空对象获取reducer返回的默认结果 return &#123; dispatch, getState, &#125;&#125;let initState = &#123; title:&#123;color:&apos;red&apos;,text:&apos;标题&apos;&#125;, content:&#123;color:&apos;green&apos;,text:&apos;内容&apos;&#125;&#125;;// reducer应该具有默认状态,当更改状态后使用最新的状态function reducer(state=initState,action) &#123; switch (action.type)&#123; case CHANGE_TITLE_TEXT: return &#123;...state,title:&#123;...state.title,text:action.text&#125;&#125;; &#125; return state&#125;五、订阅函数12345678910111213141516171819202122232425function createStore(reducer) &#123; let state; let listeners = []; // 放置所有订阅的函数 let getState = () =&gt; JSON.parse(JSON.stringify(state)); function dispatch(action) &#123; state = reducer(state,action); listeners.forEach(item=&gt;item());//每次派发后执行订阅的函数 &#125; let subscribe = (fn)=&gt;&#123; //主要用于订阅事件 listeners.push(fn); return ()=&gt;&#123; //返回一个移除监听的方法 listeners = listeners.filter(l=&gt;l!==fn); &#125; &#125;; dispatch(&#123;&#125;); return &#123; dispatch, getState, subscribe &#125;&#125;store.subscribe(renderApp); //通过suscribe订阅派发时需要触发的函数setTimeout(()=&gt;&#123; store.dispatch(&#123;type:CHANGE_TITLE_TEXT,text:&apos;hello&apos;&#125;);&#125;,1000);此时我们redux中常用的方法已经封装完成！^_^,我们将封装好的逻辑抽离成redux.js12345678910111213141516171819202122232425function createStore(reducer) &#123; let state; let listeners = []; // 放置所有订阅的函数 let getState = () =&gt; JSON.parse(JSON.stringify(state)); function dispatch(action) &#123; state = reducer(state,action); listeners.forEach(item=&gt;item());//每次派发后执行订阅的函数 &#125; let subscribe = (fn)=&gt;&#123; //主要用于订阅事件 listeners.push(fn); return ()=&gt;&#123; //返回一个移除监听的方法 // 源码中给出的方法 let index = listeners.indexOf(fn); listeners.splice(index, 1); // listeners = listeners.filter(item =&gt; item!==fn); 过滤一下也是可以实现的 &#125; &#125;; dispatch(&#123;&#125;); return &#123; dispatch, getState, subscribe &#125;&#125;这样我们就简单的实现了一个属于自己的redux.js","categories":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/categories/前端框架/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"react-router-dom","slug":"reactRouterDom","date":"2017-08-11T16:00:00.000Z","updated":"2018-03-21T10:06:48.638Z","comments":true,"path":"2017/08/12/reactRouterDom/","link":"","permalink":"http://yoursite.com/2017/08/12/reactRouterDom/","excerpt":"","text":"** 本文中使用的参数举例为官方文档案例** 本篇文章只将组件和方法的参数展示，针对使用方法和常用的参数进行阐述，如果想了解的更多，可以去查看React-Router 4.x官方文档在react中想使用路由功能，基本是可选的插件只有react-router，我们想使用路由功能首先要安装1$ npm install react-router-dom --save-dev;安装成功之后我们就可以在我们的项目中使用了1234import React from &apos;react&apos;;import ReactDom from &apos;react-dom&apos;;import &#123;BrowserRouter,HashRouter,Link,NavLink,Redirect,Route,Switch&#125; from &apos;react-router-dom&apos;;// react-router-dom中提供的组件供我们使用react-router 提供的组件BrowserRouter12345678&lt;BrowserRouter basename=&#123;optionalString&#125; forceRefresh=&#123;optionalBool&#125; getUserConfirmation=&#123;optionalFunc&#125; keyLength=&#123;optionalNumber&#125;&gt; &lt;App/&gt;&lt;/BrowserRouter&gt;[注意]：需要一个根节点包裹12345678import Address from &apos;../component/Address&apos;;&lt;BrowserRouter basename=&apos;/base&apos;&gt; &lt;div&gt; &lt;Route path=&apos;/address&apos; component=&#123;Address&#125;/&gt; &lt;/div&gt;&lt;/BrowserRouter&gt;&lt;Link to=&apos;/address&apos;&gt; // render ： &lt;a href=&apos;/base/address&apos;&gt;HashRouter[注意]：需要一个根节点包裹123456789import Address from &apos;../component/Address&apos;;&lt;HashRouter basename=&apos;/base&apos;&gt; &lt;App&gt; &lt;Route path=&apos;/address&apos; exact component=&#123;Address&#125;/&gt; &lt;App/&gt;&lt;/HashRouter&gt;&lt;Link to=&quot;/address&quot;/&gt; // renders &lt;a href=&quot;#/base/address&quot;&gt;Link1&lt;Link to=&quot;/about&quot;&gt;About&lt;/Link&gt; // renders &lt;a href=&quot;#/about&quot;&gt;exact : bool如果为true，路径为精准匹配to : string连接到指定的路径to : object要连接的位置1234567&lt;Link to=&#123;&#123; pathname: &apos;/address&apos;, // 跳转路径 search: &apos;?sort=name&apos;, hash: &apos;#the-hash&apos;, state: &#123; fromDashboard: true &#125;&#125;&#125;/&gt;// 对面里面可以添加跳转携带的参数replace : bool如果为true，单击链接将替换历史堆栈中的当前条目，而不是添加新条目。NavLink一种特殊版本的，用法和Link一致，不过在与当前URL匹配时，将向渲染元素添加样式属性。12345678910111213&lt;NavLink to=&quot;/faq&quot; // 跳转路径 activeClassName=&quot;selected&quot; // 当于路径匹配成功时，追加的类名&gt;FAQs&lt;/NavLink&gt;// 如果我们不适用样式表，也可以写成行内样式，如下&lt;NavLink to=&quot;/faq&quot; activeStyle=&#123;&#123; // 对象数据类型 写法如js中设置属性时的写法 fontWeight: &apos;bold&apos;, color: &apos;red&apos; &#125;&#125;&gt;FAQs&lt;/NavLink&gt;Redirect (配合Switch使用)路径重定向，当匹配不到符合路径是，会跳转到Redirect设置的路径to : string重定向路径to : object要重定向位置12345&lt;Redirect to=&#123;&#123; pathname: &apos;/login&apos;, search: &apos;?utm=your+face&apos;, state: &#123; referrer: currentLocation &#125;&#125;&#125;/&gt;push: bool当为true时，重定向会将新条目推入历史记录，而不是替换当前条目。from: string要重定向的路径名。这只能用于在内部呈现时匹配位置。1234&lt;Switch&gt; &lt;Redirect from=&apos;/old-path&apos; to=&apos;/new-path&apos;/&gt; &lt;Route path=&apos;/new-path&apos; component=&#123;Address&#125;/&gt;&lt;/Switch&gt;Route路由组件可能是React Router中了解和学习使用的最重要的组件。其最基本的责任是在位置与路线的路径匹配时呈现一些UI。123456&lt;BrowserRouter&gt; &lt;div&gt; &lt;Route exact path=&quot;/&quot; component=&#123;Header&#125;/&gt; &lt;Route path=&quot;/news&quot; component=&#123;Footer&#125;/&gt; &lt;/div&gt;&lt;/BrowserRouter&gt;component当您使用组件（而不是下面的渲染或子项）时，路由器使用React.createElement从给定组件创建一个新的React元素。这意味着如果您向组件属性提供内联函数，则可以在每个渲染中创建一个新组件.这将导致现有组件卸载和新组件安装，而不是仅更新现有组件render ： function这允许方便的在线呈现和包装，而不需要上述的不期望的重新安装。您可以使用组件支持为您创建一个新的React元素，而不必在位置匹配时传入要调用的函数。渲染道具接收与组件渲染道具相同的所有route props。警告：&lt;Route component&gt;取决于&lt;Route render&gt;，所以不要在同一个&lt;Route&gt;中使用两者12345678910111213// 内联呈现&lt;Route path=&quot;/home&quot; render=&#123;() =&gt; &lt;div&gt;Home&lt;/div&gt;&#125;/&gt;// 包装/合成const FadingRoute = (&#123; component: Component, ...rest &#125;) =&gt; (&lt;Route &#123;...rest&#125; render=&#123;props =&gt; ( &lt;FadeIn&gt; &lt;Component &#123;...props&#125;/&gt; &lt;/FadeIn&gt;)&#125;/&gt;)&lt;FadingRoute path=&quot;/cool&quot; component=&#123;Something&#125;/&gt;children ： function有时您需要渲染路径是否匹配该位置。在这些情况下，可以使用函数child prop。它的工作原理就像渲染，除了它被调用是否有匹配children 渲染prop接收与组件和渲染方法相同的所有route props，除非路由未能匹配URL，则match为null。这允许您根据路线是否匹配来动态调整用户界面。在这里，如果路由匹配，我们添加一个活动类警告：&lt;Route component&gt;和&lt;Route render&gt;优先级高于&lt;Route children&gt;，所以不要在同一个&lt;Route&gt;中使用多个Switch解决路匹配机制问题的组件当我们定义了很多路由的时候123&lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;&lt;Route path=&quot;/:user&quot; component=&#123;User&#125;/&gt;&lt;Route component=&#123;NoMatch&#125;/&gt;路由的匹配机制并不是我们所想象的，匹配到符合的路径后就会停止，而是会继续向后面匹配，如果匹配到多个符合的路径时，会将这些路径对应的组件都渲染，这就让我们难接受了123456&lt;Switch&gt; &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125;/&gt; &lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt; &lt;Route path=&quot;/:user&quot; component=&#123;User&#125;/&gt; &lt;Route component=&#123;NoMatch&#125;/&gt;&lt;/Switch&gt;所有我们要是用Switch 这个路由组件，来帮助我们解决这个问题，将所有的路由包裹在Switch组件中，路由会根据路径从上至下的匹配，如果匹配到符合的路径，就会立即停止匹配，然后渲染对应组件react-router 提供的属性和方法所有通过路由渲染的组件都会携带 Route props1、history2、location3、matchhistoryhistory对象通常具有以下属性和方法：length : （number）历史堆栈中的条目数action : （string）当前动作（PUSH，REPLACE或POP）location : (object) 当前位置。具有以下属性：pathname: URL的路径search: URL查询字符串hash: URL哈希片段state: 位置特定的状态被提供给例如。当这个位置被推到堆栈上时，push（路径，状态）。仅在浏览器和内存历史记录中可用。push : (path, [state]) - (function) 将新条目推入历史堆栈replace : (path, [state]) - (function) 替换历史堆栈上的当前条目go(n) : (function) 将历史堆栈中的指针移动n个条目goBack() : (function) 相当于 go(-1)goForward() : (function) 相当于 go(1)block : (function) 防止导航 (https://github.com/ReactTraining/history#blocking-transitions)locationlocation对象的常用属性：key: （在HashHistory中没有这个属性）pathname: URL的路径search: URL查询字符串hash: URL哈希片段state: 位置特定的状态被提供给例如。当这个位置被推到堆栈上时，push（路径，状态）。仅在浏览器和内存历史记录中可用。matchmatch对象的常用属性：params - （object）从对应于路径的动态段的URL解析的键/值对isExact - （boolean）true如果整个URL匹配（没有尾随字符path - （string）用于匹配的路径模式。作用于构建嵌套的url - （string）URL的匹配部分。作用于构建嵌套的swithRouter也是比较常用的一个路由方法，withRouter其实是一个react的高阶组件（什么是高阶组件？高阶组件是一个函数，能够接受一个组件并返回一个新的组件）在项目中我们有一些组件并不是通过路由跳转，但是我们还想使用路由中的方法，我们就需要通过withRouter来将我们的组件包装一下123456789101112131415161718192021class ShowTheLocation extends React.Component &#123; static propTypes = &#123; match: PropTypes.object.isRequired, location: PropTypes.object.isRequired, history: PropTypes.object.isRequired &#125; render() &#123; const &#123; match, location, history &#125; = this.props return ( &lt;div&gt;You are now at &#123;location.pathname&#125;&lt;/div&gt; ) &#125;&#125;export default withRouter(ShowTheLocation)// 如果这个组件中使用了reduxexport default withRouter(connect(state,action)(ShowTheLocation));如果有任何疑问或者文章内有错误，可以发邮件到1043951234@qq.com 进行交流，如果有错误我会第一时间更正，感谢您的赐教","categories":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/categories/前端框架/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"javascript scope","slug":"scope","date":"2017-07-29T16:00:00.000Z","updated":"2018-03-20T12:11:13.743Z","comments":true,"path":"2017/07/30/scope/","link":"","permalink":"http://yoursite.com/2017/07/30/scope/","excerpt":"","text":"对作用域和作用域链概念的模糊是我们在开发中导致一些‘意外’状况发生的常见原因我们随便写一个例子来看一下123456789101112131415161718192021222324252627var name = &apos;bird&apos;;function fn()&#123; console.log(name); // 1、undefined var name = &apos;dog&apos; function temp()&#123; var name = &apos;cat&apos; console.log(name); // 2、cat &#125; function item()&#123; console.log(name); // 3、dog &#125; temp(); item(); console.log(name); // 4、dog return function()&#123; console.log(name); // 5、dog &#125;&#125;var fn1 = fn();fn1();如果的这些结果你还会产生疑问的话，那说明你对作用域和作用域链的概念很模糊我们先说一下在js中的作用域的概念：作用域指的是变量的适用范围； 基本分为全局作用域（window）和局部作用域（函数）作用域的特点: 1、js中是不存在动态作用域的; 2、es6之前是不存在块级作用域的;我们来了分析一下刚才的代码位置1 这个位置输出 undefined 是因为js中变量提升机制所导致的 当进入一个作用域范围的时候js会预先查询在当前作用域中的var和function关键字所创建的变量，然后将这些变量的声明提升到当前作用域的顶部，但是var只能提升声明，不能赋值；而function 是提升声明并且赋值；位置2 在当前作用域（temp函数）中可以查询到name属性；位置3 在当前作用域（item函数）中无法查询到name属性，js机制会继续向外层查询，如果查询到了即输出；如果依旧没有找到，则继续向上级查询，直到查找到全局作用域，如果仍然查找不到，就会报错。位置4 跟2同理位置5 这也是证明了js中没有动态作用域；因为我们已经将fn函数的返回的函数赋值到了fn1，如果存在动态作用域的话，那输出的结果应该是‘bird’，然而他依旧是输出的‘dog’，也就是说，作用域链的查找规则是根据函数声明的位置，为不是看函数的调用位置如果有任何疑问或者文章内有错误，可以发邮件到1043951234@qq.com 进行交流，如果有错误我会第一时间更正，感谢您的赐教","categories":[{"name":"原生js","slug":"原生js","permalink":"http://yoursite.com/categories/原生js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"javascript Prototype","slug":"prototype","date":"2017-07-14T16:00:00.000Z","updated":"2018-03-22T04:14:00.171Z","comments":true,"path":"2017/07/15/prototype/","link":"","permalink":"http://yoursite.com/2017/07/15/prototype/","excerpt":"","text":"W3C对prototype的描述是：prototype 属性使您有能力向对象添加属性和方法。语法：object.prototype.name=value让很多刚刚开始了解OOP思想的人很是迷茫。prototype 的出现主要是为了实现“继承”的设计理念12345678910111213141516function Fn(name)&#123; this.name = name this.type = &apos;string&apos;;&#125;var foo1 = new Fn(&apos;one&apos;);var foo2 = new Fn(&apos;two&apos;);console.log(foo1.type) // =&gt; stringconsole.log(foo2.type) // =&gt; stringfoo1.type = &apos;number&apos;;console.log(foo2.type) // =&gt; string// 同一个构造函数所生成的所有实例之间相互是没有影响的（this是构造函数所生成的实例）这是我们通过 new 命令去创造一个实例的方法，但是 new 命令有一个很大的弊端，就是构造函数生成实例的时候会是属性和方法无法共享；这不仅是数据无法共享，也是资源的一种浪费；考虑到这个问题，也就在构造函数中出现了‘prototype’这个属性1234567891011121314151617181920// 我们改写一下上面的方法function Fn(name)&#123; this.name = name this.fn = function()&#123;&#125;;&#125;Fn.prototype = &#123; type: &apos;string&apos;&#125;var foo1 = new Fn(&apos;one&apos;);var foo2 = new Fn(&apos;two&apos;);console.log(foo1.name) // =&gt; oneconsole.log(foo2.name) // =&gt; twoFn.prototype.type = &apos;number&apos;;console.log(foo2.type) // =&gt; number我们发现 type 这个属性变成了两个实例的共有属性，而构造函数修改‘prototype’属性时会影响这实例的属性；理解起来很像是构造函数内部this上的属性是实例的私有属性，而构造函数的‘prototype’上的属性是实例的共有属性；对 prototype 有了一些了解 我们在说一下 __proto__ 这个属性， 它可以称谓隐式原型；我们先对这两个属性抽象理解一下:1) 每一个函数都天生自带一个prototype（对象数据类型）属性 指向自身的原型2) 每一个对象都天生自带一个__proto__属性 指向所属构造函数（类）的原型3) 每一个原型都再带一个 constructor 属性 指向构造函数（类）（但是constructor这个属性是可以手动修改的）js中的原型链也是由这俩个属性来实现的；我们先了解一下函数的三种身份：1) 普通函数2) 构造函数3) 函数对象普通函数 ： 是我们做常用的，不管是封装也谢方法还是回调函数，都属于普通函数范围构造函数 ： new 命名后面跟的函数 归属于构造函数，并且我们为了更方便的区分普通函数还是构造函数，在声明函数的时候，构造函数通常会采用首字母大写的方式函数对象 ： 函数自身也是一个对象，可以有自己的属性这也不难理解为什么js中的函数可塑性如此的高;既然说了prototype和__proto__是为了共享属性和方法（继承）而诞生的属性，我们来看一看他们在实际中是怎么使用的123456789101112131415161718192021function Parent (name,age)&#123; this.name = name; this.age = age;&#125;Parent.prototype = &#123; getName : function()&#123; return this.name; &#125;&#125;function Child (name,age,sex)&#123; Parent.call(this,name,age) this.sex = sex;&#125;Child.prototype = new Parent();var child = new Child(&apos;李雷&apos;,18,&apos;男&apos;)console.log(child.getName()); // 李雷我们写了一个简单的继承方式，在这个例子中我们不难发现，在Child这个构造函数所产生的实例中，我们可以使用Parent上的方法，这就是继承的作用，当在一个已有的构造函数中已经写过我们需要的方法，我们在合适的需求下，我们完全可以将其拿来直接使用，而不是自己在写一段重复、冗余的代码，这样也就实现了资源的共享；__proto__ 这个属性在实际开发中我们很少直接使用，是因为这个属性牵扯的东西太多，而且IE（所有开发者的痛苦）浏览器是屏蔽开发者对这个属性的操作的；并且这个属性也是一直不被推荐使用的；__proto__ 默认是串联所有实例和类的原型1234var ary = new Array(3);console.dir(ary);// 在输出台里你可以看见 \\__proto__ 的指向顺序， ary -&gt; Array -&gt; Object（自身\\__proto__为null，因为它已经是根源了）；这就是为什么我们声明一个数组后，就可以调用Array和Object上的方法；这也是js中为什么说万物皆对象的原因；在ES6中给出了两个操作方法:1) Object.getPrototypeOf() 方法返回指定对象的原型2) Object.setPrototypeOf() 方法设置一个指定的对象的原型尽管如此，设置对象的__proto__是一个缓慢的操作，如果性能是一个问题，应该避免;如果看过有关原型继承的书籍的话，我们会发现有很多继承的方式，在这就不一一举例了，我们直说一下寄生组合式继承，应该是目前最为理想解决继承的方法，解决了以前原型继承，组合式继承等等方法的一些小bug和缺陷123456789101112131415161718192021222324252627// 借助一下上面的例子，改造一下function Parent (name,age)&#123; this.name = name; this.age = age;&#125;Parent.prototype.getName = function()&#123; return this.name; &#125;// 在考虑Object.create 这个方法的兼容性不够，所以采用自己模拟这个功能的写法，如果不需要考虑IE9一下版本的话可以直接使用虑Object.create 更简单一些function inherit(sub,sup)&#123; function Fn()&#123;&#125;; Fn.prototype = sup.prototype; var fn = new Fn(); Object.defineProperty(fn,&apos;constructor&apos;,&#123;value:sub&#125;) // 增强原型 sub.prototype = fn;&#125;function Child (name,age,sex)&#123; Parent.call(this,name,age) this.sex = sex;&#125;inherit(Child,Parent);var child = new Child(&apos;李雷&apos;,18,&apos;男&apos;)console.log(child.getName()); // 李雷希望对正在学习这方面只是的小伙伴们有帮助吧, 以上观点也是我总结的一些。如果有任何疑问或者文章内有错误，可以发邮件到1043951234@qq.com 进行交流，如果有错误我会第一时间更正，感谢您的赐教","categories":[{"name":"原生js","slug":"原生js","permalink":"http://yoursite.com/categories/原生js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"react 声明周期","slug":"reactLifeCycle","date":"2017-07-01T16:00:00.000Z","updated":"2018-03-22T04:42:07.293Z","comments":true,"path":"2017/07/02/reactLifeCycle/","link":"","permalink":"http://yoursite.com/2017/07/02/reactLifeCycle/","excerpt":"","text":"react 的声明周期先上一张图，我们会根据这张图来分析react的声明周期其实是可以分为两大类的，第一种是组件实例化时只执行一次的，第二种是组件存在时会跟着组件内部操作而触发的；那就让我们分别来看看他们在react的一个组件组件中所充当的角色一、getDefaultProps12345678910111213import React from 'react'; *以后的代码省略这行代码了import PropTypes from 'prop-types';class Component extends React.Component&#123; static defaultProps = &#123; name: 'yang' &#125; render() &#123; return ( &lt;div&gt;Hello, &#123;this.props.name&#125;&lt;/div&gt; ) &#125;&#125;当组件实例化的时候会执行defaultProps这个函数，作用是设置组件所需参数的默认值、也可以配合prop-types这个包来进行参数验证prop-types注释 ： extends 是 es6 中类继承的语法；123456789 // 例如： 你想让类A 继承类B 那么写法 就是class A extends B &#123; //(类的名字最好是首字母大写，保持这种良好的代码风格) constructor()&#123; super(); // 在es5 一个构造函数继承另外一个构造函数的时候，会有很多方法：call继承，原型继承，组合式继承，寄生组合式继承（如果不知道的小伙变要好好学习了） // 而es6 中类继承则是通过super来进行的 ，super的特性不属于本篇文章的讨论范围，如果感兴趣的话可以去翻查一下 &#125;&#125;二、getInitialState12345678class Component extends React.Component&#123; constructor()&#123; super(); this.state = &#123; render: true &#125; &#125;&#125;当组件实例化的时候会对实例的一些私有属性进行初始化，对es6语法了解的话，应该很容易理解，如果对es6的class类的语法不了解的话建议大家先去了解一下es6, state是组件内部状态，这个属性十分的重要，state的属性变更会直接影响这组件的渲染三、componentWillMount是组件挂载前的最后一个生命周期，只执行一次，最后修改state的机会四 render12345678910111213class Component extends React.Component&#123; constructor()&#123; super(); this.state = &#123; name: &apos;yang&apos; &#125; &#125; render()&#123; return ( &lt;div&gt; `hello $&#123;this.state.name&#125;`&lt;/div&gt; ) &#125;&#125;组件渲染，render方法会根据return 的返回结果生成虚拟的DOM，经过react内部机制的DOM Diff 比对后，渲染到页面上。在render函数中有几个注意事项:必须存在一个根节点不可以修改state可以输出null，false五 componentDidMount组件挂载完成，通常我们会在这个生命周期函数内进行页面数据的请求操作， 只会执行一次六 componentWillReceiveProps1234567891011121314151617181920class Component extends React.Component&#123; constructor()&#123; super(); this.state = &#123; name: this.props.name || 'yang' &#125; &#125; componentWillReceiveProps(nextProps)&#123; if(typeof nextProps.name !== 'undefined')&#123; this.setState(&#123; name: nextProps.name &#125;) &#125; &#125; render()&#123; return ( &lt;div&gt; `hello $&#123;this.state.name&#125;`&lt;/div&gt; ) &#125;&#125;当外部传入的参数发生改变的时候会触发componentWillReceiveProps这个函数的执行，在函数里可以修改本组件的state值，不用担心会引起render的多次调用七 shouldComponentUpdate12345678910111213141516class Component extends React.Component&#123; constructor()&#123; super(); this.state = &#123; name: this.props.name || 'yang' &#125; &#125; shouldComponentUpdate(nextProps,nextState)&#123; return nextProps.name != this.props.name; &#125; render()&#123; return ( &lt;div&gt; `hello $&#123;this.state.name&#125;`&lt;/div&gt; ) &#125;&#125;这个生命周期函数是在props和state发生改变时必然会触发的，如果没有手动声明，默认为true ，如果手动设置为false 组件将不会在更新；这个生命周期是开发者在react开发的时候对性能优化上帮助最大的，很多开发这都轻视了这个函数。八 componentWillUpdatestate或者props发生改变时，在组件准备更新之前执行的生命周期函数，在这个生命周期内不要在去修改state和props 不然后果很严重九 componentDidUpdate组件重新渲染后会被调用，在这个函数中可以获取到更新之后的数据和dom元素十 componentWillUnmount当用户执行移除组件或者删除组件的操作后，在执行前触发的生命周期函数，但是react对善后工作做的不是很到位，如果你在组件中创建了计时器这种异步操作事件，在componentWillUnmount函数中一定要手动的移除这些事件，否则会报错123456789101112131415161718192021222324class Component extends React.Component&#123; constructor()&#123; super(); this.state = &#123; name: this.props.name || 'yang' &#125; &#125; componentDidMount()&#123; this.timer = setTimeout(()=&gt;&#123; this.setState(&#123;name:'我要卸载了'&#125;) &#125;,5000) &#125; componentWillUnmount()&#123; clearTimeout(this.timer) &#125; handelClick()&#123; ReactDom.unmountComponentAtNode(window.root) &#125; render()&#123; return ( &lt;div onClick=&#123;this.handelClick&#125;&gt; `hello $&#123;this.state.name&#125;`&lt;/div&gt; ) &#125;&#125;对react 生命周期的以一些理解，希望对您有帮助","categories":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/categories/前端框架/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"react 基础篇（三）","slug":"reactBase3","date":"2017-06-24T16:00:00.000Z","updated":"2018-03-18T11:15:53.165Z","comments":true,"path":"2017/06/25/reactBase3/","link":"","permalink":"http://yoursite.com/2017/06/25/reactBase3/","excerpt":"","text":"react 的基本语法首先我们要了解react 的jsx语法react 使用 jsx 语法来代替常规的javascript 使用起来很像 html+javascript的组合jsx的优点 ：1、执行更快，因为它在编译为 JavaScript 代码后进行了优化2、它是类型安全的，在编译过程中就能发现错误3、使用 JSX 编写模板更加简单快速注意事项 ： 1、 想要在jsx中使用js语法需要使用‘{}’ 例： { this.state.name }2、 在jsx 中不能使用if else 可以改用三元运算符3、 jsx 中的注释写法 ：{/*注释…*/}我们先看一下这么一段代码123456789101112131415// 本篇文章代码必须引入的两个组件，后面的代码中省略import React from 'react';import ReactDOM from 'react-dom';let str = '20170109';function build(str) &#123; return ( &lt;div&gt; &lt;h1&gt;&#123;str&#125;&lt;/h1&gt; &lt;h2&gt;&#123;true ? str : null&#125;&lt;/h2&gt; &lt;/div&gt; )&#125;let el = &lt;div&gt;&#123;build('react的基本语法！')&#125;&lt;/div&gt;;ReactDOM.render(el, document.getElementById('root'));下面我们看一下组件的写法123456789101112131415161718192021let student1 = &#123;name: '小明', age: 15&#125;;let student2 = &#123;name: '李雷', age: 16&#125;;class Achievement extends React.Component &#123; render()&#123; // 这个组件在调用时，默认会调用render方法 let &#123;name,age&#125; = this.props; // 使用解构的方法可以让我们在写参数的时候更少 return &lt;p&gt;&#123;name&#125; &#123;age&#125;&lt;/p&gt;; // 也可以 return &lt;p&gt;&#123;this.props.name&#125; &#123;this.props.age&#125;&lt;/p&gt; &#125;&#125;// 组件的传参的两种方法，可以使用es6的解构方式，也可以一个个传ReactDOM.render(&lt;div&gt; &lt;Achievement &#123;...student1&#125;/&gt; &lt;Achievement name=&#123;student2.name&#125; age=&#123;student2.age&#125;/&gt;&lt;/div&gt;, window.root);// 注意 ： &lt;Achievement age=9/&gt; 这样传递参数的时候，在组件内部调用this.props.age 的时候是字符串类型而不是数字类型---列表类的输出方式12345678910111213141516let students = [ &#123;name: '李雷', sex: '男'&#125;, &#123;name: '李华', sex: '男'&#125;, &#123;name: '小红', sex: '女'&#125;];ReactDOM.render(( &lt;ul&gt; &#123;lessons.map((item, index) =&gt; ( &lt;li key=&#123;index&#125;&gt;姓名：&#123;item.name&#125;;性别：&#123;item.sex&#125;&lt;/li&gt; ) )&#125; &lt;/ul&gt;), document.getElementById('root'));一定要注意的是 如果你有代码的格式洁癖，请用() 将代码包裹起来，防止react不能正常解析这段代码，在react中循环输出的时候一定要在输出的元素上添加 key 属性，否则会出现警报，虽然这个警报不会影响你代码的执行，但是会影响性能，因为在react 中保证性能的 DOM Diff 会使用到这个属性 ,不是本篇文章的讨论范围属性上的渲染123456789101112131415let style = &#123; backgroundColor : 'red', color : 'blue', fontSize : '20px'&#125;;ReactDOM.render(( &lt;ul style=&#123;style&#125;&gt; &lt;li className='aa'&gt;1&lt;/li&gt; &lt;li&gt;&lt;label htmlFor='aa'&gt;-&lt;/label&gt;&lt;input id='aa'/&gt;&lt;/li&gt; &lt;li dangerouslySetInnerHTML=&#123;&#123;__html:'&lt;span&gt;123&lt;/span&gt;'&#125;&#125;&gt;&lt;/li&gt; &lt;/ul&gt;),window.root);// 这里需要注意的是 这里的style是对象数据类型要了解是react中dom的属性有一些已经变成react中的关键字，所以写法上会和以前的写法不同，例如：class -&gt; className; for -&gt; htmlFor …如果你必不可免的要在一个结构中插入许多标签，可以使用dangerouslySetInnerHTML（安全插入），因为有可能不合时宜的使用innerHTML会导致XSS攻击；事件上的绑定1234567891011121314151617181920212223242526272829303132333435363738394041// 我们以input 来举例， 顺便也说以下react 实现双向数据绑定的方法// 写法一class Input extends React.Component&#123; constructor()&#123; super(); this.state = &#123;val:''&#125; &#125; handleFn(e)&#123; this.setState(&#123;val:e.target.value&#125;); &#125; render()&#123; return ( &lt;div&gt; &lt;input type=\"text\" value=&#123;this.state.val&#125; onChange=&#123;this.handleFn.bind(this)&#125;/&gt; &#123;this.state.val&#125; &lt;/div&gt; ) &#125;&#125;// 写法二class Input extends React.Component&#123; constructor()&#123; super(); this.state = &#123;val:''&#125; &#125; handleFn = (e)=&gt;&#123; this.setState(&#123;val:e.target.value&#125;); &#125; render()&#123; return ( &lt;div&gt; &lt;input type=\"text\" value=&#123;this.state.val&#125; onChange=&#123;this.handleFn&#125;/&gt; &#123;this.state.val&#125; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;Input/&gt;,window.root);上面有两种写法，当然第二种使用了es6和es7的语法所以写起来很简洁，也不用担心this错误的问题，所以在babel可以解析的语法，我们都可以在项目中使用我们简单说一下 react 的双向数据绑定，大家都知道react 是 MVC框架（单向数据绑定），所以我们想实现双向数据绑定就要借助其他的方法，react 能引起视图渲染的方法只有修改state和props，所以我们想要是想双向数据绑定，我们就要去操作state和props，那我们实现一下1234567891011121314151617181920212223242526272829303132333435363738class Parent extends React.Component &#123; constructor() &#123; super(); this.state = &#123;val: ''&#125; &#125; changeFn = (e) =&gt; &#123; this.setState(&#123;val: e.target.value&#125;); &#125;; render() &#123; return ( &lt;Input value=&#123;this.state.val&#125; changeFn=&#123;this.changeFn&#125;/&gt; ) &#125;&#125;class Input extends React.Component &#123; constructor() &#123; super(); this.state = &#123;val: ''&#125; &#125; handleFn = (e) =&gt; &#123; this.setState(&#123;val: e.target.value&#125;); &#125;; render() &#123; let &#123;value,changeFn&#125; = this.props; return ( &lt;div&gt; &lt;input type=\"text\" value=&#123;this.state.val&#125; onChange=&#123;this.handleFn&#125;/&gt; &#123;this.state.val&#125; &lt;input type=\"text\" value=&#123;value&#125; onChange=&#123;changeFn&#125;/&gt; &#123;value&#125; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;Parent/&gt;,window.root)需要用事件来触发state或者props的修改来让视图重新渲染，来实现双向绑定还有一种不提倡的方法，就是直接通过ref 来操作DOM也可以实现，不过既然使用react了，还在操作DOM 那就太low了。所以我们要习惯这种数据驱动视图的思想。","categories":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/categories/前端框架/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"react 基础篇（二）","slug":"reactBase2","date":"2017-06-17T16:00:00.000Z","updated":"2018-03-18T11:15:25.699Z","comments":true,"path":"2017/06/18/reactBase2/","link":"","permalink":"http://yoursite.com/2017/06/18/reactBase2/","excerpt":"","text":"webpack 的基本配置想要实现项目的自动化管理，还是需要依赖自动化构建工具，这篇文章主要讲述的是webpack的基本配置12$ npm install webpack webpack-dev-server --save-dev // 或者使用yarn$ npm install style-loader css-loader url-loader file-loader less-loader html-webpack-plugin --save-dev上面安装的的是一个项目基本必须要使用的一些依赖包安装完成之后我们来看一下webpack该如何配置12345678910111213141516171819202122232425// 这个插件是为了webpack打包后的代码可以插入到我们html中的let HtmlWebpackPlugin = require(\"html-webpack-plugin\");// 我们先配置一个文件配置module.exports = &#123; entry: \"./src/index.js\", // 入口文件 output: &#123; // 出口 filename: \"build.js\", // 文件名 path: require('path').resolve('/dist') // 文件路径，这个需要填写绝对路径，所以我们引用path插件，来将一个相对路径转换成绝对路径 &#125;, module: &#123; rules: [ // 配置文件解析规则， &#123;test: /\\.js$/, use: \"babel-loader\", exclude: /node_modules/&#125;, &#123;test: /\\.css$/, use: [\"style-loader\", \"css-loader\"]&#125;, &#123;test: /\\.less$/, use: [\"style-loader\", \"css-loader\", \"less-loader\"]&#125;, &#123;test: /\\.(jpg|png|gif|jpeg)$/, use: \"url-loader\"&#125;, ] &#125;, devtool: 'source-map', /*源码映射*/ plugins: [ // 插件 new HtmlWebpackPlugin(&#123; template: \"./index.html\" &#125;) ]&#125;;多个文件的配置方法1234567891011module.exports = &#123; entry: &#123; app: &apos;./src/app.js&apos;, search: &apos;./src/search.js&apos; &#125;, output: &#123; filename: &apos;[name].js&apos;, path: __dirname + &apos;/dist&apos; &#125; ......&#125;webpack还有更多的配置参数，我们先配置一个简单的当然我们想要将环境跑起来，还需要在package.json文件中的scripts中配置一些启动环境的指令123456// 截取部分代码\"scripts\": &#123; \"dev\": \"webpack-dev-server --config webpack.config.js\", \"start\": \"npm run dev\", \"build\": \"webpack --config webpack.config.js\" // 打包时使用的代码 &#125;,配置完成后，我们就可以执行 start 来开启一个本地端口来运行我们的代码了是不是很简单呢，快来写一写react代码来感受一下吧","categories":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/categories/前端框架/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"react 基础篇（一）","slug":"reactBase1","date":"2017-06-10T16:00:00.000Z","updated":"2018-03-22T04:14:57.561Z","comments":true,"path":"2017/06/11/reactBase1/","link":"","permalink":"http://yoursite.com/2017/06/11/reactBase1/","excerpt":"","text":"react 安装对于入门的人来说，是从无到有的过程，首先我们要先了解一下如何使用框架1、首先要安装node.js 在Node下载，node的版本会影响你可用的功能和一些语法支持，所以尽量使用高版本的node2、node会自带npm包管理器，Npm，使用npm的指令来安装react项目中需要用到的组件，插件，翻译官(babel)等,如果下载缓慢的话可以采用taobao镜像，也可以使用yarn来安装，速度会快一些。1$ npm install -g cnpm --registry=https://registry.npm.taobao.org3、创建一个新的文件夹，在这个文件夹中调用命令窗口（Shift+右键）调用cmd命令窗口输入指令12$ npm init // 生成一个package.json文件 ，一步步配置文件信息$ npm init -y // 自动提取文件信息生成一个默认的package.json文件如果想使用yarn 首先要通过1$ npm install yarn -g //来安装之后就可以使用yarn的语法了4、安装react：123$ npm install react react-dom//或者$ yarn add react react-dom在react项目中还需要很多辅助插件：babel 这个翻译官 是在框架项目中必备的，它可以将项目中的es2015(es6)-es2017(es8)的语法转换成现在所有浏览器支持程度最高的es5语法；【注意】：像Set、Map这种是不会被翻译的。babel 的核心包 babel-core5、安装babel123$ npm babel-core babel-preset-stage-0 babel-preset-react babel-loader babel-preset-env --save-dev// --save-dev 是将安装这些依赖包安装在开发环境中在现在流行的框架开发中，有开发环境和生产环境，所谓的开发环境就是项目在开发过程中所依赖的环境；生产环境就是上线之后，项目面对用户的真实环境6、配置文件我们还需要在根目录下创建一个 .babelrc 文件（没有文件名称）在里面配置一些东西12345// .babelrc 文件内[ &quot;presets&quot;:[&quot;react&quot;,&quot;env&quot;,&quot;stage-0&quot;]]env是可以解析es6及以前的语法，但是在用的后发现，他无法解析es6以上的一些草案语法，所以为了可以使用更高级的语法，在后面加上stage-0 保险起见；完成以上操作其实你就已经开启了你的react之旅了","categories":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/categories/前端框架/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"javascript Ajax","slug":"ajax","date":"2017-05-06T16:00:00.000Z","updated":"2018-03-18T11:18:44.130Z","comments":true,"path":"2017/05/07/ajax/","link":"","permalink":"http://yoursite.com/2017/05/07/ajax/","excerpt":"","text":"在学习AJAX原理的时候我尝试这封装过自己的AJAX，作为我学习AJAX的纪念吧123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157/* * 参数 * url : 请求地址 * method : 请求类型 * data : 请求参数 * dataType : 数据类型 * async : 是否异步 * cache : 是否清缓存 * success : 成功执行函数 * error : 失败后执行函数 * timeoutTimer : 等待时长*/(function () &#123; class ajaxFn &#123; constructor(url, options) &#123; // 如果传入的是一个对象的话，options 就被 url 替换 if (typeof url === &apos;object&apos;) &#123; options = url; url = undefined; &#125; options = Object.prototype.toString.call(options).slice(8, -1) === &apos;Object&apos; ? options : &#123;&#125;; this.url = url || options.url; this.options = &#123; method: options.type || options.method || &apos;GET&apos;, data: options.data || null, dataType: options.dataType || &apos;JSON&apos;, async: options.async || true, cache: options.cache || true, success: typeof options.success === &apos;function&apos; ? options.success : function () &#123; &#125;, error: typeof options.error === &apos;function&apos; ? options.error : function () &#123; &#125;, timeoutTimer: options.timeoutTimer || null &#125;; this.isGet = /(^|\\s+)(head|detele|get)(\\s+|$)/i.test(this.options.method); this.isLocal = window.XMLHttpRequest; &#125; formatData() &#123; if (Object.prototype.toString.call(this.options.data).slice(8, -1) === &apos;Object&apos;) &#123; let obj = this.options.data, str = ``; for (let key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; str += `$&#123;key&#125;=$&#123;obj[key]&#125;&amp;` &#125; &#125; str = str.replace(/&amp;$/g, &apos;&apos;); this.options.data = str; &#125; &#125; queryURL() &#123; return this.url.indexOf(&quot;?&quot;) === -1 ? &quot;?&quot; : &quot;&amp;&quot;; &#125; cacheFn() &#123; return !this.cache ? `$&#123;this.queryURL()&#125;_=$&#123;Math.random()&#125;` : ``; &#125; createStandardXHR() &#123; try &#123; return new window.XMLHttpRequest(); &#125; catch (e) &#123; &#125; &#125; createActiveXHR() &#123; try &#123; return new window.ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; catch (e) &#123; &#125; &#125; serialize(form) &#123; let parts = [], field = null, option, optValue; for (let i = 0; i &lt; form.elements.length; i++) &#123; field = form.elements[i]; switch (field.type) &#123; case &quot;select-one&quot;: case &quot;select-multiple&quot;: if (field.name.length) &#123; for (let j = 0; j &lt; field.options.length; j++) &#123; option = field.options[j]; if (option.selected) &#123; optValue = &apos;&apos;; if (optioin.hasAttribute) &#123; optValue = (option.hasAttribute(&apos;value&apos;) ? option.value : option.text); &#125; else &#123; optValue = (option.attributes[&apos;value&apos;].specified ? option.value : option.text); &#125; parts.push(encodeURIComponent(field.name) + &apos;=&apos; + encodeURIComponent(optValue)); &#125; &#125; &#125; break; case undefined: //字段集 case &apos;file&apos;: //文件输入 case &apos;submit&apos;: //提交按钮 case &apos;reset&apos;: //重置按钮 case &apos;button&apos;: //自定义按钮 break; case &apos;radio&apos;: //单选按钮 case &apos;checkbox&apos;: //复选框 if (!field.checked) &#123; break; &#125; break; default: if (field.name.length) &#123; parts.push(encodeURIComponent(field.name) + &apos;=&apos; + encodeURIComponent(field.value)); &#125; &#125; &#125; return parts.join(&apos;&amp;&apos;); &#125; &#125; window.ajax = function (url, options) &#123; let example = new ajaxFn(url, options); url = example.url || null; options = example.options || &#123;&#125;; let xhr = example.isLocal ? example.createStandardXHR() : example.createActiveXHR(); xhr.onreadystatechange = function () &#123; if (xhr.readyState === 2) &#123; let response = xhr.responseText; &#125; if (xhr.readyState === 4) &#123; if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status === 304) &#123; let response = xhr.responseText; options.success(response); &#125; if (xhr.status &gt;= 400 &amp;&amp; xhr.status &lt; 600) &#123; let response = xhr.responseText; options.error(response); &#125; &#125; &#125;; if (options.data != null) &#123; example.formatData(); if (example.isGet) &#123; url += example.queryURL() + encodeURIComponent(options.data); options.data = null; &#125; &#125; example.isGet &amp;&amp; (url += example.cacheFn()); xhr.open(options.method, url, options.async); xhr.send(options.data); &#125;;&#125;)();","categories":[{"name":"原生js","slug":"原生js","permalink":"http://yoursite.com/categories/原生js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"javascript Utils","slug":"jsCommonFn","date":"2017-05-05T16:00:00.000Z","updated":"2018-03-22T04:12:24.147Z","comments":true,"path":"2017/05/06/jsCommonFn/","link":"","permalink":"http://yoursite.com/2017/05/06/jsCommonFn/","excerpt":"","text":"平时在工作中我们在使用javascript开发的时候会很怀念jQuery，因为Jquery中很多的方法都非常的好用，而且还能兼容ie的低版本浏览器，虽然大家现在都在慢慢的抛弃ie低版本的浏览器，不过一些方法的封装思想还是要常常回顾一下，温故而知新嘛！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341var utils = (function () &#123; var _flag = /MSIE [678]/i.test(navigator.userAgent); var toTrim = function (str) &#123; return str.replace(/^\\s+|\\s+$/g, &apos;&apos;); &#125;; var toJSON = function (str) &#123; return window.JSON ? JSON.parse(str) : eval(&apos;(&apos; + str + &apos;)&apos;); &#125;; var toArray = function (classAry) &#123; var ary = []; if (!_flag) &#123; ary = Array.prototype.slice.call(classAry); &#125; else &#123; for (var i = 0; i &lt; classAry.length; i++) &#123; ary[ary.length] = classAry[i]; &#125; &#125; return ary; &#125;; var getEleClassName = function (strClass, context) &#123; context = context || document; if (!_flag) &#123; getEleClassName = function (strClass, context) &#123; context = context || document; return toArray(context.getElementsByClassName(strClass)); &#125; &#125; else &#123; getEleClassName = function (strClass, context) &#123; context = context || document; var result = [], classNode = context.getElementsByTagName(&apos;*&apos;); strClass = strClass.replace(/^\\s+|\\s+$/g, &apos;&apos;).split(/\\s+/); for (var i = 0; i &lt; classNode.length; i++) &#123; var item = classNode[i], itemClass = item.className, flag = true; for (var j = 0; j &lt; strClass.length; j++) &#123; var reg = new RegExp(&apos;(^|\\\\s)&apos; + strClass[j] + &apos;(\\\\s+|$)&apos;); if (!reg.test(itemClass)) &#123; flag = false; break; &#125; &#125; flag ? result.push(item) : null; &#125; return result; &#125; &#125; return getEleClassName(strClass, context); &#125;; var getEleChildren = function (curEle, tagName) &#123; var result = [], childNode = curEle.childNodes; for (var i = 0; i &lt; childNode.length; i++) &#123; var item = childNode[i]; if (item.nodeType === 1) &#123; if (tagName) &#123; if (item.nodeName === tagName.toLocaleUpperCase()) &#123; result.push(item); &#125; continue; &#125; result.push(item); &#125; &#125; return result; &#125;; var getCss = function (curEle, attr) &#123; if (!_flag) &#123; getCss = function (curEle, attr) &#123; var value = window.getComputedStyle(curEle, null)[attr]; var reg = /^-?\\d+(\\.\\d+)?(px|pt|em|rem)?$/g; reg.test(value) ? value = parseFloat(value) : null; return value; &#125; &#125; else &#123; getCss = function (curEle, attr) &#123; var value = null; if (attr === &apos;opacity&apos;) &#123; value = curEle.currentStyle[&apos;filter&apos;]; value = (value === &apos;&apos;) ? 1 : value.replace(/(?:=)(.+)(?:\\))/g, function () &#123; return arguments[1] / 100; &#125;) &#125; else &#123; value = curEle.currentStyle[attr]; &#125; var reg = /^-?\\d+(\\.\\d+)?(px|pt|em|rem)?$/g; reg.test(value) ? value = parseFloat(value) : null; return value; &#125; &#125; return getCss(curEle, attr); &#125;; var setCss = function (curEle, attr, value) &#123; if (attr === &apos;opacity&apos;) &#123; curEle.style[&apos;opacity&apos;] = value; curEle.style[&apos;filter&apos;] = &apos;alpha(opacity=&apos; + value * 100 + &apos;)&apos;; return; &#125; !isNaN(value) &amp;&amp; !/^(zIndex|zoom|fontWeight|lineHeight)$/i.test(attr) ? value += &apos;px&apos; : null; curEle.style[attr] = value; &#125;; var setGroupCss = function (curEle, options) &#123; if (Object.prototype.toString.call(options).slice(8, -1) !== &apos;Object&apos;) return; for (var key in options) &#123; if (options.hasOwnProperty(key)) &#123; setCss(curEle, key, options[key]); &#125; &#125; &#125;; var css = function () &#123; var len = arguments.length, fn = getCss, type = Object.prototype.toString.call(arguments[1]).slice(8, -1); len &gt;= 3 ? fn = setCss : (len === 2 &amp;&amp; type === &apos;Object&apos;) ? fn = setGroupCss : null; return fn.apply(this, arguments); &#125;; var offset = function (curEle) &#123; var $t = curEle.offsetTop, $l = curEle.offsetLeft, $p = curEle.offsetParent; while ($p.nodeName !== &apos;BODY&apos;) &#123; if (/MSIE 8/i.test(navigator.userAgent)) &#123; $t += $p.clientTop; $l += $p.clientLeft; &#125; $t += $p.offsetTop; $l += $p.offsetLeft; $p = $p.offsetParent; &#125; return &#123;top: $t, left: $l&#125;; &#125;; var winBox = function (attr, value) &#123; if (typeof value !== &apos;undefined&apos;) &#123; document.documentElement[attr] = value; document.body[attr] = value; return; &#125; return document.documentElement[attr] || document.body[attr] &#125;; var hasClass = function (curEle, cls) &#123; var flag = true, reg = null, curClassName = curEle.className; cls = toTrim(cls).split(/\\s+/); if (cls.length &lt;= 1) &#123; reg = new RegExp(&apos;(?:^|\\\\s+)&apos; + cls + &apos;(?:\\\\s+|$)&apos;); return curClassName.match(reg); &#125; else &#123; for (var i = 0; i &lt; cls.length; i++) &#123; reg = new RegExp(&apos;(?:^|\\\\s+)&apos; + cls[i] + &apos;(?:\\\\s+|$)&apos;); if (!reg.test(curClassName)) &#123; flag = false; break; &#125; &#125; return flag; &#125; &#125;; var addClass = function (curEle, cls) &#123; cls = toTrim(cls).split(/\\s+/); for (var i = 0; i &lt; cls.length; i++) &#123; if (!hasClass(curEle, cls[i])) &#123; curEle.className += &apos; &apos; + cls[i]; &#125; &#125; curEle.className = toTrim(curEle.className).replace(/\\s+/g, &apos; &apos;); &#125;; var removeClass = function (curEle, cls) &#123; cls = toTrim(cls).split(/\\s+/); for (var i = 0; i &lt; cls.length; i++) &#123; if (hasClass(curEle, cls[i])) &#123; var reg = new RegExp(&apos;(?:^|\\\\s)&apos; + cls[i] + &apos;(?:\\\\s|$)&apos;); curEle.className = curEle.className.replace(reg, &apos; &apos;); &#125; &#125; curEle.className = toTrim(curEle.className).replace(/\\s+/g, &apos; &apos;); &#125;; var addEventHandler = function (target, type, fn) &#123; if (target.addEventListener) &#123; target.addEventListener(type, fn); &#125; else &#123; target.attachEvent(&quot;on&quot; + type, fn); &#125; &#125;; var removeEventHandler = function (target, type, fn) &#123; if (target.removeEventListener) &#123; target.removeEventListener(type, fn); &#125; else &#123; target.detachEvent(&quot;on&quot; + type, fn); &#125; &#125;; var siblings = function (curEle, tagName) &#123; var result = []; var previous = curEle.previousSibling; var next = curEle.nextSibling; if (tagName) &#123; tagName = toTrim(tagName); if (/\\.[\\w-]/g.test(tagName)) &#123; tagName = tagName.replace(/\\./g, &apos;&apos;); var reg = new RegExp(&apos;(?:^|\\\\s+)&apos; + tagName + &apos;(?:\\\\s+|$)&apos;); while (previous) &#123; if (reg.test(previous.className)) &#123; result.unshift(previous); &#125; previous = previous.previousSibling; &#125; while (next) &#123; if (reg.test(next.className)) &#123; result.push(next) &#125; next = next.nextSibling; &#125; &#125; else &#123; while (previous) &#123; if (previous.nodeName === tagName.toLocaleUpperCase()) &#123; result.unshift(previous); &#125; previous = previous.previousSibling; &#125; while (next) &#123; if (next.nodeName === tagName.toLocaleUpperCase()) &#123; result.push(next) &#125; next = next.nextSibling; &#125; &#125; &#125; else &#123; while (previous) &#123; if (previous.nodeType === 1) &#123; result.unshift(previous); &#125; previous = previous.previousSibling; &#125; while (next) &#123; if (next.nodeType === 1) &#123; result.push(next); &#125; next = next.nextSibling; &#125; &#125; return result; &#125;; var find = function (curEle, cls) &#123; var result = []; var nodeList = curEle.getElementsByTagName(&apos;*&apos;); if (cls) &#123; cls = toTrim(cls); if (/\\.[\\w-]/g.test(cls)) &#123; cls = cls.replace(/\\./, &apos;&apos;); for (var i = 0; i &lt; nodeList.length; i++) &#123; var reg = new RegExp(&apos;(?:^|\\\\s+)&apos; + cls + &apos;(?:\\\\s+|$)&apos;); if (reg.test(nodeList[i].className)) &#123; result.push(nodeList[i]); &#125; &#125; &#125; else &#123; for (var j = 0; j &lt; nodeList.length; j++) &#123; if (nodeList[j].nodeName === cls.toLocaleUpperCase()) &#123; result.push(nodeList[j]); &#125; &#125; &#125; &#125; return result; &#125;; var getPrevEle = function (curEle) &#123; var item = curEle.previousSibling; while (item) &#123; if (item.nodeType === 1) &#123; return item; &#125; item = item.previousSibling; &#125; &#125;; var getPrevAll = function (curEle) &#123; var result = []; var previous = curEle.previousSibling; while (previous) &#123; if (previous.nodeName === 1) &#123; result.unshift(previous); &#125; previous = previous.previousSibling; &#125; return result; &#125;; var getNextEle = function (curEle) &#123; var item = curEle.nextSibling; while (item) &#123; if (item.nodeType === 1) &#123; return item; &#125; item = item.nextSibling; &#125; &#125;; var getNextAll = function (curEle) &#123; var result = []; var next = curEle.nextSibling; while (next) &#123; if (next.nodeName === 1) &#123; result.push(next); &#125; next = next.nextSibling; &#125; return result; &#125;; var getFirstChild = function(curEle)&#123; return getEleTagName(curEle)[0]; &#125;; var getLastChild = function(curEle)&#123; return getEleTagName(curEle)[getEleTagName(curEle).length-1]; &#125;; return &#123; toTrim: toTrim, toJSON: toJSON, toArray: toArray, getEleClassName: getEleClassName, getEleChildren: getEleChildren, css: css, offset: offset, winBox: winBox, hasClass: hasClass, addClass: addClass, removeClass: removeClass, addEventHandler: addEventHandler, removeEventHandler: removeEventHandler, siblings: siblings, find: find, getPrevEle:getPrevEle, getPrevAll:getPrevAll, getNextEle:getNextEle, getNextAll:getNextAll, getFirstChild:getFirstChild, getLastChild:getLastChild &#125;&#125;)();封装一些我们常用的方法，可以让我们的开发更具有效率。","categories":[{"name":"原生js","slug":"原生js","permalink":"http://yoursite.com/categories/原生js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]}]}