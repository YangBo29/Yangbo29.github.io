{"meta":{"title":"我的博客","subtitle":null,"description":null,"author":"杨波","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"react 声明周期","slug":"reactLifeCycle","date":"2018-03-14T12:51:51.282Z","updated":"2018-03-15T07:04:38.831Z","comments":true,"path":"2018/03/14/reactLifeCycle/","link":"","permalink":"http://yoursite.com/2018/03/14/reactLifeCycle/","excerpt":"","text":"react 的声明周期先上一张图，我们会根据这张图来分析react的声明周期其实是可以分为两大类的，第一种是组件实例化时只执行一次的，第二种是组件存在时会跟着组件内部操作而触发的；那就让我们分别来看看他们在react的一个组件组件中所充当的角色一、getDefaultProps12345678910111213import React from 'react'; *以后的代码省略这行代码了import PropTypes from 'prop-types';class Component extends React.Component&#123; static defaultProps = &#123; name: 'yang' &#125; render() &#123; return ( &lt;div&gt;Hello, &#123;this.props.name&#125;&lt;/div&gt; ) &#125;&#125;当组件实例化的时候会执行defaultProps这个函数，作用是设置组件所需参数的默认值、也可以配合prop-types这个包来进行参数验证prop-types注释 ： extends 是 es6 中类继承的语法；123456789 // 例如： 你想让类A 继承类B 那么写法 就是class A extends B &#123; //(类的名字最好是首字母大写，保持这种良好的代码风格) constructor()&#123; super(); // 在es5 一个构造函数继承另外一个构造函数的时候，会有很多方法：call继承，原型继承，组合式继承，寄生组合式继承（如果不知道的小伙变要好好学习了） // 而es6 中类继承则是通过super来进行的 ，super的特性不属于本篇文章的讨论范围，如果感兴趣的话可以去翻查一下 &#125;&#125;二、getInitialState12345678class Component extends React.Component&#123; constructor()&#123; super(); this.state = &#123; render: true &#125; &#125;&#125;当组件实例化的时候会对实例的一些私有属性进行初始化，对es6语法了解的话，应该很容易理解，如果对es6的class类的语法不了解的话建议大家先去了解一下es6, state是组件内部状态，这个属性十分的重要，state的属性变更会直接影响这组件的渲染三、componentWillMount是组件挂载前的最后一个生命周期，只执行一次，最后修改state的机会四 render12345678910111213class Component extends React.Component&#123; constructor()&#123; super(); this.state = &#123; name: &apos;yang&apos; &#125; &#125; render()&#123; return ( &lt;div&gt; `hello $&#123;this.state.name&#125;`&lt;/div&gt; ) &#125;&#125;组件渲染，render方法会根据return 的返回结果生成虚拟的DOM，经过react内部机制的DOM Diff 比对后，渲染到页面上。在render函数中有几个注意事项:1) 必须存在一个根节点2) 不可以修改state3) 可以输出null，false五 componentDidMount组件挂载完成，通常我们会在这个生命周期函数内进行页面数据的请求操作， 只会执行一次六 componentWillReceiveProps1234567891011121314151617181920class Component extends React.Component&#123; constructor()&#123; super(); this.state = &#123; name: this.props.name || 'yang' &#125; &#125; componentWillReceiveProps(nextProps)&#123; if(typeof nextProps.name !== 'undefined')&#123; this.setState(&#123; name: nextProps.name &#125;) &#125; &#125; render()&#123; return ( &lt;div&gt; `hello $&#123;this.state.name&#125;`&lt;/div&gt; ) &#125;&#125;当外部传入的参数发生改变的时候会触发componentWillReceiveProps这个函数的执行，在函数里可以修改本组件的state值，不用担心会引起render的多次调用七 shouldComponentUpdate12345678910111213141516class Component extends React.Component&#123; constructor()&#123; super(); this.state = &#123; name: this.props.name || 'yang' &#125; &#125; shouldComponentUpdate(nextProps,nextState)&#123; return nextProps.name != this.props.name; &#125; render()&#123; return ( &lt;div&gt; `hello $&#123;this.state.name&#125;`&lt;/div&gt; ) &#125;&#125;这个生命周期函数是在props和state发生改变时必然会触发的，如果没有手动声明，默认为true ，如果手动设置为false 组件将不会在更新；这个生命周期是开发者在react开发的时候对性能优化上帮助最大的，很多开发这都轻视了这个函数。八 componentWillUpdatestate或者props发生改变时，在组件准备更新之前执行的生命周期函数，在这个生命周期内不要在去修改state和props 不然后果很严重九 componentDidUpdate组件重新渲染后会被调用，在这个函数中可以获取到更新之后的数据和dom元素十 componentWillUnmount当用户执行移除组件或者删除组件的操作后，在执行前触发的生命周期函数，但是react对善后工作做的不是很到位，如果你在组件中创建了计时器这种异步操作事件，在componentWillUnmount函数中一定要手动的移除这些事件，否则会报错123456789101112131415161718192021222324class Component extends React.Component&#123; constructor()&#123; super(); this.state = &#123; name: this.props.name || 'yang' &#125; &#125; componentDidMount()&#123; this.timer = setTimeout(()=&gt;&#123; this.setState(&#123;name:'我要卸载了'&#125;) &#125;,5000) &#125; componentWillUnmount()&#123; clearTimeout(this.timer) &#125; handelClick()&#123; ReactDom.unmountComponentAtNode(window.root) &#125; render()&#123; return ( &lt;div onClick=&#123;this.handelClick&#125;&gt; `hello $&#123;this.state.name&#125;`&lt;/div&gt; ) &#125;&#125;对react 生命周期的以一些理解，希望对您有帮助，图中conponentWillReceiveProps 应该是com 拼错了","categories":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/categories/前端框架/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"react 基础篇（一）","slug":"reactBase1","date":"2018-03-14T12:10:53.348Z","updated":"2018-03-14T12:49:14.586Z","comments":true,"path":"2018/03/14/reactBase1/","link":"","permalink":"http://yoursite.com/2018/03/14/reactBase1/","excerpt":"","text":"react 安装对于入门的人来说，是从无到有的过程，首先我们要先了解一下如何使用框架1、首先要安装node.js 在Node下载，node的版本会影响你可用的功能和一些语法支持，所以尽量使用高版本的node2、node会自带npm包管理器，Npm，使用npm的指令来安装react项目中需要用到的组件，插件，翻译官(babel)等,如果下载缓慢的话可以采用taobao镜像，也可以使用yarn来安装，速度会快一些。3、创建一个新的文件夹，在这个文件夹中调用命令窗口（Shift+右键）， 输入指令 npm init 初始化项目；如果想使用yarn 首先要通过 npm install yarn -g 来安装 之后就科一是用yarn的语法了4、安装react：npm install react react-dom / yarn add react react-dom 两者效果是等同的在react项目中还需要很多辅助插件：babel 这个翻译官 是在框架项目中必备的，它可以将项目中的es2015(es6)-es2017(es8)的语法转换成现在所有浏览器支持程度最高的es5语法；【注意】：像Set、Map这种是不会被翻译的。babel 的核心包 babel-core 和相关依赖 babel-preset-stage-0 babel-preset-react babel-loader babel-preset-es2015 –save-dev 都是会被用到的, –save-dev 是将安装这些依赖包安装在开发环境中那什么是开发环境呢？在现在流行的框架开发中，有开发环境和生产环境，所谓的开发环境就是项目在开发过程中所依赖的环境；生产环境就是上线之后，项目面对用户的真实环境完成以上操作其实你就已经开启了你的react之旅了","categories":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/categories/前端框架/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-03-14T03:32:29.915Z","updated":"2018-03-14T03:32:29.915Z","comments":true,"path":"2018/03/14/hello-world/","link":"","permalink":"http://yoursite.com/2018/03/14/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new \"My New Post\"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment","categories":[],"tags":[]}]}