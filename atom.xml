<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-23T10:24:08.721Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>杨波</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RegExp</title>
    <link href="http://yoursite.com/2017/11/26/regExp/"/>
    <id>http://yoursite.com/2017/11/26/regExp/</id>
    <published>2017-11-25T16:00:00.000Z</published>
    <updated>2018-03-23T10:24:08.721Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 23 2018 18:24:16 GMT+0800 (中国标准时间) --><h2 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h2><blockquote><p>释义： 具有全等正多边形各面的以及多面体的所有角均相等的</p><p>用途： 通常用于字符串的处理；指定一种规则，来验证字符串是否符合我们的要求；最多的应用在表单验证，路径解析，用户输入内容格式等；</p><p>语法： js中有两种方式创建一个正则表达式</p><ul><li>1、var reg = new RegExp(‘abc’,’g’) 或者 var reg = new RegExp(/abc/g); // 构造函数 ES6之前是允许混用的，如：new RegExp(/abc/，’g’); ES6 修改了这种行为，如果 new RegExp(/abc/i，’g’) 第二个参数会覆盖第一个参数中的修饰符</li><li>2、var reg = /abc/g // 字面量</li></ul></blockquote><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><blockquote><p>String.prototype.search() 查找符合正则的字符串出现的位置 ，如果查询不到返回 -1<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;abcregexp&apos;.search(/abc/); // =&gt; 0 首次出现的位置</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>String.prototype.replace(n,m) 替换符合正则的字符串<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&apos;abcregexp&apos;.replace(/abc/,&apos;def&apos;); // =&gt; defregexp 如果第二个参数不传，会用undefined替代</span><br><span class="line"></span><br><span class="line">// 当replace 的第二个参数是func的时候，用法就改变了</span><br><span class="line"></span><br><span class="line">&apos;abcregabcexp&apos;.replace(/abc/,function()&#123;</span><br><span class="line">   console.log(arguments);</span><br><span class="line">&#125;) // 虽然有两项符合条件，但是依然只会匹配第一个，这也是正则惰性一种表现，想取出这种惰性，需要加全局修饰符</span><br><span class="line">/* =&gt; Arguments(3) [&quot;abc&quot;, 0, &quot;abcregexp&quot;, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span><br><span class="line">      0 : &quot;abc&quot;  // 匹配结果</span><br><span class="line">      1 : 0 // 匹配的开始索引</span><br><span class="line">      2 : &quot;abcregabcexp&quot; // 原字符串</span><br><span class="line">      callee : ƒ ()</span><br><span class="line">      length : 3 // 数组长度</span><br><span class="line">      ...</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"> &apos;abcregabcexp&apos;.replace(/abc/g,function()&#123;</span><br><span class="line">     console.log(arguments);</span><br><span class="line">  &#125;)</span><br><span class="line">  // 不要以为是返回一次结果，依然是一次匹配只能返回一次结果，但是 replace 方法，会主动的去循环查找，知道没有符合条件后结束匹配。</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>String.prototype.split(reg) 替换符合正则的字符串<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;abcaregaexp&apos;.split(/a/); // =&gt; [&apos;&apos;,&apos;bc&apos;,&apos;reg&apos;,&apos;exp&apos;] 如果切割的字符串出现在了开始或者最后，数组中会出现一项为空字符串</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>String.prototype.match(reg) 用来捕获字符串中符合正则的字符串到一个数组中。默认情况下只捕获第一个符合的结果到数组中(正则的惰性，下面我们会说到)，正则表达式有”全局捕获“的修饰符时(定义正则表达式的时候添加参数g)，会捕获所有结果到数组中<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;abcregabcexpabc&apos;.match(/abc/); // =&gt; [&apos;abc&apos;]</span><br><span class="line">&apos;abcregabcexpabc&apos;.match(/abc/g); // =&gt; [&apos;abc&apos;,&apos;abc&apos;,&apos;abc&apos;]</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>RegExp.prototype.test(reg) 用来测试字符串中是否含有子字符串<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/abc/.test(&apos;abcaregaexp&apos;); // =&gt; true 是否存在，存在：true  不存在: false</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>RegExp.prototype.exec(reg) 和match方法相似，也是从字符串中捕获满足条件的字符串到数组中，但是也有区别。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/abc/.exec(&apos;abcaregaexp&apos;); // =&gt; [[&quot;abc&quot;, index: 0, input: &quot;abcaregaexp&quot;, groups: undefined]</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>当执行reg.exec(str) 先去验证当前字符串是否匹配，如果不匹配返回结果是null，如果匹配，从字符串最左边开始向右边查找匹配内容，并且把匹配内容返回。<br>捕获的返回结果格式：</p><ul><li>数组格式，数组中的第一项当前本次大正则在字符串中匹配的结果</li><li>index 记录的本次捕获到结果起始索引</li><li>input 当前正则操作的原始字符串</li><li>如果当前正则中有分组，获取的数组中，从第二项开始都是每个小分组，本次匹配到的结果（通过exec可以把分组中的内容捕获到）</li><li>执行一次exec只能把符合条件的第一项捕获到，如果还有其他符合规则的，需要在此执行exec才能有可能会捕获到</li><li>正则捕获的懒惰型：执行一次exec捕获到第一个符合规则的内容，第一次执行exec，捕获到的依然是第一个匹配内容，后面匹配的内容不管执行多少次exec都无法捕获（解决正则捕获的懒惰型：在正则的末尾加修饰符g [全局匹配]）</li></ul></blockquote><h4 id="正则为什么会存在懒惰型呢？"><a href="#正则为什么会存在懒惰型呢？" class="headerlink" title="正则为什么会存在懒惰型呢？"></a>正则为什么会存在懒惰型呢？</h4><blockquote><p>正则本身有一个属性：lastIndex（下一次匹配的的起始位置）默认值是0， 默认不管指定多少遍exec方法，正则的lastIndex的值都不会改变（也就是为什么始终查找的都是第一个匹配内容）,并且程序不识别我们手动改变的值</p><p>为什么加上修饰符g就能解决懒惰型呢？<br>加了修饰符g之后，每次执行exec之后，浏览器会自动修改lastIndex的值，下一次从上一次结束的位置开始</p></blockquote><blockquote><p><strong>所以如果想一次匹配到所有结果，需要自己封装一个方法，目的是执行一次这个方法，可以捕获所有符合匹配的内容</strong></p></blockquote><hr><h3 id="元字符和修饰符"><a href="#元字符和修饰符" class="headerlink" title="元字符和修饰符"></a>元字符和修饰符</h3><p><strong>修饰符</strong></p><blockquote><p>g（global）：全局匹配（查找所有匹配而非在找到第一个匹配后停止）<br>i （ignoreCase）：忽略大小写匹配<br>m（multiline）：多行匹配<br>ES6 还推出了新的修饰符，在这里就不做介绍了，感兴趣的话自己去看吧</p></blockquote><p><strong>元字符</strong></p><blockquote><p>[量词元字符]</p><ul><li>+：让前面的元字符出现一到多次</li><li>？：出现零到一次</li><li>*：出现零到多次</li><li>{n}：出现n次</li><li>{n,}：出现n到多次</li><li>{n,m}：出现n到m次</li></ul><p>[特殊意义的元字符]</p><ul><li>\ ：转义字符（把一个普通字符转变成有特殊意义的字符，或者把一个有意义的字符转换为普通字符）</li><li>. ：除了\n（换行符）以外的任意字符</li><li>\d ： 匹配一个0-9之间的数字</li><li>\D ： 匹配一个任意非0-9之间的数字（大写字母和小写字母的组合正好是反向的）</li><li>\w ： 匹配一个0-9或者字母或者 _ 之间的字符</li><li>\W ： 非\w</li><li>\s ： 匹配一个任意空白字符串</li><li>\S ： 匹配一个非空白字符串</li><li>[\b] 匹配一个退格符</li><li>\b ： 匹配一个边界符</li><li>\B ： 匹配一个单词的非边界</li><li>\t ： 匹配一个制表符</li><li>\n ： 匹配一个换行符</li><li>\r ： 匹配一个回车符</li><li>\v ： 匹配一个重直制表符</li><li>x|y ：匹配x或者y中的一个</li><li>[a-z] ：匹配a-z之中的任意一个字符</li><li>[^a-z] ：匹配一个非a-z的字符</li><li>[xyz] ： 匹配x或者y或者z中的一个</li><li>[^xyz] ： 匹配除了xyz以外的任意字符</li><li>() ： 正则的小分组，匹配一个分组（小分组可以理解为一个大分组中的一个小分组）</li><li>^ ：以某一个元字符开始</li><li>$ ：以某一个元字符结束</li><li>?: ：只匹配不捕获（断言）</li><li>?= ：正向预查</li><li>?! ：负向预查</li></ul></blockquote><h3 id="元字符详解"><a href="#元字符详解" class="headerlink" title="元字符详解"></a>元字符详解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">\  ：有一些符号在正则中室友特殊含义的，我们在想使用他本身意思的时候需要进行转义，例如 /./g（这个时候.所匹配的是除了\n（换行符）以外的任意字符），而我们只是希望匹配‘.’，写法：/\./g ；</span><br><span class="line"></span><br><span class="line">() ：正则中的分组，也可以理解为一个大正则中的一个正则（包起来的部分是一个整体，在正则中我们可以使用小括号改变一些默认的优先级）</span><br><span class="line"></span><br><span class="line">[] ：在其中的任意一个，具有消磁作用，特殊意义的符号，在[]中，恢复正常含义</span><br><span class="line">  - 分组引用 ：\1,\2,……出现和第N个分组一模一样的内容</span><br><span class="line">  - 分组捕获 ： 分组不仅可以匹配，而且以后捕获的时候，不仅可以把大正则匹配的结果捕获到，里面每一个小分组匹配的结果也可以单独的捕获到。</span><br><span class="line"></span><br><span class="line">// 非断言的情况 /hello\s(world)/.exec(&apos;hello world hello today&apos;) =&gt;  [&quot;hello world&quot;, &quot;world&quot;, index: 0, input: &quot;hello world hello today&quot;, groups: undefined]</span><br><span class="line"></span><br><span class="line">?: ：断言， 正则表达式 /hello\s(?:world)/.exec(&apos;hello world hello today&apos;) // =&gt; [&quot;hello world&quot;, index: 0, input: &quot;hello world hello today&quot;, groups: undefined] 但是不给此分组分配组号，也不会出现在返回结果中，</span><br><span class="line"></span><br><span class="line">?= ：正则表达式 /hello\s(?=world)/.exec(&apos;hello world hello today&apos;) // =&gt; [&quot;hello &quot;, index: 0, input: &quot;hello world hello today&quot;, groups: undefined]</span><br><span class="line">     // 只会捕获 (?=world) 中world 之前符合匹配条件，同样不给此分组分配组号，也不会出现在返回结果中；</span><br><span class="line"></span><br><span class="line">?! ：正则表达式 /hello\s(?!world)/.exec(&apos;hello world hello today&apos;) // =&gt; [&quot;hello &quot;, index: 12, input: &quot;hello world hello today&quot;, groups: undefined]</span><br><span class="line">     // 只会捕获 (?=world) 中world 后面符合匹配条件，同样不给此分组分配组号，也不会出现在返回结果中；</span><br></pre></td></tr></table></figure><blockquote><p>事实上 正则能做的事情远远超出你的想想，越研究你会越喜欢正则的</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 23 2018 18:24:16 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;正则&quot;&gt;&lt;a href=&quot;#正则&quot; class=&quot;headerlink&quot; title=&quot;正则&quot;&gt;&lt;/a&gt;正则&lt;/h2&gt;&lt;blockquote
      
    
    </summary>
    
      <category term="正则" scheme="http://yoursite.com/categories/%E6%AD%A3%E5%88%99/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>MiddleWare</title>
    <link href="http://yoursite.com/2017/11/12/middleWare/"/>
    <id>http://yoursite.com/2017/11/12/middleWare/</id>
    <published>2017-11-11T16:00:00.000Z</published>
    <updated>2018-03-23T07:01:38.197Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 23 2018 18:24:16 GMT+0800 (中国标准时间) --><h3 id="React-中间件"><a href="#React-中间件" class="headerlink" title="React 中间件"></a>React 中间件</h3><blockquote><p>在Redux 中为我们提供了一个 applyMiddleware 的接口函数，来处理我们需要使用的中间件；</p></blockquote><p><strong>react 有那些中间件</strong></p><blockquote><p>redux-logger — 操作日志<br>redux-thunk — 将 dispatch 的控制权交给开发者，允许在 action 中返回一个函数，接收一个 dispatch 参数，并且可以异步调用它<br>redux-promise — 支持 dispatch 一个异步 Promise action 并且等待结果后 dispatch 一个 action<br>中间件函数签名 ({ getState, dispatch }) =&gt; next =&gt; action</p></blockquote><hr><h4 id="redux-logger"><a href="#redux-logger" class="headerlink" title="redux-logger"></a>redux-logger</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let logger = store =&gt; dispatch =&gt; action=&gt;&#123;</span><br><span class="line">  console.log(store.getState().number);</span><br><span class="line">  dispatch(action);</span><br><span class="line">  console.log(store.getState().number)</span><br><span class="line">&#125;;</span><br><span class="line">let applyMiddleWare = middleware =&gt; createStore =&gt; reducer =&gt;&#123;</span><br><span class="line">  let store = createStore(reducer);</span><br><span class="line">  let middle = middleware(store);</span><br><span class="line">  let dispatch = middle(store.dispatch);</span><br><span class="line">  return &#123; //将中间返回的dispatch方法覆盖掉原有store中的dispatch</span><br><span class="line">    ...store,</span><br><span class="line">    dispatch</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">export default applyMiddleWare(logger)(createStore)(reducer);</span><br></pre></td></tr></table></figure><h4 id="redux-thunk"><a href="#redux-thunk" class="headerlink" title="redux-thunk"></a>redux-thunk</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let reduxThunk = store =&gt; dispatch =&gt; action=&gt;&#123;</span><br><span class="line">  if(typeof action === &apos;function&apos;)&#123; //如果是函数将派发的权限传递给函数</span><br><span class="line">    return action(dispatch,store.getState);</span><br><span class="line">  &#125;</span><br><span class="line">  dispatch(action);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="redux-promise"><a href="#redux-promise" class="headerlink" title="redux-promise"></a>redux-promise</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let reduxPromise = store =&gt; dispatch =&gt; action=&gt;&#123;</span><br><span class="line">  if(action.then)&#123;</span><br><span class="line">    return action.then(dispatch); //只支持成功</span><br><span class="line">  &#125;</span><br><span class="line">  else if(action.payload&amp;&amp;action.payload.then)&#123;</span><br><span class="line">    // 如果payload是一个promise 会对成功和失败都进行捕获并且将成功或失败的数据放到payload中进行派发</span><br><span class="line">    return action.payload.then(function (data) &#123;</span><br><span class="line">      dispatch(&#123;...action,payload:data&#125;);</span><br><span class="line">    &#125;,function (data) &#123;</span><br><span class="line">      dispatch(&#123;...action,payload:data&#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  dispatch(action);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="实现-compose"><a href="#实现-compose" class="headerlink" title="实现 compose"></a>实现 compose</h4><blockquote><p>compose 也是 redux 提供的5个函数之一（<strong>createStore</strong>,<strong>combineReducers</strong>,<strong>applyMiddleware</strong>,bindActionCreators,compose）只不过我们最常用的就是加粗的3个函数；bindActionCreators,compose 是 redux 内部可以自主触发的函数，所以我们主动用到的机会比较少</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// compose 的主要职责就是将传入的参数（func）： compose(funcA, funcB, funcC) 转换成 compose(funcA(funcB(funcC())))，你可以理解为把这些独立的函数&apos;串联&apos;到一起后执行；</span><br><span class="line"></span><br><span class="line">function combineStr(str1,str2)&#123;</span><br><span class="line">  return str1+str2;</span><br><span class="line">&#125;</span><br><span class="line">function strLen(str)&#123;</span><br><span class="line">  return str.length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let compose = (...fns)=&gt;(...args)=&gt; &#123;</span><br><span class="line">  let last = fns.pop();</span><br><span class="line">  return fns.reduceRight(function (prev,next) &#123;</span><br><span class="line">      return next(prev);</span><br><span class="line">  &#125;,last(...args))</span><br><span class="line">&#125;; // 将上一个函数当做参数传给下一个函数；</span><br><span class="line"></span><br><span class="line">console.log(compose(strLen, combineStr)(&apos;hello&apos;, &apos; world&apos;));</span><br></pre></td></tr></table></figure><h4 id="实现-combineReducers"><a href="#实现-combineReducers" class="headerlink" title="实现 combineReducers"></a>实现 combineReducers</h4><blockquote><p>原理非常的简单，将创建的多个 reducer 合并成一个 reducer，之前的 reducer 都变成新对象属性存在</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let combineReducers = (reducers) =&gt; (newState = &#123;&#125;, action) =&gt; &#123;</span><br><span class="line">    for (let key in reducers) &#123;</span><br><span class="line">        newState[key] = reducers[key](newState[key], action)</span><br><span class="line">    &#125;</span><br><span class="line">    return newState;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>最终实现的结果：export default createStore(reducer,applyMiddleware(reduxThunk,reduxPromise));</p></blockquote><blockquote><p>基本上 redux 中的方法的思想已经明白了，redux 仅仅是 react 中的一部分，想更深入的了解 react 框架思想和原理，这是一个比较漫长的路，加油吧所有走在 react 的开发者们。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 23 2018 18:24:16 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;React-中间件&quot;&gt;&lt;a href=&quot;#React-中间件&quot; class=&quot;headerlink&quot; title=&quot;React 中间件&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="前端框架" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>Express</title>
    <link href="http://yoursite.com/2017/10/28/express/"/>
    <id>http://yoursite.com/2017/10/28/express/</id>
    <published>2017-10-27T16:00:00.000Z</published>
    <updated>2018-03-22T13:45:53.392Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 23 2018 18:24:16 GMT+0800 (中国标准时间) --><h3 id="什么是Express"><a href="#什么是Express" class="headerlink" title="什么是Express"></a>什么是Express</h3><blockquote><p><a href="http://www.expressjs.com.cn/4x/api.html" target="_blank" rel="noopener">Express</a> 是一个简洁、灵活的 node.js Web 应用开发框架,它提供一系列强大的特性，并且提供一些供客户端调用的api接口（支持中间件、支持路由处理等）,还有一个框架和它类似，叫做koa(有时间我也会写一篇);</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* express：express核心框架</span><br><span class="line">* body-parser：用来快速解析请求主体中内容的</span><br><span class="line">* express-session / cookie-parser：方便我们在express中操作session的</span><br><span class="line">*/</span><br><span class="line">$ npm install express body-parser express-session cookie-parser</span><br></pre></td></tr></table></figure><h4 id="创建服务，监听端口"><a href="#创建服务，监听端口" class="headerlink" title="创建服务，监听端口"></a>创建服务，监听端口</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于NODE内置模块，使用原生JS代码实现WEB服务</span></span><br><span class="line"><span class="keyword">let</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>),</span><br><span class="line">    fs = <span class="built_in">require</span>(<span class="string">'fs'</span>),</span><br><span class="line">    url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;<span class="attr">url</span>:reqURL, method, headers&#125;=req,</span><br><span class="line">        &#123;pathname, query&#125;= url.parse(reqURL, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (pathname === <span class="string">'/login'</span> &amp;&amp; method==<span class="string">'GET'</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pathname===<span class="string">'/register'</span> &amp;&amp; method==<span class="string">'POST'</span>)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">8888</span>, ()=&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`server is success~`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&lt;*------------*&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于express框架完成</span></span><br><span class="line"><span class="comment">// express就是把我们自己用原生写的封装好了，我们以后直接调取使用即可（方便开发，有点类似于JQ）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>),</span><br><span class="line">    app = express();</span><br><span class="line">app.listen(<span class="number">8888</span>, ()=&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`server is success~`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">`/login`</span>, (req, res)=&gt; &#123;</span><br><span class="line">  <span class="comment">//=&gt;等价于原生</span></span><br><span class="line">  <span class="comment">//req.url  请求的地址+问号传参</span></span><br><span class="line">  <span class="comment">//req.method 请求的方式(大写)</span></span><br><span class="line">  <span class="comment">//req.headers 请求头(小写)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//=&gt;EXPRESS新提供的</span></span><br><span class="line">  <span class="comment">//req.path 相当于我们原生中通过url.parse方法解析出来的pathname</span></span><br><span class="line">  <span class="comment">//req.query 相当于解析出来的query</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//=&gt;等价于原生</span></span><br><span class="line">  <span class="comment">//res.writeHead 重写响应头</span></span><br><span class="line">  <span class="comment">//res.write 响应主体</span></span><br><span class="line">  <span class="comment">//res.end 结束响应(响应主体) //=&gt;只能返回字符串或者Buffer格式数据</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//=&gt;EXPRESS独有的</span></span><br><span class="line">      <span class="comment">//res.sendFile('./index.html',&#123;root:__dirname&#125;); 读取指定的文件，并且把内容响应给客户端</span></span><br><span class="line">      <span class="comment">//res.json(&#123;"id":1,"name":"李雷"&#125;); 我们可以直接放JSON,EXPRESS帮我们把它转换为字符串返回给客户端（并且设置好了响应头信息）</span></span><br><span class="line">      <span class="comment">//res.send() 综合体</span></span><br><span class="line">      <span class="comment">//res.statusCode = 200; 设置状态码</span></span><br><span class="line">      <span class="comment">//res.redirect() 重定向(对应状态码中的302/301)</span></span><br><span class="line">      <span class="comment">//res.sendStatus(404); 返回状态码并且附带一些状态码的描述信息</span></span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">`/register`</span>, (req, res)=&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h3 id="Express中间件"><a href="#Express中间件" class="headerlink" title="Express中间件"></a>Express中间件</h3><blockquote><p>使用中间件的两大作用：</p><ul><li>1、想要提取部分公共代码</li><li>2、想要在主体API逻辑处理前，做一些特殊处理（把传递的参数做特殊的处理）</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>),</span><br><span class="line">    app = express();</span><br><span class="line">app.listen(<span class="number">8888</span>, ()=&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`server is success~`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt;所有的客户端请求都会先执行这个中间件(然后执行NEXT后在进入下一个处理程序)</span></span><br><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//next:执行下一个处理(当前这个中间件根据情况，如果需要走到下一个操作，必须执行NEXT，如果不需要，直接响应内容即可)</span></span><br><span class="line">    <span class="keyword">if</span> (req.query.name) &#123;</span><br><span class="line">        req.userName = req.query.name;<span class="comment">//=&gt;把获取的内容写在了userName自定义属性上</span></span><br><span class="line">        next();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.send(<span class="string">`name必须传递`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//=&gt;只有请求的地址中包含`/user`的才会进入这个中间件</span></span><br><span class="line">app.use(<span class="string">`/user`</span>, (req, res, next)=&gt; &#123;</span><br><span class="line">    req.userName += <span class="string">'@'</span>;</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">`/user`</span>, (req, res)=&gt; &#123;</span><br><span class="line">    res.send(<span class="string">`My name is <span class="subst">$&#123;req.userName&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">`/article`</span>, (req, res)=&gt; &#123;</span><br><span class="line">    res.send(<span class="string">`Article author is <span class="subst">$&#123;req.userName&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>###Express中的路由router</p><blockquote><p>当请求变得越来越多的时候，我们为了方便后期的管理和维护，我们会把相同功能体系的接口进行归类；在实现的时候，也会分类实现（分组管理）；<br>例如：<br>/user/signin<br>/user/signup</p><p>/product/query<br>/product/search</p><p>/log/info<br>GET获取<br>POST请求设置<br>同一个地址，因为请求方式不一样，实现不一样的功能<br>…<br>对于上面的操作我们可以基于Express中的路由来完成</p></blockquote><p>1、我们创建一个routers文件夹，在这个文件夹中存储所有功能模块的接口信息（分类存储）</p><blockquote><p>格式 ： routers</p><pre><code>- user.js- product.js- login.js</code></pre></blockquote><p>2、在每一个路由模块中完成相关API接口的编写（举例：user模块）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let express = require(&apos;express&apos;),</span><br><span class="line">    router = express.Router(); //=&gt;router和app其实差不多</span><br><span class="line">router.use((req, res, next)=&gt; &#123;</span><br><span class="line">    console.log(`ok`);</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line">router.post(`/signin`, (req, res)=&gt; &#123;</span><br><span class="line">    res.send(&apos;login success&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">router.post(`/signup`, (req, res)=&gt; &#123;</span><br><span class="line">    res.send(&apos;register success&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">module.exports = router; //=&gt;把创建的路由导出,方便后续调取使用</span><br></pre></td></tr></table></figure><p>3、在server中需要调取使用<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let express = require(&apos;express&apos;),</span><br><span class="line">    app = express();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">app.use(`/user`, require(&apos;./routers/user&apos;));</span><br></pre></td></tr></table></figure><p></p><h3 id="Express-中获取客户端传递的信息"><a href="#Express-中获取客户端传递的信息" class="headerlink" title="Express 中获取客户端传递的信息"></a>Express 中获取客户端传递的信息</h3><blockquote><p>客户端把信息传递给服务器：</p><ul><li>1、问号传参（GET请求）</li><li>2、设置请求主体（POST请求）</li><li>3、设置请求头（cookie等信息传送）<br>…</li></ul></blockquote><p><strong>问号传参 &amp; 请求头</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">`/query`</span>, (req, res)=&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.headers);<span class="comment">//=&gt; 通过 req 的 header 可以直接的获取请求头信息(想获取其中的某一个:req.headers.host...)</span></span><br><span class="line"></span><br><span class="line">    res.send(req.query);<span class="comment">//=&gt;通过 req 中的 query 就可以获取问号传递的参数值(并且存储的方式是 KEY : VALUE)</span></span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>请求主体</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=&gt;基于传统的内置模块自己实现</span></span><br><span class="line">app.use(<span class="string">`/reg`</span>, (req, res, next)=&gt; &#123;</span><br><span class="line">    <span class="comment">//=&gt;POST请求获取请求主体内容,需要基于事件完成</span></span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">``</span>;</span><br><span class="line">    req.on(<span class="string">'data'</span>, chunk=&gt; &#123;</span><br><span class="line">        <span class="comment">//=&gt;正在接收请求主体中的内容(一般内容偏多)</span></span><br><span class="line">        str += chunk;</span><br><span class="line">    &#125;);</span><br><span class="line">    req.on(<span class="string">'end'</span>, ()=&gt; &#123;</span><br><span class="line">        <span class="comment">//=&gt;接收结束,此时STR存储的就是传递进来的信息</span></span><br><span class="line">        <span class="comment">//=&gt;客户端传递给服务器的信息一般都是字符串格式的(JSON字符串或者普通的FORMAT-DATA字符串[xxx=xxx&amp;xxx=xxx])</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> data = <span class="built_in">require</span>(<span class="string">'querystring'</span>).parse(str);<span class="comment">//=&gt;这个内置模块就是把FORMAT-DATA变为对象键值对的方式存储</span></span><br><span class="line">        req.body = data;<span class="comment">//=&gt;把解析后的数据放到REQ的自定义属性上,在其它的方法中可以获取使用</span></span><br><span class="line">        next();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">app.post(<span class="string">`/reg`</span>, (req, res)=&gt; &#123;</span><br><span class="line">    res.send(req.body);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>但是这种方式太麻烦了，我们可以使用第三方插件搞定刚才处理的事情：<code>body-parser</code></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</span><br><span class="line">app.use(bodyParser.urlencoded(&#123;<span class="attr">extended</span>: <span class="literal">false</span>&#125;));</span><br><span class="line">app.use(bodyParser.json());</span><br><span class="line">app.use(bodyParser.raw());</span><br><span class="line">app.use(bodyParser.text());</span><br><span class="line">app.post(<span class="string">`/reg`</span>, (req, res)=&gt; &#123;</span><br><span class="line">    res.send(req.body);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 23 2018 18:24:16 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;什么是Express&quot;&gt;&lt;a href=&quot;#什么是Express&quot; class=&quot;headerlink&quot; title=&quot;什么是Express
      
    
    </summary>
    
      <category term="node" scheme="http://yoursite.com/categories/node/"/>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>Node 基本语法</title>
    <link href="http://yoursite.com/2017/10/14/node/"/>
    <id>http://yoursite.com/2017/10/14/node/</id>
    <published>2017-10-13T16:00:00.000Z</published>
    <updated>2018-03-22T11:30:48.194Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 23 2018 18:24:16 GMT+0800 (中国标准时间) --><h2 id="Node-的特点"><a href="#Node-的特点" class="headerlink" title="Node 的特点"></a>Node 的特点</h2><blockquote><p>NODE只是一个工具（或者环境），我们可以把NODE安装在服务器上，NODE提供的环境可以运行JS代码，这样我们就可以在服务器端使用JavaScript编写一些处理服务器相关操作的程序，也可以理解为JS变为了后台编程语言。</p><ul><li>1、NODE是基于V8引擎来渲染JS的（V8是谷歌的引擎）<ul><li>渲染JS的速度会很快</li><li>我们在使用JS开发后台程序的时候，不需要考虑浏览器兼容了，使用JS的最新标准即可（ECMAScript）</li></ul></li><li>2、单线程、无阻塞I/O操作、事件驱动（event-driven）</li></ul></blockquote><blockquote><p>首先要安装node，下载地址<a href="http://nodejs.cn/" target="_blank" rel="noopener">Node.js</a> 下载最新的即可，因为node也在不断更新语法和处理方式；</p></blockquote><blockquote><p>Node和客户端的主要区别在于全局对象</p><ul><li>浏览器全局对象: window</li><li>NODE全局对象: global</li></ul></blockquote><h3 id="NODE天生就是基于模块化开发的"><a href="#NODE天生就是基于模块化开发的" class="headerlink" title="NODE天生就是基于模块化开发的"></a>NODE天生就是基于模块化开发的</h3><blockquote><p>NODE中模块这个概念非常强（强到我们每创建一个新的JS，都相当于创建了一个新的模块）</p><p>NODE是基于commonjs规范来完成模块设计的（如何创建模块、如何调取模块、如何导出模块 这些就是规范里提及的内容）</p><ul><li>CMD模块开发思想：seajs （按需导入：用到的时候在导入进来使用）</li><li>AMD模块开发思想：requirejs （提前导入所有需要的依赖）</li></ul><p>1、自定义模块：自己创建的<br>2、第三方模块：别人写好的我来用<br>3、内置模块：天生自带的</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//=&gt;NODE为了实现模块之间的独立，会自动包一层闭包，而且给每一个模块传递五个值</span><br><span class="line">(function (exports, require, module, __filename, __dirname) &#123;</span><br><span class="line">   /*</span><br><span class="line">    * module模块:NODE模块管理的对象</span><br><span class="line">    * exports叫做导出，等同于module.exports，用来把模块进行导出的</span><br><span class="line">    * require是导入的方法，通过这个方法可以把一些模块导入到当前模块中使用</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">    //=&gt;内部代码中有一个类似于这样的操作，可以把一些想要供别人使用的属性和方法暴露出来</span><br><span class="line">    module.exports=exports=this=&#123;</span><br><span class="line">        fn:()=&gt;&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p><strong>module.exports</strong></p><blockquote><p>把当前模块中的某些属性和方法导出</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">module.exports.fn=fn;</span><br><span class="line">module.exports.a=12;</span><br><span class="line">//=&gt;上面写起来麻烦（上面属于向原有内置对象的堆内存中增加属性和方法，下面属于导出一个新的堆内存）</span><br><span class="line">module.exports=&#123;</span><br><span class="line">  fn:fn,</span><br><span class="line">  a:12</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">//=&gt;直接使用exports也可以，但是这种模式只能使用原有内置内容，自己开辟新内存不行</span><br><span class="line">exports.fn=fn;</span><br><span class="line">exports=&#123;&#125;;//=&gt;这种方式不行</span><br></pre></td></tr></table></figure><p><strong>require</strong></p><blockquote><p>导入某个模块，目的是使用其它模块中的属性和方法。在导入自定义模块和第三方模块语法上是有一些区别需要注意的</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">require(&apos;./xxx&apos;) ： 指定目录的情况下，都是为了要导入自己定义的模块</span><br><span class="line"></span><br><span class="line">require(&apos;xxx&apos;)：不指定目录情况下，可能是导入第三方安装的模块，也可能是导入内置模块。</span><br><span class="line">// 查找规则: 首先到node_modules文件夹中找第三方模块，有的话，导入的就是第三方模块，没有的话，看内置模块中有没有，内置中这个模块，导入的就是内置模块，内置中没有就会报错。</span><br></pre></td></tr></table></figure><hr><h4 id="Path-模块"><a href="#Path-模块" class="headerlink" title="Path 模块"></a>Path 模块</h4><blockquote><p>用于处理文件路径</p><ul><li>path.normalize(p) 路径解析，得到规范路径</li><li>path.join 路径合并</li><li>path.resolve([from …], to) 获取绝对路径</li><li>path.relative(from, to) 获取相对路径</li><li>path.isAbsolute(path) 判定是否为绝对路径</li><li>path.dirname(p) 返回路径中文件夹的名称</li><li>path.basename(p, [ext]) 返回路径中的最后一部分</li><li>path.extname(p) 返回路径中文件的扩展名, 在从最后一部分中的最后一个’.’到字符串的末尾。 如果在路径的最后一部分没有’.’，或者第一个字符是’.’，就返回一个 空字符串</li><li>path.parse(pathString) 解析路径 (返回一个对象：{ root : “/“, dir : “/home/user/dir”, base : “file.txt”, ext : “.txt”, name : “file” })</li></ul></blockquote><hr><h4 id="Http-模块"><a href="#Http-模块" class="headerlink" title="Http 模块"></a>Http 模块</h4><blockquote><p>用于和服务器交互</p><ul><li>http.createServer(function(req,res){}); 创建服务</li><li>http.get(‘path’,callback); 发送get请求。</li><li>http.request(options,callback); 发送请求。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var http=require(&apos;http&apos;);</span><br><span class="line">var querystring=require(&apos;querystring&apos;);</span><br><span class="line"></span><br><span class="line">//启动服务</span><br><span class="line">http.createServer((req,res)=&gt;&#123;</span><br><span class="line">    console.log(&quot;request already come&quot;);</span><br><span class="line">    var post = &quot;&quot;;</span><br><span class="line">    req.on(&apos;data&apos;,(chunk)=&gt;&#123;</span><br><span class="line">        post += chunk;</span><br><span class="line">    &#125;);</span><br><span class="line">    req.on(&apos;end&apos;,()=&gt;&#123;</span><br><span class="line">        //querystring.parse  将字符串转换为json的格式</span><br><span class="line">        post =  querystring.parse(post);</span><br><span class="line">        console.log(&apos;complete complished&apos;);</span><br><span class="line">        //返回请求者一个信息</span><br><span class="line">        res.write(post.name);</span><br><span class="line">        res.end();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).listen(3000);</span><br></pre></td></tr></table></figure><h4 id="FS-模块"><a href="#FS-模块" class="headerlink" title="FS 模块"></a>FS 模块</h4><blockquote><p>主要作用就是进行I/O操作（对服务器端的文件进行增删改查等操作）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 导入fs模块</span><br><span class="line">let fs = require(&apos;fs&apos;);</span><br><span class="line">//=&gt;接下来就可以使用它里面提供的方法了</span><br></pre></td></tr></table></figure><blockquote><p>我们发现FS中提供的方法一般都是两套：同步操作和异步操作各一套</p><p>例如：<br>fs.readFile 异步读取文件中的内容<br>fs.readFileSync 同步读取文件中的内容</p><p>同步和异步的区别在于：同步读取文件，文件内容没有读取完成，后面的任务无法处理，而异步不是，数据没有读取完成，下面的任务先去执行（我们也把这个特点叫做 <code>“无阻塞的I/O操作”</code>）</p></blockquote><hr><p><strong>readFile &amp;&amp; readFileSync</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//=&gt;同步读取</span><br><span class="line">let con = fs.readFileSync(&apos;./index.html&apos;);</span><br><span class="line">console.log(con); //=&gt;BUFFER</span><br><span class="line"></span><br><span class="line">con = fs.readFileSync(&apos;./index.html&apos;, &apos;utf8&apos;);</span><br><span class="line">console.log(con); //=&gt;STRING 设置UTF8后,会自动把BUFFER格式的数据转换为字符串格式的数据</span><br><span class="line"></span><br><span class="line">console.log(&apos;ok&apos;);//=&gt;最后执行:同步读取,需要等内容读取完成才会执行下面的任务</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//=&gt;异步读取</span><br><span class="line">console.time(&apos;readFile&apos;);</span><br><span class="line">let con = fs.readFile(&apos;./index2.html&apos;, &apos;utf8&apos;, (err, result)=&gt; &#123;</span><br><span class="line">    //=&gt;回调函数就是NODE的事件驱动机制:当文件读取成功或者失败的时候,会触发回调函数执行(并且传递两个实参值)</span><br><span class="line">    //=&gt;err(error):当读取出错,信息保存在err中,如果没有出错,err为null</span><br><span class="line">    //=&gt;result:当读取成功,信息保存在result中(第二个参数不设置utf8,获取的结果依然是Buffer格式的数据)</span><br><span class="line">    console.timeEnd(&apos;readFile&apos;);</span><br><span class="line">    if (err) &#123;</span><br><span class="line">        //=&gt;出错了:真实项目中我们会把错误信息记录在错误日志中</span><br><span class="line">        console.log(err);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(result);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;ok&apos;);//=&gt;OK是先输出的</span><br></pre></td></tr></table></figure><hr><p><strong>fs.writeFile &amp;&amp; fs.writeFileSync</strong></p><blockquote><p>同步或者异步向某个文件中写入内容</p><blockquote><p>特点：</p><ul><li>1、如果当前文件没有，我们会自动创建文件，然后再写入内容（但是并不是万能的：如果指定的地址中不存在这个文件夹，NODE无法自动帮你创建文件夹，需要我们自己手动检测并创建）</li><li>2、文件写入属于覆盖式写入（新写入的内容会覆盖原有的内容）</li><li>3、写入的内容需要是字符串或者BUFFER格式的数据</li></ul></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 同步写入</span><br><span class="line">let res = fs.writeFileSync(&apos;./TEMP.txt&apos;, &apos;HELLO&apos;, &apos;utf8&apos;);</span><br><span class="line">console.log(res); //=&gt;undefined 写入的方法没有返回值</span><br><span class="line"></span><br><span class="line">// 异步写入</span><br><span class="line">fs.writeFile(&apos;./TEMP.txt&apos;, &apos;珠峰培训&apos;, &apos;utf8&apos;, (error)=&gt; &#123;</span><br><span class="line">    //=&gt;这里面只有ERROR一个参数:代表写入成功还是失败</span><br><span class="line">    console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><p><strong>appendFile &amp;&amp; appendFileSync</strong></p><blockquote><p>用法和writeFile类似,不一样的地方在于：appendFile写入属于追加式写入（原有内容不改变），而writeFile输入覆盖式写入（覆盖原有的内容）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fs.appendFileSync(&apos;./TEMP.txt&apos;, &apos;HELLO&apos;, &apos;utf8&apos;);</span><br><span class="line"></span><br><span class="line">fs.appendFile(&apos;./TEMP.txt&apos;, &apos;HELLO&apos;, &apos;utf8&apos;, error=&gt; &#123;</span><br><span class="line">    if (error) &#123;</span><br><span class="line">        console.log(error);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&apos;success&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><p><strong>readdir &amp;&amp; readdirSync</strong></p><blockquote><p>同步或者异步读取某一个目录下所有的文件和文件夹信息</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let dirList = fs.readdirSync(&apos;./&apos;);</span><br><span class="line">console.log(dirList);</span><br><span class="line"></span><br><span class="line">fs.readdir(&apos;./&apos;, (error, result)=&gt; &#123;</span><br><span class="line">    if (error) &#123;</span><br><span class="line">        console.log(error);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(result); //=&gt;获取一个数组集合,集合中包含当前目录中(./)所有的文件及文件夹信息</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><p><strong>mkdir &amp;&amp; mkdirSync</strong></p><blockquote><p>创建文件夹</p><ul><li>特点:<ul><li>1、可以创建文件夹，如果当前文件夹已经存在，返回的是错误的信息，不会重新的创建</li><li>2、不能一次创建多级结构目录，例如：./TEMP/DAY1/CSS 这样的多级目录无法一次创建，需要先创建TEMP，然后再创建DAY1…</li></ul></li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.mkdir(&apos;./TEMP&apos;, (error)=&gt; &#123;</span><br><span class="line">    if (error) &#123;</span><br><span class="line">        console.log(&apos;error&apos;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&apos;success&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>自己实现一个方法，可以一次创建多级结构目录</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 创建文件夹</span><br><span class="line"> *   path: &apos;./TEMP&apos; 、&apos;./TEMP/DAY1&apos; 、&apos;./TEMP/DAY1/CSS&apos; ...</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">let makeDir = function (path) &#123;</span><br><span class="line">    let pathAry = path.split(&apos;/&apos;),</span><br><span class="line">        [root,...arg]=pathAry;</span><br><span class="line">    root = root + &apos;/&apos;;</span><br><span class="line"></span><br><span class="line">    let make = n=&gt; &#123;</span><br><span class="line">        if (n &gt;= arg.length) return;</span><br><span class="line">        let curPath = arg[n];</span><br><span class="line">        fs.mkdir(root + curPath, error=&gt; &#123;</span><br><span class="line">            root += curPath + &apos;/&apos;;</span><br><span class="line">            make(n + 1);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    make(0);</span><br><span class="line">&#125;;</span><br><span class="line">makeDir(&apos;./TEMP/DAY1/CSS/LESS&apos;);</span><br></pre></td></tr></table></figure><blockquote><p>除了上述方法以外，还有很多其它的方法，例如：copyFile、rmdir… ，大家可以观看NODE中文文档（<a href="http://nodejs.cn/api/）" target="_blank" rel="noopener">http://nodejs.cn/api/）</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 23 2018 18:24:16 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;Node-的特点&quot;&gt;&lt;a href=&quot;#Node-的特点&quot; class=&quot;headerlink&quot; title=&quot;Node 的特点&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="node" scheme="http://yoursite.com/categories/node/"/>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>react 高阶组件</title>
    <link href="http://yoursite.com/2017/09/17/reduxApp/"/>
    <id>http://yoursite.com/2017/09/17/reduxApp/</id>
    <published>2017-09-16T16:00:00.000Z</published>
    <updated>2018-03-22T11:04:35.947Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 23 2018 18:24:16 GMT+0800 (中国标准时间) --><h3 id="为什么要使用高阶组件"><a href="#为什么要使用高阶组件" class="headerlink" title="为什么要使用高阶组件"></a>为什么要使用高阶组件</h3><blockquote><p>我们先看一个demo</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">export default class Username extends React.Component &#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state = &#123;val:&apos;&apos;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount()&#123;</span><br><span class="line">    let username = localStorage.getItem(&apos;username&apos;)||&apos;&apos;;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      val:username</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; value=&#123;this.state.val&#125; onChange=&#123;()=&gt;&#123;&#125;&#125;/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在本地缓存中获取用户的姓名，并且将数据作为输入框的默认值，很简单的一个逻辑，不过中情况可能我们还会在密码输入框中用到； 也就是说这一段获取本地缓存数据的操作可能是一段公共逻辑，当然我们可以在每一个组件中写这样的一段逻辑，但是这就失去了组件复用性，这个时候我们就可以使用高阶组件来完成这样的操作（有没有瞬间想到node里面的中间件用法）；</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 我们来实现一下这个功能</span><br><span class="line"></span><br><span class="line">// local.js</span><br><span class="line">import React from &apos;react&apos;;</span><br><span class="line">let local = (key) =&gt; (Component) =&gt; &#123;</span><br><span class="line">   return class extends React.Component &#123;</span><br><span class="line">      constructor()&#123;</span><br><span class="line">        super();</span><br><span class="line">        this.state = &#123; val : &apos;&apos;&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      componentDidMount()&#123;</span><br><span class="line">        let temp = localStorage.getItem(key) || &apos;&apos;;</span><br><span class="line">        this.getState(&#123;</span><br><span class="line">          val : temp</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      render()&#123;</span><br><span class="line">        return &lt;Component &#123;...this.state&#125; /&gt;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default local;</span><br><span class="line"></span><br><span class="line">// index.js</span><br><span class="line">import Local from &apos;./local&apos;;</span><br><span class="line"></span><br><span class="line">class Username extends React.Component &#123;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; value=&#123;this.props.val&#125; onChange=&#123;()=&gt;&#123;&#125;&#125;/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Local(&apos;username&apos;)(Username);</span><br></pre></td></tr></table></figure><blockquote><p>将公共的逻辑拿到外层组件中处理，将处理完成的数据在传入到原本组件中，所以高阶组件也就是一个React组件接收一个组件，然后返回另外一个组件</p></blockquote><h3 id="context的用法"><a href="#context的用法" class="headerlink" title="context的用法"></a>context的用法</h3><blockquote><p>react 是单向数据流， 我们想传递数据需要一层层向下传递，数据传递变得非常的麻烦，我们可以用context实现数据的交互</p><ul><li>父级组件 childContextTypes getChildContext函数</li><li>子级组件 contextTypes</li></ul></blockquote><h4 id="跨组建数据交互"><a href="#跨组建数据交互" class="headerlink" title="跨组建数据交互"></a>跨组建数据交互</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">// 组件顺序 App -&gt; Header -&gt; Title</span><br><span class="line"></span><br><span class="line">// App.js</span><br><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import PropTypes from &apos;prop-types&apos;</span><br><span class="line">import Header from &quot;./Header&quot;;</span><br><span class="line"></span><br><span class="line">export default class App extends React.Component &#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state = &#123;color:&apos;red&apos;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  static childContextTypes = &#123;</span><br><span class="line">    //定义子组件上下文的类型</span><br><span class="line">    color:PropTypes.string,</span><br><span class="line">    setColor:PropTypes.func</span><br><span class="line">  &#125;;</span><br><span class="line">  setColor = (color) =&gt;&#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      color</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">  getChildContext()&#123;</span><br><span class="line">    // 定义子组件上下文的数据</span><br><span class="line">    return &#123;</span><br><span class="line">      color:this.state.color,</span><br><span class="line">      setColor:this.setColor</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Header/&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Header.js</span><br><span class="line">export default class Header extends React.Component &#123;</span><br><span class="line">  static contextTypes = &#123;</span><br><span class="line">     setColor:PropTypes.func</span><br><span class="line">  &#125;;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;()=&gt;&#123;</span><br><span class="line">        this.context.setColor(&apos;green&apos;);</span><br><span class="line">      &#125;&#125;&gt;变绿&lt;/button&gt;</span><br><span class="line">      &lt;Title/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Title.js</span><br><span class="line">export default class Title extends React.Component &#123;</span><br><span class="line">  static contextTypes = &#123;</span><br><span class="line">    color:PropTypes.string</span><br><span class="line">  &#125;;</span><br><span class="line">  render()&#123; // 通过context获取父组件定义的数据</span><br><span class="line">    return &lt;div style=&#123;&#123;color:this.context.color&#125;&#125;&gt;Title&lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="实现-react-redux-库"><a href="#实现-react-redux-库" class="headerlink" title="实现 react-redux 库"></a>实现 react-redux 库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import PropTypes from &apos;prop-types&apos;;</span><br><span class="line"></span><br><span class="line">class Provider extends React.Component&#123;</span><br><span class="line">  static childContextTypes = &#123;</span><br><span class="line">    store:PropTypes.object</span><br><span class="line">  &#125;;</span><br><span class="line">  getChildContext()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      store:this.props.store</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return this.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let connect = (mapStateToProps,mapDispatchToProps) =&gt; (Component) =&gt;&#123;</span><br><span class="line">  //如果第二个参数传递一个actions(一个对象)；做如下处理（与bindActionCreators处理方式相同）</span><br><span class="line">  if(&#123;&#125;.toString.call(mapDispatchToProps).slice(8,-1)===&apos;Object&apos;)&#123;</span><br><span class="line">    let actions=mapDispatchToProps;</span><br><span class="line">    mapDispatchToProps=(dispatch)=&gt;&#123;</span><br><span class="line">      let obj=&#123;&#125;;</span><br><span class="line">      for (let key in actions) &#123;</span><br><span class="line">        if (actions.hasOwnProperty(key)) &#123;</span><br><span class="line">          obj[key]=(...args)=&gt;&#123;</span><br><span class="line">            dispatch(actions[key](...args));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return obj;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return class Proxy extends React.Component&#123;</span><br><span class="line">    static contextTypes = &#123;</span><br><span class="line">      store:PropTypes.object</span><br><span class="line">    &#125;;</span><br><span class="line">    constructor(props,context)&#123;</span><br><span class="line">      super();</span><br><span class="line">      this.state = mapStateToProps(context.store.getState());</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">      this.unsubscribe = this.context.store.subscribe(()=&gt;&#123;</span><br><span class="line">        this.setState(mapStateToProps(this.context.store.getState()))</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillUnmount()&#123;</span><br><span class="line">      this.unsubscribe();</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">      return &lt;Component &#123;...this.state&#125; &#123;...mapDispatchToProps(this.context.store.dispatch)&#125;/&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">export &#123;Provider,connect&#125;</span><br></pre></td></tr></table></figure><h4 id="bindActionCreators-方法"><a href="#bindActionCreators-方法" class="headerlink" title="bindActionCreators 方法"></a>bindActionCreators 方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let bindActionCreators = (actionCreators,dispatch) =&gt; &#123;</span><br><span class="line">  let obj = &#123;&#125;</span><br><span class="line">  for(let key in actionCreators)&#123;</span><br><span class="line">    obj[key] = (...args)=&gt;&#123;</span><br><span class="line">      dispatch(actionCreators[key](...args))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return obj</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default connect(state=&gt;(&#123;...state&#125;),dispatch=&gt;bindActionCreators(actionCreators,dispatch))(Counter)</span><br></pre></td></tr></table></figure><p><strong>顺手献上源码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function bindActionCreator(actionCreator, dispatch) &#123;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    return dispatch(actionCreator.apply(undefined, arguments));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default function bindActionCreators(actionCreators, dispatch) &#123;</span><br><span class="line">  if (typeof actionCreators === &apos;function&apos;) &#123;</span><br><span class="line">    return bindActionCreator(actionCreators, dispatch);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (typeof actionCreators !== &apos;object&apos; || actionCreators === null) &#123;</span><br><span class="line">    throw new Error(&apos;&apos;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var keys = Object.keys(actionCreators);</span><br><span class="line">  var boundActionCreators = &#123;&#125;;</span><br><span class="line">  for (var i = 0; i &lt; keys.length; i++) &#123;</span><br><span class="line">    var key = keys[i];</span><br><span class="line">    var actionCreator = actionCreators[key];</span><br><span class="line">    if (typeof actionCreator === &apos;function&apos;) &#123;</span><br><span class="line">      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return boundActionCreators;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 23 2018 18:24:16 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;为什么要使用高阶组件&quot;&gt;&lt;a href=&quot;#为什么要使用高阶组件&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用高阶组件
      
    
    </summary>
    
      <category term="前端框架" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>redux</title>
    <link href="http://yoursite.com/2017/09/09/redux/"/>
    <id>http://yoursite.com/2017/09/09/redux/</id>
    <published>2017-09-08T16:00:00.000Z</published>
    <updated>2018-03-22T11:04:35.940Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 23 2018 18:24:16 GMT+0800 (中国标准时间) --><h2 id="什么是Redux"><a href="#什么是Redux" class="headerlink" title="什么是Redux"></a>什么是Redux</h2><p>我们一直通过属性来进行组件中的数据传递,这种模式是非常脆弱的。在日常的开发中经常会遇到非父子组件传递的场景。原来的方式是找到共同的父级进行数据交互，这时通信就变得比较麻烦 我们先通过一个简单的例子实现一下redux的工作模式:</p><h3 id="一、统一数据管理"><a href="#一、统一数据管理" class="headerlink" title="一、统一数据管理"></a>一、统一数据管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">let state = &#123;</span><br><span class="line">  title:&#123;color:&apos;red&apos;,text:&apos;标题&apos;&#125;,</span><br><span class="line">  content:&#123;color:&apos;green&apos;,text:&apos;内容&apos;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function renderContent() &#123;</span><br><span class="line">  let content = document.querySelector(&apos;.content&apos;);</span><br><span class="line">  content.innerHTML = state.content.text;</span><br><span class="line">  content.style.color = state.content.color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function renderTitle() &#123;</span><br><span class="line">  let title = document.querySelector(&apos;.title&apos;);</span><br><span class="line">  title.innerHTML = state.title.text;</span><br><span class="line">  title.style.color = state.title.color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function renderApp() &#123;</span><br><span class="line">  renderContent();</span><br><span class="line">  renderTitle()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">renderApp();</span><br></pre></td></tr></table></figure><blockquote><p>这里我们可以将renderContent,renderTitle看成两个组件将所需的数据提取到state中统一进行管理。当渲染后我们希望更改状态，封装更改状态的方法(dispatch)</p></blockquote><h3 id="二、实现dispatch"><a href="#二、实现dispatch" class="headerlink" title="二、实现dispatch"></a>二、实现dispatch</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let CHANGE_TITLE_TEXT = &apos;CHANGE_TITLE_TEXT&apos;;</span><br><span class="line">function dispatch(action) &#123;</span><br><span class="line">  switch (action.type)&#123;</span><br><span class="line">    case CHANGE_TITLE_TEXT:</span><br><span class="line">      state = &#123;...state,title:&#123;...state.title,text:action.text&#125;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">  dispatch(&#123;type:CHANGE_TITLE_TEXT,text:&apos;hello&apos;&#125;);</span><br><span class="line">  renderApp();</span><br><span class="line">&#125;,1000);</span><br></pre></td></tr></table></figure><blockquote><p>不要直接更改状态而是使用dispatch方法进行状态的更改,派发一个带有type的属性来进行状态的更改，仅仅是这样依然无法阻止用户更改状态。</p></blockquote><h3 id="三、createStore的实现"><a href="#三、createStore的实现" class="headerlink" title="三、createStore的实现"></a>三、createStore的实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">let CHANGE_TITLE_TEXT = &apos;CHANGE_TITLE_TEXT&apos;;</span><br><span class="line"></span><br><span class="line">function createStore() &#123;</span><br><span class="line">  let state = &#123;</span><br><span class="line">    title:&#123;color:&apos;red&apos;,text:&apos;标题&apos;&#125;,</span><br><span class="line">    content:&#123;color:&apos;green&apos;,text:&apos;内容&apos;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  let getState = () =&gt; JSON.parse(JSON.stringify(state));</span><br><span class="line">  // 创造一份和状态同样的对象给外界来用</span><br><span class="line">  function dispatch(action) &#123;</span><br><span class="line">    switch (action.type)&#123;</span><br><span class="line">      case CHANGE_TITLE_TEXT:</span><br><span class="line">        state = &#123;...state,title:&#123;...state.title,text:action.text&#125;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return &#123;</span><br><span class="line">    dispatch,</span><br><span class="line">    getState</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let store = createStore(); // 拿到createStore中返回的对象</span><br><span class="line"></span><br><span class="line">function renderContent() &#123;</span><br><span class="line">  let content = document.querySelector(&apos;.content&apos;);</span><br><span class="line">  content.innerHTML = store.getState().content.text;</span><br><span class="line">  content.style.color = store.getState().content.color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function renderTitle() &#123;</span><br><span class="line">  let title = document.querySelector(&apos;.title&apos;);</span><br><span class="line">  title.innerHTML = store.getState().title.text;</span><br><span class="line">  title.style.color = store.getState().title.color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function renderApp() &#123;</span><br><span class="line">  renderContent();</span><br><span class="line">  renderTitle()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">renderApp();</span><br><span class="line"></span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">  store.dispatch(&#123;type:CHANGE_TITLE_TEXT,text:&apos;hello&apos;&#125;);</span><br><span class="line">  renderApp();</span><br><span class="line">&#125;,1000);</span><br></pre></td></tr></table></figure><blockquote><p>我们将状态放到了createStore函数中，目的是隔离作用域，并且再内部返回深度克隆的对象，这样用户无法再通过外界更改状态。但是状态应该由我们自身来控制，应该是外界传入的，所以要将状态拿出createStore。并且判断的逻辑也应该由我们自己来编写</p></blockquote><h3 id="四、reducer的实现"><a href="#四、reducer的实现" class="headerlink" title="四、reducer的实现"></a>四、reducer的实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">const CHANGE_TITLE_TEXT = &apos;CHANGE_TITLE_TEXT&apos;;</span><br><span class="line"></span><br><span class="line">function createStore(reducer) &#123;</span><br><span class="line">  let state;</span><br><span class="line">  let getState = () =&gt; JSON.parse(JSON.stringify(state));</span><br><span class="line">  function dispatch(action) &#123;</span><br><span class="line">    state  = reducer(state,action);//获取对应的状态覆盖掉store中的状态</span><br><span class="line">  &#125;</span><br><span class="line">  dispatch(&#123;&#125;); // 默认传入空对象获取reducer返回的默认结果</span><br><span class="line">  return &#123;</span><br><span class="line">    dispatch,</span><br><span class="line">    getState,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let initState = &#123;</span><br><span class="line">  title:&#123;color:&apos;red&apos;,text:&apos;标题&apos;&#125;,</span><br><span class="line">  content:&#123;color:&apos;green&apos;,text:&apos;内容&apos;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// reducer应该具有默认状态,当更改状态后使用最新的状态</span><br><span class="line">function reducer(state=initState,action) &#123;</span><br><span class="line">  switch (action.type)&#123;</span><br><span class="line">    case CHANGE_TITLE_TEXT:</span><br><span class="line">      return &#123;...state,title:&#123;...state.title,text:action.text&#125;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  return state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、订阅函数"><a href="#五、订阅函数" class="headerlink" title="五、订阅函数"></a>五、订阅函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function createStore(reducer) &#123;</span><br><span class="line">  let state;</span><br><span class="line">  let listeners = []; // 放置所有订阅的函数</span><br><span class="line">  let getState = () =&gt; JSON.parse(JSON.stringify(state));</span><br><span class="line">  function dispatch(action) &#123;</span><br><span class="line">    state  = reducer(state,action);</span><br><span class="line">    listeners.forEach(item=&gt;item());//每次派发后执行订阅的函数</span><br><span class="line">  &#125;</span><br><span class="line">  let subscribe = (fn)=&gt;&#123; //主要用于订阅事件</span><br><span class="line">    listeners.push(fn);</span><br><span class="line">    return ()=&gt;&#123; //返回一个移除监听的方法</span><br><span class="line">      listeners = listeners.filter(l=&gt;l!==fn);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  dispatch(&#123;&#125;);</span><br><span class="line">  return &#123;</span><br><span class="line">    dispatch,</span><br><span class="line">    getState,</span><br><span class="line">    subscribe</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">store.subscribe(renderApp); //通过suscribe订阅派发时需要触发的函数</span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">  store.dispatch(&#123;type:CHANGE_TITLE_TEXT,text:&apos;hello&apos;&#125;);</span><br><span class="line">&#125;,1000);</span><br></pre></td></tr></table></figure><blockquote><p>此时我们redux中常用的方法已经封装完成！^_^,我们将封装好的逻辑抽离成redux.js</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function createStore(reducer) &#123;</span><br><span class="line">  let state;</span><br><span class="line">  let listeners = []; // 放置所有订阅的函数</span><br><span class="line">  let getState = () =&gt; JSON.parse(JSON.stringify(state));</span><br><span class="line">  function dispatch(action) &#123;</span><br><span class="line">    state  = reducer(state,action);</span><br><span class="line">    listeners.forEach(item=&gt;item());//每次派发后执行订阅的函数</span><br><span class="line">  &#125;</span><br><span class="line">  let subscribe = (fn)=&gt;&#123; //主要用于订阅事件</span><br><span class="line">    listeners.push(fn);</span><br><span class="line">    return ()=&gt;&#123; //返回一个移除监听的方法</span><br><span class="line">      // 源码中给出的方法</span><br><span class="line">      let  index = listeners.indexOf(fn);</span><br><span class="line">      listeners.splice(index, 1);</span><br><span class="line"></span><br><span class="line">      // listeners = listeners.filter(item =&gt; item!==fn); 过滤一下也是可以实现的</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  dispatch(&#123;&#125;);</span><br><span class="line">  return &#123;</span><br><span class="line">    dispatch,</span><br><span class="line">    getState,</span><br><span class="line">    subscribe</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这样我们就简单的实现了一个属于自己的redux.js</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 23 2018 18:24:16 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;什么是Redux&quot;&gt;&lt;a href=&quot;#什么是Redux&quot; class=&quot;headerlink&quot; title=&quot;什么是Redux&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="前端框架" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react-router-dom</title>
    <link href="http://yoursite.com/2017/08/12/reactRouterDom/"/>
    <id>http://yoursite.com/2017/08/12/reactRouterDom/</id>
    <published>2017-08-11T16:00:00.000Z</published>
    <updated>2018-03-21T10:06:48.638Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 23 2018 18:24:16 GMT+0800 (中国标准时间) --><p>** 本文中使用的参数举例为官方文档案例</p><p>** 本篇文章只将组件和方法的参数展示，针对使用方法和常用的参数进行阐述，如果想了解的更多，可以去查看<a href="https://reacttraining.com/react-router/web/api/BrowserRouter/basename-string" target="_blank" rel="noopener">React-Router 4.x官方文档</a></p><p>在react中想使用路由功能，基本是可选的插件只有react-router，我们想使用路由功能首先要安装<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install react-router-dom --save-dev;</span><br></pre></td></tr></table></figure><p></p><p>安装成功之后我们就可以在我们的项目中使用了<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDom from &apos;react-dom&apos;;</span><br><span class="line">import &#123;BrowserRouter,HashRouter,Link,NavLink,Redirect,Route,Switch&#125; from &apos;react-router-dom&apos;;</span><br><span class="line">// react-router-dom中提供的组件供我们使用</span><br></pre></td></tr></table></figure><p></p><h2 id="react-router-提供的组件"><a href="#react-router-提供的组件" class="headerlink" title="react-router 提供的组件"></a>react-router 提供的组件</h2><h3 id="BrowserRouter"><a href="#BrowserRouter" class="headerlink" title="BrowserRouter"></a>BrowserRouter</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;BrowserRouter</span><br><span class="line">  basename=&#123;optionalString&#125;</span><br><span class="line">  forceRefresh=&#123;optionalBool&#125;</span><br><span class="line">  getUserConfirmation=&#123;optionalFunc&#125;</span><br><span class="line">  keyLength=&#123;optionalNumber&#125;</span><br><span class="line">&gt;</span><br><span class="line">  &lt;App/&gt;</span><br><span class="line">&lt;/BrowserRouter&gt;</span><br></pre></td></tr></table></figure><p>[注意]：需要一个根节点包裹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import Address from &apos;../component/Address&apos;;</span><br><span class="line"></span><br><span class="line">&lt;BrowserRouter basename=&apos;/base&apos;&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Route path=&apos;/address&apos; component=&#123;Address&#125;/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/BrowserRouter&gt;</span><br><span class="line">&lt;Link to=&apos;/address&apos;&gt; // render ： &lt;a href=&apos;/base/address&apos;&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="HashRouter"><a href="#HashRouter" class="headerlink" title="HashRouter"></a>HashRouter</h3><p>[注意]：需要一个根节点包裹<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import Address from &apos;../component/Address&apos;;</span><br><span class="line"></span><br><span class="line">&lt;HashRouter basename=&apos;/base&apos;&gt;</span><br><span class="line">  &lt;App&gt;</span><br><span class="line">    &lt;Route path=&apos;/address&apos; exact component=&#123;Address&#125;/&gt;</span><br><span class="line">  &lt;App/&gt;</span><br><span class="line">&lt;/HashRouter&gt;</span><br><span class="line"></span><br><span class="line">&lt;Link to=&quot;/address&quot;/&gt; // renders &lt;a href=&quot;#/base/address&quot;&gt;</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=&quot;/about&quot;&gt;About&lt;/Link&gt; // renders &lt;a href=&quot;#/about&quot;&gt;</span><br></pre></td></tr></table></figure><p><strong>exact</strong> : bool<br>如果为true，路径为精准匹配</p><p><strong>to</strong> : string<br>连接到指定的路径</p><p><strong>to</strong> : object<br>要连接的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=&#123;&#123;</span><br><span class="line">  pathname: &apos;/address&apos;, // 跳转路径</span><br><span class="line">  search: &apos;?sort=name&apos;,</span><br><span class="line">  hash: &apos;#the-hash&apos;,</span><br><span class="line">  state: &#123; fromDashboard: true &#125;</span><br><span class="line">&#125;&#125;/&gt;</span><br><span class="line">// 对面里面可以添加跳转携带的参数</span><br></pre></td></tr></table></figure><p><strong>replace</strong> : bool<br>如果为true，单击链接将替换历史堆栈中的当前条目，而不是添加新条目。</p><hr><h3 id="NavLink"><a href="#NavLink" class="headerlink" title="NavLink"></a>NavLink</h3><p>一种特殊版本的<link>，用法和Link一致，不过在与当前URL匹配时，将向渲染元素添加样式属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavLink</span><br><span class="line">  to=&quot;/faq&quot; // 跳转路径</span><br><span class="line">  activeClassName=&quot;selected&quot; // 当于路径匹配成功时，追加的类名</span><br><span class="line">&gt;FAQs&lt;/NavLink&gt;</span><br><span class="line"></span><br><span class="line">// 如果我们不适用样式表，也可以写成行内样式，如下</span><br><span class="line">&lt;NavLink</span><br><span class="line">  to=&quot;/faq&quot;</span><br><span class="line">  activeStyle=&#123;&#123; // 对象数据类型 写法如js中设置属性时的写法</span><br><span class="line">    fontWeight: &apos;bold&apos;,</span><br><span class="line">    color: &apos;red&apos;</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&gt;FAQs&lt;/NavLink&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="Redirect-配合Switch使用"><a href="#Redirect-配合Switch使用" class="headerlink" title="Redirect (配合Switch使用)"></a>Redirect (配合Switch使用)</h3><p>路径重定向，当匹配不到符合路径是，会跳转到Redirect设置的路径</p><p><strong>to</strong> : string<br>重定向路径</p><p><strong>to</strong> : object<br>要重定向位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Redirect to=&#123;&#123;</span><br><span class="line">  pathname: &apos;/login&apos;,</span><br><span class="line">  search: &apos;?utm=your+face&apos;,</span><br><span class="line">  state: &#123; referrer: currentLocation &#125;</span><br><span class="line">&#125;&#125;/&gt;</span><br></pre></td></tr></table></figure><p><strong>push</strong>: bool<br>当为true时，重定向会将新条目推入历史记录，而不是替换当前条目。</p><p><strong>from</strong>: string<br>要重定向的路径名。这只能用于在<switch>内部呈现<redirect>时匹配位置。</redirect></switch></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Redirect from=&apos;/old-path&apos; to=&apos;/new-path&apos;/&gt;</span><br><span class="line">  &lt;Route path=&apos;/new-path&apos; component=&#123;Address&#125;/&gt;</span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h3><p>路由组件可能是React Router中了解和学习使用的最重要的组件。其最基本的责任是在位置与路线的路径匹配时呈现一些UI。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;BrowserRouter&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Route exact path=&quot;/&quot; component=&#123;Header&#125;/&gt;</span><br><span class="line">    &lt;Route path=&quot;/news&quot; component=&#123;Footer&#125;/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/BrowserRouter&gt;</span><br></pre></td></tr></table></figure><p><strong>component</strong><br>当您使用组件（而不是下面的渲染或子项）时，路由器使用React.createElement从给定组件创建一个新的React元素。<br>这意味着如果您向组件属性提供内联函数，则可以在每个渲染中创建一个新组件.这将导致现有组件卸载和新组件安装，而不是仅更新现有组件</p><p><strong>render</strong> ： function<br>这允许方便的在线呈现和包装，而不需要上述的不期望的重新安装。您可以使用组件支持为您创建一个新的React元素，而不必在位置匹配时传入要调用的函数。<br>渲染道具接收与组件渲染道具相同的所有route props。</p><p>警告：&lt;Route component&gt;取决于&lt;Route render&gt;，所以不要在同一个&lt;Route&gt;中使用两者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 内联呈现</span><br><span class="line">&lt;Route path=&quot;/home&quot; render=&#123;() =&gt; &lt;div&gt;Home&lt;/div&gt;&#125;/&gt;</span><br><span class="line"></span><br><span class="line">// 包装/合成</span><br><span class="line">const FadingRoute = (&#123; component: Component, ...rest &#125;) =&gt; (</span><br><span class="line">&lt;Route &#123;...rest&#125; render=&#123;props =&gt; (</span><br><span class="line">  &lt;FadeIn&gt;</span><br><span class="line">    &lt;Component &#123;...props&#125;/&gt;</span><br><span class="line">  &lt;/FadeIn&gt;</span><br><span class="line">)&#125;/&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&lt;FadingRoute path=&quot;/cool&quot; component=&#123;Something&#125;/&gt;</span><br></pre></td></tr></table></figure><p><strong>children</strong> ： function<br>有时您需要渲染路径是否匹配该位置。在这些情况下，可以使用函数child prop。它的工作原理就像渲染，除了它被调用是否有匹配<br>children 渲染prop接收与组件和渲染方法相同的所有route props，除非路由未能匹配URL，则match为null。<br>这允许您根据路线是否匹配来动态调整用户界面。在这里，如果路由匹配，我们添加一个活动类</p><p>警告：&lt;Route component&gt;和&lt;Route render&gt;优先级高于&lt;Route children&gt;，所以不要在同一个&lt;Route&gt;中使用多个</p><hr><h3 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h3><p>解决路匹配机制问题的组件</p><p>当我们定义了很多路由的时候<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;</span><br><span class="line">&lt;Route path=&quot;/:user&quot; component=&#123;User&#125;/&gt;</span><br><span class="line">&lt;Route component=&#123;NoMatch&#125;/&gt;</span><br></pre></td></tr></table></figure><p></p><p>路由的匹配机制并不是我们所想象的，匹配到符合的路径后就会停止，而是会继续向后面匹配，如果匹配到多个符合的路径时，会将这些路径对应的组件都渲染，这就让我们难接受了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">  &lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;</span><br><span class="line">  &lt;Route path=&quot;/:user&quot; component=&#123;User&#125;/&gt;</span><br><span class="line">  &lt;Route component=&#123;NoMatch&#125;/&gt;</span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure><p>所有我们要是用Switch 这个路由组件，来帮助我们解决这个问题，将所有的路由包裹在Switch组件中，路由会根据路径从上至下的匹配，如果匹配到符合的路径，就会立即停止匹配，然后渲染对应组件</p><h2 id="react-router-提供的属性和方法"><a href="#react-router-提供的属性和方法" class="headerlink" title="react-router 提供的属性和方法"></a>react-router 提供的属性和方法</h2><p>所有通过路由渲染的组件都会携带 Route props<br>1、history<br>2、location<br>3、match</p><h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p>history对象通常具有以下属性和方法：<br>length : （number）历史堆栈中的条目数<br>action : （string）当前动作（PUSH，REPLACE或POP）<br>location : (object) 当前位置。具有以下属性：<br>pathname: URL的路径<br>search: URL查询字符串<br>hash: URL哈希片段<br>state: 位置特定的状态被提供给例如。当这个位置被推到堆栈上时，push（路径，状态）。仅在浏览器和内存历史记录中可用。<br>push : (path, [state]) - (function) 将新条目推入历史堆栈<br>replace : (path, [state]) - (function) 替换历史堆栈上的当前条目<br>go(n) : (function) 将历史堆栈中的指针移动n个条目<br>goBack() : (function) 相当于 go(-1)<br>goForward() : (function) 相当于 go(1)<br>block : (function) 防止导航 (<a href="https://github.com/ReactTraining/history#blocking-transitions" target="_blank" rel="noopener">https://github.com/ReactTraining/history#blocking-transitions</a>)</p><p><img src="http://ww1.sinaimg.cn/large/e315dd2ely1fpkkba3om4j20ef08jwep.jpg" alt=""></p><h3 id="location"><a href="#location" class="headerlink" title="location"></a>location</h3><p>location对象的常用属性：<br>key: （在HashHistory中没有这个属性）<br>pathname: URL的路径<br>search: URL查询字符串<br>hash: URL哈希片段<br>state: 位置特定的状态被提供给例如。当这个位置被推到堆栈上时，push（路径，状态）。仅在浏览器和内存历史记录中可用。</p><p><img src="http://ww1.sinaimg.cn/large/e315dd2ely1fpkkba4e23j20eh02qt8m.jpg" alt=""></p><h3 id="match"><a href="#match" class="headerlink" title="match"></a>match</h3><p>match对象的常用属性：<br>params - （object）从对应于路径的动态段的URL解析的键/值对<br>isExact - （boolean）true如果整个URL匹配（没有尾随字符<br>path - （string）用于匹配的路径模式。作用于构建嵌套的<route><br>url - （string）URL的匹配部分。作用于构建嵌套的<link>s</route></p><p><img src="http://ww1.sinaimg.cn/large/e315dd2ely1fpkkba5osxj20el03yglk.jpg" alt=""></p><h3 id="withRouter"><a href="#withRouter" class="headerlink" title="withRouter"></a>withRouter</h3><p>也是比较常用的一个路由方法，withRouter其实是一个react的高阶组件（什么是高阶组件？高阶组件是一个函数，能够接受一个组件并返回一个新的组件）</p><p>在项目中我们有一些组件并不是通过路由跳转，但是我们还想使用路由中的方法，我们就需要通过withRouter来将我们的组件包装一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class ShowTheLocation extends React.Component &#123;</span><br><span class="line">  static propTypes = &#123;</span><br><span class="line">    match: PropTypes.object.isRequired,</span><br><span class="line">    location: PropTypes.object.isRequired,</span><br><span class="line">    history: PropTypes.object.isRequired</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123; match, location, history &#125; = this.props</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;You are now at &#123;location.pathname&#125;&lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default withRouter(ShowTheLocation)</span><br><span class="line"></span><br><span class="line">// 如果这个组件中使用了redux</span><br><span class="line"></span><br><span class="line">export default withRouter(connect(state,action)(ShowTheLocation));</span><br></pre></td></tr></table></figure><p>如果有任何疑问或者文章内有错误，可以发邮件到<a href="mailto:1043951234@qq.com" target="_blank" rel="noopener">1043951234@qq.com</a> 进行交流，如果有错误我会第一时间更正，感谢您的赐教</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 23 2018 18:24:16 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;** 本文中使用的参数举例为官方文档案例&lt;/p&gt;&lt;p&gt;** 本篇文章只将组件和方法的参数展示，针对使用方法和常用的参数进行阐述，如果想了解的更多，可以
      
    
    </summary>
    
      <category term="前端框架" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>javascript scope</title>
    <link href="http://yoursite.com/2017/07/30/scope/"/>
    <id>http://yoursite.com/2017/07/30/scope/</id>
    <published>2017-07-29T16:00:00.000Z</published>
    <updated>2018-03-20T12:11:13.743Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 23 2018 18:24:16 GMT+0800 (中国标准时间) --><p>对作用域和作用域链概念的模糊是我们在开发中导致一些‘意外’状况发生的常见原因</p><p>我们随便写一个例子来看一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;bird&apos;;</span><br><span class="line">function fn()&#123;</span><br><span class="line">  console.log(name); // 1、undefined</span><br><span class="line">  var name = &apos;dog&apos;</span><br><span class="line"></span><br><span class="line">  function temp()&#123;</span><br><span class="line">    var name = &apos;cat&apos;</span><br><span class="line">    console.log(name); // 2、cat</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function item()&#123;</span><br><span class="line">    console.log(name); // 3、dog</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  temp();</span><br><span class="line">  item();</span><br><span class="line"></span><br><span class="line">  console.log(name); // 4、dog</span><br><span class="line"></span><br><span class="line">  return function()&#123;</span><br><span class="line">    console.log(name); // 5、dog</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fn1 = fn();</span><br><span class="line"></span><br><span class="line">fn1();</span><br></pre></td></tr></table></figure><p>如果的这些结果你还会产生疑问的话，那说明你对作用域和作用域链的概念很模糊</p><p>我们先说一下在js中的作用域的概念：作用域指的是变量的适用范围； 基本分为全局作用域（window）和局部作用域（函数）</p><p>作用域的特点: 1、js中是不存在动态作用域的; 2、es6之前是不存在块级作用域的;</p><p>我们来了分析一下刚才的代码</p><p>位置1 这个位置输出 undefined 是因为js中变量提升机制所导致的 当进入一个作用域范围的时候js会预先查询在当前作用域中的var和function关键字所创建的变量，然后将这些变量的声明提升到当前作用域的顶部，但是var只能提升声明，不能赋值；而function 是提升声明并且赋值；</p><p>位置2 在当前作用域（temp函数）中可以查询到name属性；</p><p>位置3 在当前作用域（item函数）中无法查询到name属性，js机制会继续向外层查询，如果查询到了即输出；如果依旧没有找到，则继续向上级查询，直到查找到全局作用域，如果仍然查找不到，就会报错。</p><p>位置4 跟2同理</p><p>位置5 这也是证明了js中没有动态作用域；因为我们已经将fn函数的返回的函数赋值到了fn1，如果存在动态作用域的话，那输出的结果应该是‘bird’，然而他依旧是输出的‘dog’，也就是说，作用域链的查找规则是根据函数声明的位置，为不是看函数的调用位置</p><p>如果有任何疑问或者文章内有错误，可以发邮件到<a href="mailto:1043951234@qq.com" target="_blank" rel="noopener">1043951234@qq.com</a> 进行交流，如果有错误我会第一时间更正，感谢您的赐教</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 23 2018 18:24:16 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;对作用域和作用域链概念的模糊是我们在开发中导致一些‘意外’状况发生的常见原因&lt;/p&gt;&lt;p&gt;我们随便写一个例子来看一下&lt;/p&gt;&lt;figure class
      
    
    </summary>
    
      <category term="原生js" scheme="http://yoursite.com/categories/%E5%8E%9F%E7%94%9Fjs/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>javascript Prototype</title>
    <link href="http://yoursite.com/2017/07/15/prototype/"/>
    <id>http://yoursite.com/2017/07/15/prototype/</id>
    <published>2017-07-14T16:00:00.000Z</published>
    <updated>2018-03-22T04:14:00.171Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 23 2018 18:24:16 GMT+0800 (中国标准时间) --><blockquote><p>W3C对prototype的描述是：prototype 属性使您有能力向对象添加属性和方法。<br>语法：object.prototype.name=value</p></blockquote><p>让很多刚刚开始了解OOP思想的人很是迷茫。</p><p>prototype 的出现主要是为了实现“继承”的设计理念</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Fn(name)&#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  this.type = &apos;string&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var foo1 = new Fn(&apos;one&apos;);</span><br><span class="line">var foo2 = new Fn(&apos;two&apos;);</span><br><span class="line"></span><br><span class="line">console.log(foo1.type) // =&gt; string</span><br><span class="line">console.log(foo2.type) // =&gt; string</span><br><span class="line"></span><br><span class="line">foo1.type = &apos;number&apos;;</span><br><span class="line"></span><br><span class="line">console.log(foo2.type) // =&gt; string</span><br><span class="line"></span><br><span class="line">// 同一个构造函数所生成的所有实例之间相互是没有影响的（this是构造函数所生成的实例）</span><br></pre></td></tr></table></figure><blockquote><p>这是我们通过 new 命令去创造一个实例的方法，但是 new 命令有一个很大的弊端，就是构造函数生成实例的时候会是属性和方法无法共享；这不仅是数据无法共享，也是资源的一种浪费；考虑到这个问题，也就在构造函数中出现了‘prototype’这个属性</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 我们改写一下上面的方法</span><br><span class="line"></span><br><span class="line">function Fn(name)&#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  this.fn = function()&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fn.prototype = &#123;</span><br><span class="line">  type: &apos;string&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var foo1 = new Fn(&apos;one&apos;);</span><br><span class="line">var foo2 = new Fn(&apos;two&apos;);</span><br><span class="line"></span><br><span class="line">console.log(foo1.name) // =&gt; one</span><br><span class="line">console.log(foo2.name) // =&gt; two</span><br><span class="line"></span><br><span class="line">Fn.prototype.type = &apos;number&apos;;</span><br><span class="line"></span><br><span class="line">console.log(foo2.type) // =&gt; number</span><br></pre></td></tr></table></figure><blockquote><p>我们发现 type 这个属性变成了两个实例的共有属性，而构造函数修改‘prototype’属性时会影响这实例的属性；</p></blockquote><blockquote><p>理解起来很像是构造函数内部this上的属性是实例的私有属性，而构造函数的‘prototype’上的属性是实例的共有属性；</p></blockquote><blockquote><p>对 prototype 有了一些了解 我们在说一下 __proto__ 这个属性， 它可以称谓隐式原型；</p></blockquote><blockquote><p>我们先对这两个属性抽象理解一下:</p><ul><li>1) 每一个函数都天生自带一个prototype（对象数据类型）属性 指向自身的原型</li><li>2) 每一个对象都天生自带一个__proto__属性 指向所属构造函数（类）的原型</li><li>3) 每一个原型都再带一个 constructor 属性 指向构造函数（类）（但是constructor这个属性是可以手动修改的）</li></ul></blockquote><p>js中的原型链也是由这俩个属性来实现的；</p><blockquote><p>我们先了解一下函数的三种身份：</p><ul><li>1) 普通函数</li><li>2) 构造函数</li><li>3) 函数对象</li></ul></blockquote><blockquote><p>普通函数 ： 是我们做常用的，不管是封装也谢方法还是回调函数，都属于普通函数范围</p><p>构造函数 ： new 命名后面跟的函数 归属于构造函数，并且我们为了更方便的区分普通函数还是构造函数，在声明函数的时候，构造函数通常会采用首字母大写的方式</p><p>函数对象 ： 函数自身也是一个对象，可以有自己的属性</p></blockquote><p>这也不难理解为什么js中的函数可塑性如此的高;</p><p>既然说了prototype和__proto__是为了共享属性和方法（继承）而诞生的属性，我们来看一看他们在实际中是怎么使用的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function Parent (name,age)&#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype = &#123;</span><br><span class="line">    getName : function()&#123;</span><br><span class="line">      return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child (name,age,sex)&#123;</span><br><span class="line">    Parent.call(this,name,age)</span><br><span class="line">    this.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = new Parent();</span><br><span class="line"></span><br><span class="line">var child = new Child(&apos;李雷&apos;,18,&apos;男&apos;)</span><br><span class="line"></span><br><span class="line">console.log(child.getName()); // 李雷</span><br></pre></td></tr></table></figure><blockquote><p>我们写了一个简单的继承方式，在这个例子中我们不难发现，在Child这个构造函数所产生的实例中，我们可以使用Parent上的方法，这就是继承的作用，当在一个已有的构造函数中已经写过我们需要的方法，我们在合适的需求下，我们完全可以将其拿来直接使用，而不是自己在写一段重复、冗余的代码，这样也就实现了资源的共享；</p><p>__proto__ 这个属性在实际开发中我们很少直接使用，是因为这个属性牵扯的东西太多，而且IE（所有开发者的痛苦）浏览器是屏蔽开发者对这个属性的操作的；并且这个属性也是一直不被推荐使用的；</p><p>__proto__ 默认是串联所有实例和类的原型</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var ary = new Array(3);</span><br><span class="line">console.dir(ary);</span><br><span class="line"></span><br><span class="line">// 在输出台里你可以看见 \__proto__ 的指向顺序， ary -&gt; Array -&gt; Object（自身\__proto__为null，因为它已经是根源了）；这就是为什么我们声明一个数组后，就可以调用Array和Object上的方法；这也是js中为什么说万物皆对象的原因；</span><br></pre></td></tr></table></figure><blockquote><p>在ES6中给出了两个操作方法:</p><ul><li>1) <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf" target="_blank" rel="noopener">Object.getPrototypeOf()</a> 方法返回指定对象的原型</li><li>2) <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf" target="_blank" rel="noopener">Object.setPrototypeOf()</a> 方法设置一个指定的对象的原型</li></ul><p>尽管如此，设置对象的__proto__是一个缓慢的操作，如果性能是一个问题，应该避免;</p></blockquote><blockquote><p>如果看过有关原型继承的书籍的话，我们会发现有很多继承的方式，在这就不一一举例了，我们直说一下寄生组合式继承，应该是目前最为理想解决继承的方法，解决了以前原型继承，组合式继承等等方法的一些小bug和缺陷</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 借助一下上面的例子，改造一下</span><br><span class="line">function Parent (name,age)&#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = function()&#123; return this.name; &#125;</span><br><span class="line"></span><br><span class="line">// 在考虑Object.create 这个方法的兼容性不够，所以采用自己模拟这个功能的写法，如果不需要考虑IE9一下版本的话可以直接使用虑Object.create 更简单一些</span><br><span class="line">function inherit(sub,sup)&#123;</span><br><span class="line">  function Fn()&#123;&#125;;</span><br><span class="line">  Fn.prototype = sup.prototype;</span><br><span class="line">  var fn = new Fn();</span><br><span class="line">  Object.defineProperty(fn,&apos;constructor&apos;,&#123;value:sub&#125;) // 增强原型</span><br><span class="line">  sub.prototype = fn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child (name,age,sex)&#123;</span><br><span class="line">    Parent.call(this,name,age)</span><br><span class="line">    this.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inherit(Child,Parent);</span><br><span class="line"></span><br><span class="line">var child = new Child(&apos;李雷&apos;,18,&apos;男&apos;)</span><br><span class="line"></span><br><span class="line">console.log(child.getName()); // 李雷</span><br></pre></td></tr></table></figure><p>希望对正在学习这方面只是的小伙伴们有帮助吧, 以上观点也是我总结的一些。</p><p>如果有任何疑问或者文章内有错误，可以发邮件到<a href="mailto:1043951234@qq.com" target="_blank" rel="noopener">1043951234@qq.com</a> 进行交流，如果有错误我会第一时间更正，感谢您的赐教</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 23 2018 18:24:16 GMT+0800 (中国标准时间) --&gt;&lt;blockquote&gt;&lt;p&gt;W3C对prototype的描述是：prototype 属性使您有能力向对象添加属性和方法。&lt;br&gt;语法：object.pro
      
    
    </summary>
    
      <category term="原生js" scheme="http://yoursite.com/categories/%E5%8E%9F%E7%94%9Fjs/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>react 声明周期</title>
    <link href="http://yoursite.com/2017/07/02/reactLifeCycle/"/>
    <id>http://yoursite.com/2017/07/02/reactLifeCycle/</id>
    <published>2017-07-01T16:00:00.000Z</published>
    <updated>2018-03-22T04:42:07.293Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 23 2018 18:24:16 GMT+0800 (中国标准时间) --><h2 id="react-的声明周期"><a href="#react-的声明周期" class="headerlink" title="react 的声明周期"></a>react 的声明周期</h2><p>先上一张图，我们会根据这张图来分析</p><p><img src="http://ww1.sinaimg.cn/large/e315dd2ely1fplhd8yxcgj20w60g1t9z.jpg" alt=""></p><blockquote><p>react的声明周期其实是可以分为两大类的，第一种是组件实例化时只执行一次的，第二种是组件存在时会跟着组件内部操作而触发的；那就让我们分别来看看他们在react的一个组件组件中所充当的角色</p></blockquote><h3 id="一、getDefaultProps"><a href="#一、getDefaultProps" class="headerlink" title="一、getDefaultProps"></a>一、getDefaultProps</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import React from <span class="string">'react'</span>; *以后的代码省略这行代码了</span><br><span class="line">import PropTypes from <span class="string">'prop-types'</span>;</span><br><span class="line"></span><br><span class="line">class Component extends React.Component&#123;</span><br><span class="line">  static defaultProps = &#123;</span><br><span class="line">      name: <span class="string">'yang'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">      <span class="built_in">return</span> (</span><br><span class="line">        &lt;div&gt;Hello, &#123;this.props.name&#125;&lt;/div&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当组件实例化的时候会执行defaultProps这个函数，作用是设置组件所需参数的默认值、也可以配合prop-types这个包来进行参数验证<a href="https://reactjs.org/docs/typechecking-with-proptypes.html" target="_blank" rel="noopener">prop-types</a></p></blockquote><p>注释 ： extends 是 es6 中类继承的语法；<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 例如： 你想让类A 继承类B 那么写法 就是</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</span><br><span class="line"> <span class="comment">//(类的名字最好是首字母大写，保持这种良好的代码风格)</span></span><br><span class="line"> <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="comment">// 在es5 一个构造函数继承另外一个构造函数的时候，会有很多方法：call继承，原型继承，组合式继承，寄生组合式继承（如果不知道的小伙变要好好学习了）</span></span><br><span class="line">    <span class="comment">// 而es6 中类继承则是通过super来进行的 ，super的特性不属于本篇文章的讨论范围，如果感兴趣的话可以去翻查一下</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="二、getInitialState"><a href="#二、getInitialState" class="headerlink" title="二、getInitialState"></a>二、getInitialState</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Component extends React.Component&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>()&#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      render: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当组件实例化的时候会对实例的一些私有属性进行初始化，对es6语法了解的话，应该很容易理解，如果对es6的class类的语法不了解的话建议大家先去了解一下<a href="http://es6.ruanyifeng.com/#docs/class" target="_blank" rel="noopener">es6</a>, state是组件内部状态，这个属性十分的重要，state的属性变更会直接影响这组件的渲染</p></blockquote><h3 id="三、componentWillMount"><a href="#三、componentWillMount" class="headerlink" title="三、componentWillMount"></a>三、componentWillMount</h3><blockquote><p>是组件挂载前的最后一个生命周期，只执行一次，最后修改state的机会</p></blockquote><h3 id="四-render"><a href="#四-render" class="headerlink" title="四 render"></a>四 render</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Component extends React.Component&#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      name: &apos;yang&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt; `hello $&#123;this.state.name&#125;`&lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>组件渲染，render方法会根据return 的返回结果生成虚拟的DOM，经过react内部机制的<a href="http://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html" target="_blank" rel="noopener">DOM Diff</a> 比对后，渲染到页面上。<br>在render函数中有几个注意事项:</p><ul><li>必须存在一个根节点</li><li>不可以修改state</li><li>可以输出null，false</li></ul></blockquote><h3 id="五-componentDidMount"><a href="#五-componentDidMount" class="headerlink" title="五 componentDidMount"></a>五 componentDidMount</h3><p>组件挂载完成，通常我们会在这个生命周期函数内进行页面数据的请求操作， 只会执行一次</p><h3 id="六-componentWillReceiveProps"><a href="#六-componentWillReceiveProps" class="headerlink" title="六 componentWillReceiveProps"></a>六 componentWillReceiveProps</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      name: <span class="keyword">this</span>.props.name || <span class="string">'yang'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillReceiveProps(nextProps)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> nextProps.name !== <span class="string">'undefined'</span>)&#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">          name: nextProps.name</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt; <span class="string">`hello <span class="subst">$&#123;<span class="keyword">this</span>.state.name&#125;</span>`</span>&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>当外部传入的参数发生改变的时候会触发componentWillReceiveProps这个函数的执行，在函数里可以修改本组件的state值，不用担心会引起render的多次调用</p></blockquote><h3 id="七-shouldComponentUpdate"><a href="#七-shouldComponentUpdate" class="headerlink" title="七 shouldComponentUpdate"></a>七 shouldComponentUpdate</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      name: <span class="keyword">this</span>.props.name || <span class="string">'yang'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  shouldComponentUpdate(nextProps,nextState)&#123;</span><br><span class="line">    <span class="keyword">return</span> nextProps.name != <span class="keyword">this</span>.props.name;</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt; <span class="string">`hello <span class="subst">$&#123;<span class="keyword">this</span>.state.name&#125;</span>`</span>&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>这个生命周期函数是在props和state发生改变时必然会触发的，如果没有手动声明，默认为true ，如果手动设置为false 组件将不会在更新；这个生命周期是开发者在react开发的时候对性能优化上帮助最大的，很多开发这都轻视了这个函数。</p></blockquote><h3 id="八-componentWillUpdate"><a href="#八-componentWillUpdate" class="headerlink" title="八 componentWillUpdate"></a>八 componentWillUpdate</h3><blockquote><p>state或者props发生改变时，在组件准备更新之前执行的生命周期函数，在这个生命周期内不要在去修改state和props 不然后果很严重</p></blockquote><h3 id="九-componentDidUpdate"><a href="#九-componentDidUpdate" class="headerlink" title="九 componentDidUpdate"></a>九 componentDidUpdate</h3><blockquote><p>组件重新渲染后会被调用，在这个函数中可以获取到更新之后的数据和dom元素</p></blockquote><h3 id="十-componentWillUnmount"><a href="#十-componentWillUnmount" class="headerlink" title="十 componentWillUnmount"></a>十 componentWillUnmount</h3><blockquote><p>当用户执行移除组件或者删除组件的操作后，在执行前触发的生命周期函数，但是react对善后工作做的不是很到位，如果你在组件中创建了计时器这种异步操作事件，在componentWillUnmount函数中一定要手动的移除这些事件，否则会报错</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      name: <span class="keyword">this</span>.props.name || <span class="string">'yang'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount()&#123;</span><br><span class="line">    <span class="keyword">this</span>.timer = setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">name</span>:<span class="string">'我要卸载了'</span>&#125;)</span><br><span class="line">    &#125;,<span class="number">5000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillUnmount()&#123;</span><br><span class="line">    clearTimeout(<span class="keyword">this</span>.timer)</span><br><span class="line">  &#125;</span><br><span class="line">  handelClick()&#123;</span><br><span class="line">    ReactDom.unmountComponentAtNode(<span class="built_in">window</span>.root)</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div onClick=&#123;<span class="keyword">this</span>.handelClick&#125;&gt; <span class="string">`hello <span class="subst">$&#123;<span class="keyword">this</span>.state.name&#125;</span>`</span>&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>对react 生命周期的以一些理解，希望对您有帮助</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 23 2018 18:24:16 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;react-的声明周期&quot;&gt;&lt;a href=&quot;#react-的声明周期&quot; class=&quot;headerlink&quot; title=&quot;react 的声
      
    
    </summary>
    
      <category term="前端框架" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react 基础篇（三）</title>
    <link href="http://yoursite.com/2017/06/25/reactBase3/"/>
    <id>http://yoursite.com/2017/06/25/reactBase3/</id>
    <published>2017-06-24T16:00:00.000Z</published>
    <updated>2018-03-18T11:15:53.165Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 23 2018 18:24:16 GMT+0800 (中国标准时间) --><h2 id="react-的基本语法"><a href="#react-的基本语法" class="headerlink" title="react 的基本语法"></a>react 的基本语法</h2><p>首先我们要了解react 的jsx语法</p><p>react 使用 jsx 语法来代替常规的javascript 使用起来很像 html+javascript的组合</p><p>jsx的优点 ：<br>1、执行更快，因为它在编译为 JavaScript 代码后进行了优化<br>2、它是类型安全的，在编译过程中就能发现错误<br>3、使用 JSX 编写模板更加简单快速</p><p>注意事项 ： 1、 想要在jsx中使用js语法需要使用‘{}’ 例： { this.state.name }<br>2、 在jsx 中不能使用if else 可以改用三元运算符<br>3、 jsx 中的注释写法 ：{/*注释…*/}</p><hr><p>我们先看一下这么一段代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本篇文章代码必须引入的两个组件，后面的代码中省略</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'20170109'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">build</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;&#123;str&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">            &lt;h2&gt;&#123;true ? str : null&#125;&lt;/</span>h2&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">let el = &lt;div&gt;&#123;build('react的基本语法！')&#125;&lt;/</span>div&gt;;</span><br><span class="line">ReactDOM.render(el, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure><hr><p>下面我们看一下组件的写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> student1 = &#123;<span class="attr">name</span>: <span class="string">'小明'</span>, <span class="attr">age</span>: <span class="number">15</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> student2 = &#123;<span class="attr">name</span>: <span class="string">'李雷'</span>, <span class="attr">age</span>: <span class="number">16</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Achievement</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="comment">// 这个组件在调用时，默认会调用render方法</span></span><br><span class="line">        <span class="keyword">let</span> &#123;name,age&#125; = <span class="keyword">this</span>.props; <span class="comment">// 使用解构的方法可以让我们在写参数的时候更少</span></span><br><span class="line">        <span class="keyword">return</span> &lt;p&gt;&#123;name&#125; &#123;age&#125;&lt;/p&gt;;</span><br><span class="line">        <span class="comment">// 也可以 return &lt;p&gt;&#123;this.props.name&#125; &#123;this.props.age&#125;&lt;/p&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件的传参的两种方法，可以使用es6的解构方式，也可以一个个传</span></span><br><span class="line">ReactDOM.render(&lt;div&gt;</span><br><span class="line">    &lt;Achievement &#123;...student1&#125;/&gt;</span><br><span class="line">    &lt;Achievement name=&#123;student2.name&#125; age=&#123;student2.age&#125;/&gt;</span><br><span class="line">&lt;/div&gt;, window.root);</span><br><span class="line"></span><br><span class="line">// 注意 ： &lt;Achievement age=9/&gt; 这样传递参数的时候，在组件内部调用this.props.age 的时候是字符串类型而不是数字类型</span><br><span class="line"></span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>列表类的输出方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> students = [</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'李雷'</span>, <span class="attr">sex</span>: <span class="string">'男'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'李华'</span>, <span class="attr">sex</span>: <span class="string">'男'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'小红'</span>, <span class="attr">sex</span>: <span class="string">'女'</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">(</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &#123;lessons.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> (</span><br><span class="line">                &lt;li key=&#123;index&#125;&gt;姓名：&#123;item.name&#125;;性别：&#123;item.sex&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">            )</span></span><br><span class="line"><span class="regexp">        )&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/u</span>l&gt;</span><br><span class="line">), <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure><p>一定要注意的是 如果你有代码的格式洁癖，请用() 将代码包裹起来，防止react不能正常解析这段代码，在react中循环输出的时候一定要在输出的元素上添加 key 属性，否则会出现警报，虽然这个警报不会影响你代码的执行，但是会影响性能，因为在react 中保证性能的 DOM Diff 会使用到这个属性 ,不是本篇文章的讨论范围</p><hr><p>属性上的渲染</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> style = &#123;</span><br><span class="line">    backgroundColor : <span class="string">'red'</span>,</span><br><span class="line">    color : <span class="string">'blue'</span>,</span><br><span class="line">    fontSize : <span class="string">'20px'</span></span><br><span class="line">&#125;;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">(</span><br><span class="line">    &lt;ul style=&#123;style&#125;&gt;</span><br><span class="line">        &lt;li className=<span class="string">'aa'</span>&gt;<span class="number">1</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">        &lt;li&gt;&lt;label htmlFor='aa'&gt;-&lt;/</span>label&gt;&lt;input id='aa'/&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li dangerouslySetInnerHTML=&#123;&#123;<span class="attr">__html</span>:<span class="string">'&lt;span&gt;123&lt;/span&gt;'</span>&#125;&#125;&gt;&lt;/li&gt;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp">,window.root);</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 这里需要注意的是 这里的style是对象数据类型</span></span><br></pre></td></tr></table></figure><p>要了解是react中dom的属性有一些已经变成react中的关键字，所以写法上会和以前的写法不同，例如：class -&gt; className; for -&gt; htmlFor …</p><p>如果你必不可免的要在一个结构中插入许多标签，可以使用dangerouslySetInnerHTML（安全插入），因为有可能不合时宜的使用innerHTML会导致XSS攻击；</p><hr><p>事件上的绑定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们以input 来举例， 顺便也说以下react 实现双向数据绑定的方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Input</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;<span class="attr">val</span>:<span class="string">''</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleFn(e)&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">val</span>:e.target.value&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;input type=<span class="string">"text"</span> value=&#123;<span class="keyword">this</span>.state.val&#125; onChange=&#123;<span class="keyword">this</span>.handleFn.bind(<span class="keyword">this</span>)&#125;/&gt;</span><br><span class="line">                &#123;<span class="keyword">this</span>.state.val&#125;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 写法二</span></span><br><span class="line"><span class="regexp">class Input extends React.Component&#123;</span></span><br><span class="line"><span class="regexp">    constructor()&#123;</span></span><br><span class="line"><span class="regexp">        super();</span></span><br><span class="line"><span class="regexp">        this.state = &#123;val:''&#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    handleFn = (e)=&gt;&#123;</span></span><br><span class="line"><span class="regexp">        this.setState(&#123;val:e.target.value&#125;);</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    render()&#123;</span></span><br><span class="line"><span class="regexp">        return (</span></span><br><span class="line"><span class="regexp">            &lt;div&gt;</span></span><br><span class="line"><span class="regexp">                &lt;input type="text" value=&#123;this.state.val&#125; onChange=&#123;this.handleFn&#125;/</span>&gt;</span><br><span class="line">                &#123;<span class="keyword">this</span>.state.val&#125;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Input/</span>&gt;,<span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><p>上面有两种写法，当然第二种使用了es6和es7的语法所以写起来很简洁，也不用担心this错误的问题，所以在babel可以解析的语法，我们都可以在项目中使用</p><p>我们简单说一下 react 的双向数据绑定，大家都知道react 是 MVC框架（单向数据绑定），所以我们想实现双向数据绑定就要借助其他的方法，react 能引起视图渲染的方法只有修改state和props，所以我们想要是想双向数据绑定，我们就要去操作state和props，那我们实现一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">val</span>: <span class="string">''</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  changeFn = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">val</span>: e.target.value&#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Input value=&#123;<span class="keyword">this</span>.state.val&#125; changeFn=&#123;<span class="keyword">this</span>.changeFn&#125;/&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Input</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">val</span>: <span class="string">''</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  handleFn = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">val</span>: e.target.value&#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;value,changeFn&#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> value=&#123;<span class="keyword">this</span>.state.val&#125; onChange=&#123;<span class="keyword">this</span>.handleFn&#125;/&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.val&#125;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> value=&#123;value&#125; onChange=&#123;changeFn&#125;/&gt;</span><br><span class="line">        &#123;value&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Parent/</span>&gt;,<span class="built_in">window</span>.root)</span><br></pre></td></tr></table></figure><p>需要用事件来触发state或者props的修改来让视图重新渲染，来实现双向绑定</p><p>还有一种不提倡的方法，就是直接通过ref 来操作DOM也可以实现，不过既然使用react了，还在操作DOM 那就太low了。所以我们要习惯这种数据驱动视图的思想。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 23 2018 18:24:16 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;react-的基本语法&quot;&gt;&lt;a href=&quot;#react-的基本语法&quot; class=&quot;headerlink&quot; title=&quot;react 的基
      
    
    </summary>
    
      <category term="前端框架" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react 基础篇（二）</title>
    <link href="http://yoursite.com/2017/06/18/reactBase2/"/>
    <id>http://yoursite.com/2017/06/18/reactBase2/</id>
    <published>2017-06-17T16:00:00.000Z</published>
    <updated>2018-03-18T11:15:25.699Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 23 2018 18:24:16 GMT+0800 (中国标准时间) --><h3 id="webpack-的基本配置"><a href="#webpack-的基本配置" class="headerlink" title="webpack 的基本配置"></a>webpack 的基本配置</h3><p>想要实现项目的自动化管理，还是需要依赖自动化构建工具，这篇文章主要讲述的是webpack的基本配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install webpack webpack-dev-server --save-dev <span class="comment">// 或者使用yarn</span></span><br><span class="line">$ npm install style-loader css-loader url-loader file-loader less-loader html-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure><p>上面安装的的是一个项目基本必须要使用的一些依赖包<br>安装完成之后我们来看一下webpack该如何配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个插件是为了webpack打包后的代码可以插入到我们html中的</span></span><br><span class="line"><span class="keyword">let</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">"html-webpack-plugin"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们先配置一个文件配置</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">"./src/index.js"</span>, <span class="comment">// 入口文件</span></span><br><span class="line">  output: &#123; <span class="comment">// 出口</span></span><br><span class="line">    filename: <span class="string">"build.js"</span>,  <span class="comment">// 文件名</span></span><br><span class="line">    path: <span class="built_in">require</span>(<span class="string">'path'</span>).resolve(<span class="string">'/dist'</span>) <span class="comment">// 文件路径，这个需要填写绝对路径，所以我们引用path插件，来将一个相对路径转换成绝对路径</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [ <span class="comment">// 配置文件解析规则，</span></span><br><span class="line">      &#123;<span class="attr">test</span>: <span class="regexp">/\.js$/</span>, <span class="attr">use</span>: <span class="string">"babel-loader"</span>, <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>&#125;,</span><br><span class="line">      &#123;<span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: [<span class="string">"style-loader"</span>, <span class="string">"css-loader"</span>]&#125;,</span><br><span class="line">      &#123;<span class="attr">test</span>: <span class="regexp">/\.less$/</span>, <span class="attr">use</span>: [<span class="string">"style-loader"</span>, <span class="string">"css-loader"</span>, <span class="string">"less-loader"</span>]&#125;,</span><br><span class="line">      &#123;<span class="attr">test</span>: <span class="regexp">/\.(jpg|png|gif|jpeg)$/</span>, <span class="attr">use</span>: <span class="string">"url-loader"</span>&#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: <span class="string">'source-map'</span>, <span class="comment">/*源码映射*/</span></span><br><span class="line">  plugins: [ <span class="comment">// 插件</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">"./index.html"</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>多个文件的配置方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: &apos;./src/app.js&apos;,</span><br><span class="line">    search: &apos;./src/search.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &apos;[name].js&apos;,</span><br><span class="line">    path: __dirname + &apos;/dist&apos;</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.css88.com/doc/webpack/" target="_blank" rel="noopener">webpack</a>还有更多的配置参数，我们先配置一个简单的</p><p>当然我们想要将环境跑起来，还需要在package.json文件中的scripts中配置一些启动环境的指令</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 截取部分代码</span></span><br><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"dev"</span>: <span class="string">"webpack-dev-server --config webpack.config.js"</span>,</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"npm run dev"</span>,</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"webpack --config webpack.config.js"</span> <span class="comment">// 打包时使用的代码</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>配置完成后，我们就可以执行 start 来开启一个本地端口来运行我们的代码了</p><p>是不是很简单呢，快来写一写react代码来感受一下吧</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 23 2018 18:24:16 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;webpack-的基本配置&quot;&gt;&lt;a href=&quot;#webpack-的基本配置&quot; class=&quot;headerlink&quot; title=&quot;webp
      
    
    </summary>
    
      <category term="前端框架" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react 基础篇（一）</title>
    <link href="http://yoursite.com/2017/06/11/reactBase1/"/>
    <id>http://yoursite.com/2017/06/11/reactBase1/</id>
    <published>2017-06-10T16:00:00.000Z</published>
    <updated>2018-03-22T04:14:57.561Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 23 2018 18:24:16 GMT+0800 (中国标准时间) --><h2 id="react-安装"><a href="#react-安装" class="headerlink" title="react 安装"></a>react 安装</h2><p>对于入门的人来说，是从无到有的过程，首先我们要先了解一下如何使用框架</p><p>1、首先要安装node.js 在<a href="http://nodejs.cn/" target="_blank" rel="noopener">Node</a>下载，node的版本会影响你可用的功能和一些语法支持，所以尽量使用高版本的node</p><p>2、node会自带npm包管理器，<a href="https://www.npmjs.com/" target="_blank" rel="noopener">Npm</a>，使用npm的指令来安装react项目中需要用到的组件，插件，翻译官(babel)等,如果下载缓慢的话可以采用taobao镜像，也可以使用yarn来安装，速度会快一些。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>3、创建一个新的文件夹，在这个文件夹中调用命令窗口（Shift+右键）调用cmd命令窗口<br>输入指令<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm init  <span class="comment">// 生成一个package.json文件 ，一步步配置文件信息</span></span><br><span class="line">$ npm init -y <span class="comment">// 自动提取文件信息生成一个默认的package.json文件</span></span><br></pre></td></tr></table></figure><p></p><p>如果想使用yarn 首先要通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install yarn -g  //来安装</span><br></pre></td></tr></table></figure><p>之后就可以使用yarn的语法了</p><p>4、安装react：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install react react-dom</span><br><span class="line">//或者</span><br><span class="line">$ yarn add react react-dom</span><br></pre></td></tr></table></figure><p>在react项目中还需要很多辅助插件：</p><p>babel 这个翻译官 是在框架项目中必备的，它可以将项目中的es2015(es6)-es2017(es8)的语法转换成现在所有浏览器支持程度最高的es5语法；【注意】：像Set、Map这种是不会被翻译的。</p><p>babel 的核心包 babel-core</p><p>5、安装babel<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm babel-core babel-preset-stage-0 babel-preset-react babel-loader babel-preset-env --save-dev</span><br><span class="line"></span><br><span class="line">// --save-dev 是将安装这些依赖包安装在开发环境中</span><br></pre></td></tr></table></figure><p></p><p>在现在流行的框架开发中，有开发环境和生产环境，所谓的开发环境就是项目在开发过程中所依赖的环境；生产环境就是上线之后，项目面对用户的真实环境</p><p>6、配置文件</p><p>我们还需要在根目录下创建一个 .babelrc 文件（没有文件名称）在里面配置一些东西</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// .babelrc 文件内</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  &quot;presets&quot;:[&quot;react&quot;,&quot;env&quot;,&quot;stage-0&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><code>env是可以解析es6及以前的语法，但是在用的后发现，他无法解析es6以上的一些草案语法，所以为了可以使用更高级的语法，在后面加上stage-0 保险起见；</code></p><p>完成以上操作其实你就已经开启了你的react之旅了</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 23 2018 18:24:16 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;react-安装&quot;&gt;&lt;a href=&quot;#react-安装&quot; class=&quot;headerlink&quot; title=&quot;react 安装&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="前端框架" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>javascript Ajax</title>
    <link href="http://yoursite.com/2017/05/07/ajax/"/>
    <id>http://yoursite.com/2017/05/07/ajax/</id>
    <published>2017-05-06T16:00:00.000Z</published>
    <updated>2018-03-18T11:18:44.130Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 23 2018 18:24:16 GMT+0800 (中国标准时间) --><p>在学习AJAX原理的时候我尝试这封装过自己的AJAX，作为我学习AJAX的纪念吧<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 参数</span><br><span class="line"> * url : 请求地址</span><br><span class="line"> * method : 请求类型</span><br><span class="line"> * data : 请求参数</span><br><span class="line"> * dataType : 数据类型</span><br><span class="line"> * async : 是否异步</span><br><span class="line"> * cache : 是否清缓存</span><br><span class="line"> * success : 成功执行函数</span><br><span class="line"> * error : 失败后执行函数</span><br><span class="line"> * timeoutTimer : 等待时长</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">(function () &#123;</span><br><span class="line">  class ajaxFn &#123;</span><br><span class="line">    constructor(url, options) &#123;</span><br><span class="line">      // 如果传入的是一个对象的话，options 就被 url 替换</span><br><span class="line">      if (typeof url === &apos;object&apos;) &#123;</span><br><span class="line">        options = url;</span><br><span class="line">        url = undefined;</span><br><span class="line">      &#125;</span><br><span class="line">      options = Object.prototype.toString.call(options).slice(8, -1) === &apos;Object&apos; ? options : &#123;&#125;;</span><br><span class="line">      this.url = url || options.url;</span><br><span class="line">      this.options = &#123;</span><br><span class="line">        method: options.type || options.method || &apos;GET&apos;,</span><br><span class="line">        data: options.data || null,</span><br><span class="line">        dataType: options.dataType || &apos;JSON&apos;,</span><br><span class="line">        async: options.async || true,</span><br><span class="line">        cache: options.cache || true,</span><br><span class="line">        success: typeof options.success === &apos;function&apos; ? options.success : function () &#123;</span><br><span class="line">        &#125;,</span><br><span class="line">        error: typeof options.error === &apos;function&apos; ? options.error : function () &#123;</span><br><span class="line">        &#125;,</span><br><span class="line">        timeoutTimer: options.timeoutTimer || null</span><br><span class="line">      &#125;;</span><br><span class="line">      this.isGet = /(^|\s+)(head|detele|get)(\s+|$)/i.test(this.options.method);</span><br><span class="line">      this.isLocal = window.XMLHttpRequest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    formatData() &#123;</span><br><span class="line">      if (Object.prototype.toString.call(this.options.data).slice(8, -1) === &apos;Object&apos;) &#123;</span><br><span class="line">        let obj = this.options.data,</span><br><span class="line">          str = ``;</span><br><span class="line">        for (let key in obj) &#123;</span><br><span class="line">          if (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            str += `$&#123;key&#125;=$&#123;obj[key]&#125;&amp;`</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        str = str.replace(/&amp;$/g, &apos;&apos;);</span><br><span class="line">        this.options.data = str;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queryURL() &#123;</span><br><span class="line">      return this.url.indexOf(&quot;?&quot;) === -1 ? &quot;?&quot; : &quot;&amp;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cacheFn() &#123;</span><br><span class="line">      return !this.cache ? `$&#123;this.queryURL()&#125;_=$&#123;Math.random()&#125;` : ``;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createStandardXHR() &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        return new window.XMLHttpRequest();</span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createActiveXHR() &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        return new window.ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serialize(form) &#123;</span><br><span class="line">      let parts = [],</span><br><span class="line">        field = null,</span><br><span class="line">        option,</span><br><span class="line">        optValue;</span><br><span class="line">      for (let i = 0; i &lt; form.elements.length; i++) &#123;</span><br><span class="line">        field = form.elements[i];</span><br><span class="line">        switch (field.type) &#123;</span><br><span class="line">          case &quot;select-one&quot;:</span><br><span class="line">          case &quot;select-multiple&quot;:</span><br><span class="line">            if (field.name.length) &#123;</span><br><span class="line">              for (let j = 0; j &lt; field.options.length; j++) &#123;</span><br><span class="line">                option = field.options[j];</span><br><span class="line">                if (option.selected) &#123;</span><br><span class="line">                  optValue = &apos;&apos;;</span><br><span class="line">                  if (optioin.hasAttribute) &#123;</span><br><span class="line">                    optValue = (option.hasAttribute(&apos;value&apos;) ? option.value : option.text);</span><br><span class="line">                  &#125; else &#123;</span><br><span class="line">                    optValue = (option.attributes[&apos;value&apos;].specified ? option.value : option.text);</span><br><span class="line">                  &#125;</span><br><span class="line">                  parts.push(encodeURIComponent(field.name) + &apos;=&apos; + encodeURIComponent(optValue));</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">          case undefined: //字段集</span><br><span class="line">          case &apos;file&apos;: //文件输入</span><br><span class="line">          case &apos;submit&apos;: //提交按钮</span><br><span class="line">          case &apos;reset&apos;: //重置按钮</span><br><span class="line">          case &apos;button&apos;: //自定义按钮</span><br><span class="line">            break;</span><br><span class="line">          case &apos;radio&apos;: //单选按钮</span><br><span class="line">          case &apos;checkbox&apos;: //复选框</span><br><span class="line">            if (!field.checked) &#123;</span><br><span class="line">              break;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">          default:</span><br><span class="line">            if (field.name.length) &#123;</span><br><span class="line">              parts.push(encodeURIComponent(field.name) + &apos;=&apos; + encodeURIComponent(field.value));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return parts.join(&apos;&amp;&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  window.ajax = function (url, options) &#123;</span><br><span class="line">    let example = new ajaxFn(url, options);</span><br><span class="line">    url = example.url || null;</span><br><span class="line">    options = example.options || &#123;&#125;;</span><br><span class="line">    let xhr = example.isLocal ? example.createStandardXHR() : example.createActiveXHR();</span><br><span class="line">    xhr.onreadystatechange = function () &#123;</span><br><span class="line">      if (xhr.readyState === 2) &#123;</span><br><span class="line">        let response = xhr.responseText;</span><br><span class="line">      &#125;</span><br><span class="line">      if (xhr.readyState === 4) &#123;</span><br><span class="line">        if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status === 304) &#123;</span><br><span class="line">          let response = xhr.responseText;</span><br><span class="line">          options.success(response);</span><br><span class="line">        &#125;</span><br><span class="line">        if (xhr.status &gt;= 400 &amp;&amp; xhr.status &lt; 600) &#123;</span><br><span class="line">          let response = xhr.responseText;</span><br><span class="line">          options.error(response);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    if (options.data != null) &#123;</span><br><span class="line">      example.formatData();</span><br><span class="line">      if (example.isGet) &#123;</span><br><span class="line">        url += example.queryURL() + encodeURIComponent(options.data);</span><br><span class="line">        options.data = null;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    example.isGet &amp;&amp; (url += example.cacheFn());</span><br><span class="line"></span><br><span class="line">    xhr.open(options.method, url, options.async);</span><br><span class="line">    xhr.send(options.data);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 23 2018 18:24:16 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;在学习AJAX原理的时候我尝试这封装过自己的AJAX，作为我学习AJAX的纪念吧&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight pl
      
    
    </summary>
    
      <category term="原生js" scheme="http://yoursite.com/categories/%E5%8E%9F%E7%94%9Fjs/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>javascript Utils</title>
    <link href="http://yoursite.com/2017/05/06/jsCommonFn/"/>
    <id>http://yoursite.com/2017/05/06/jsCommonFn/</id>
    <published>2017-05-05T16:00:00.000Z</published>
    <updated>2018-03-22T04:12:24.147Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 23 2018 18:24:16 GMT+0800 (中国标准时间) --><blockquote><p>平时在工作中我们在使用javascript开发的时候会很怀念jQuery，因为Jquery中很多的方法都非常的好用，而且还能兼容ie的低版本浏览器，虽然大家现在都在慢慢的抛弃ie低版本的浏览器，不过一些方法的封装思想还是要常常回顾一下，温故而知新嘛！</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br></pre></td><td class="code"><pre><span class="line">var utils = (function () &#123;</span><br><span class="line">    var _flag = /MSIE [678]/i.test(navigator.userAgent);</span><br><span class="line"></span><br><span class="line">    var toTrim = function (str) &#123;</span><br><span class="line">        return str.replace(/^\s+|\s+$/g, &apos;&apos;);</span><br><span class="line">    &#125;;</span><br><span class="line">    var toJSON = function (str) &#123;</span><br><span class="line">        return window.JSON ? JSON.parse(str) : eval(&apos;(&apos; + str + &apos;)&apos;);</span><br><span class="line">    &#125;;</span><br><span class="line">    var toArray = function (classAry) &#123;</span><br><span class="line">        var ary = [];</span><br><span class="line">        if (!_flag) &#123;</span><br><span class="line">            ary = Array.prototype.slice.call(classAry);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            for (var i = 0; i &lt; classAry.length; i++) &#123;</span><br><span class="line">                ary[ary.length] = classAry[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ary;</span><br><span class="line">    &#125;;</span><br><span class="line">    var getEleClassName = function (strClass, context) &#123;</span><br><span class="line">        context = context || document;</span><br><span class="line">        if (!_flag) &#123;</span><br><span class="line">            getEleClassName = function (strClass, context) &#123;</span><br><span class="line">                context = context || document;</span><br><span class="line">                return toArray(context.getElementsByClassName(strClass));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            getEleClassName = function (strClass, context) &#123;</span><br><span class="line">                context = context || document;</span><br><span class="line">                var result = [],</span><br><span class="line">                    classNode = context.getElementsByTagName(&apos;*&apos;);</span><br><span class="line">                strClass = strClass.replace(/^\s+|\s+$/g, &apos;&apos;).split(/\s+/);</span><br><span class="line">                for (var i = 0; i &lt; classNode.length; i++) &#123;</span><br><span class="line">                    var item = classNode[i],</span><br><span class="line">                        itemClass = item.className,</span><br><span class="line">                        flag = true;</span><br><span class="line">                    for (var j = 0; j &lt; strClass.length; j++) &#123;</span><br><span class="line">                        var reg = new RegExp(&apos;(^|\\s)&apos; + strClass[j] + &apos;(\\s+|$)&apos;);</span><br><span class="line">                        if (!reg.test(itemClass)) &#123;</span><br><span class="line">                            flag = false;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    flag ? result.push(item) : null;</span><br><span class="line">                &#125;</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return getEleClassName(strClass, context);</span><br><span class="line">    &#125;;</span><br><span class="line">    var getEleChildren = function (curEle, tagName) &#123;</span><br><span class="line">        var result = [],</span><br><span class="line">            childNode = curEle.childNodes;</span><br><span class="line">        for (var i = 0; i &lt; childNode.length; i++) &#123;</span><br><span class="line">            var item = childNode[i];</span><br><span class="line">            if (item.nodeType === 1) &#123;</span><br><span class="line">                if (tagName) &#123;</span><br><span class="line">                    if (item.nodeName === tagName.toLocaleUpperCase()) &#123;</span><br><span class="line">                        result.push(item);</span><br><span class="line">                    &#125;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                result.push(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;;</span><br><span class="line">    var getCss = function (curEle, attr) &#123;</span><br><span class="line">        if (!_flag) &#123;</span><br><span class="line">            getCss = function (curEle, attr) &#123;</span><br><span class="line">                var value = window.getComputedStyle(curEle, null)[attr];</span><br><span class="line">                var reg = /^-?\d+(\.\d+)?(px|pt|em|rem)?$/g;</span><br><span class="line">                reg.test(value) ? value = parseFloat(value) : null;</span><br><span class="line">                return value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            getCss = function (curEle, attr) &#123;</span><br><span class="line">                var value = null;</span><br><span class="line">                if (attr === &apos;opacity&apos;) &#123;</span><br><span class="line">                    value = curEle.currentStyle[&apos;filter&apos;];</span><br><span class="line">                    value = (value === &apos;&apos;) ? 1 : value.replace(/(?:=)(.+)(?:\))/g, function () &#123;</span><br><span class="line">                        return arguments[1] / 100;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    value = curEle.currentStyle[attr];</span><br><span class="line">                &#125;</span><br><span class="line">                var reg = /^-?\d+(\.\d+)?(px|pt|em|rem)?$/g;</span><br><span class="line">                reg.test(value) ? value = parseFloat(value) : null;</span><br><span class="line">                return value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return getCss(curEle, attr);</span><br><span class="line">    &#125;;</span><br><span class="line">    var setCss = function (curEle, attr, value) &#123;</span><br><span class="line">        if (attr === &apos;opacity&apos;) &#123;</span><br><span class="line">            curEle.style[&apos;opacity&apos;] = value;</span><br><span class="line">            curEle.style[&apos;filter&apos;] = &apos;alpha(opacity=&apos; + value * 100 + &apos;)&apos;;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        !isNaN(value) &amp;&amp; !/^(zIndex|zoom|fontWeight|lineHeight)$/i.test(attr) ? value += &apos;px&apos; : null;</span><br><span class="line">        curEle.style[attr] = value;</span><br><span class="line">    &#125;;</span><br><span class="line">    var setGroupCss = function (curEle, options) &#123;</span><br><span class="line">        if (Object.prototype.toString.call(options).slice(8, -1) !== &apos;Object&apos;) return;</span><br><span class="line">        for (var key in options) &#123;</span><br><span class="line">            if (options.hasOwnProperty(key)) &#123;</span><br><span class="line">                setCss(curEle, key, options[key]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    var css = function () &#123;</span><br><span class="line">        var len = arguments.length,</span><br><span class="line">            fn = getCss,</span><br><span class="line">            type = Object.prototype.toString.call(arguments[1]).slice(8, -1);</span><br><span class="line">        len &gt;= 3 ? fn = setCss : (len === 2 &amp;&amp; type === &apos;Object&apos;) ? fn = setGroupCss : null;</span><br><span class="line">        return fn.apply(this, arguments);</span><br><span class="line">    &#125;;</span><br><span class="line">    var offset = function (curEle) &#123;</span><br><span class="line">        var $t = curEle.offsetTop,</span><br><span class="line">            $l = curEle.offsetLeft,</span><br><span class="line">            $p = curEle.offsetParent;</span><br><span class="line">        while ($p.nodeName !== &apos;BODY&apos;) &#123;</span><br><span class="line">            if (/MSIE 8/i.test(navigator.userAgent)) &#123;</span><br><span class="line">                $t += $p.clientTop;</span><br><span class="line">                $l += $p.clientLeft;</span><br><span class="line">            &#125;</span><br><span class="line">            $t += $p.offsetTop;</span><br><span class="line">            $l += $p.offsetLeft;</span><br><span class="line">            $p = $p.offsetParent;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;top: $t, left: $l&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    var winBox = function (attr, value) &#123;</span><br><span class="line">        if (typeof value !== &apos;undefined&apos;) &#123;</span><br><span class="line">            document.documentElement[attr] = value;</span><br><span class="line">            document.body[attr] = value;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        return document.documentElement[attr] || document.body[attr]</span><br><span class="line">    &#125;;</span><br><span class="line">    var hasClass = function (curEle, cls) &#123;</span><br><span class="line">        var flag = true,</span><br><span class="line">            reg = null,</span><br><span class="line">            curClassName = curEle.className;</span><br><span class="line">        cls = toTrim(cls).split(/\s+/);</span><br><span class="line">        if (cls.length &lt;= 1) &#123;</span><br><span class="line">            reg = new RegExp(&apos;(?:^|\\s+)&apos; + cls + &apos;(?:\\s+|$)&apos;);</span><br><span class="line">            return curClassName.match(reg);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            for (var i = 0; i &lt; cls.length; i++) &#123;</span><br><span class="line">                reg = new RegExp(&apos;(?:^|\\s+)&apos; + cls[i] + &apos;(?:\\s+|$)&apos;);</span><br><span class="line">                if (!reg.test(curClassName)) &#123;</span><br><span class="line">                    flag = false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return flag;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    var addClass = function (curEle, cls) &#123;</span><br><span class="line">        cls = toTrim(cls).split(/\s+/);</span><br><span class="line">        for (var i = 0; i &lt; cls.length; i++) &#123;</span><br><span class="line">            if (!hasClass(curEle, cls[i])) &#123;</span><br><span class="line">                curEle.className += &apos; &apos; + cls[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        curEle.className = toTrim(curEle.className).replace(/\s+/g, &apos; &apos;);</span><br><span class="line">    &#125;;</span><br><span class="line">    var removeClass = function (curEle, cls) &#123;</span><br><span class="line">        cls = toTrim(cls).split(/\s+/);</span><br><span class="line">        for (var i = 0; i &lt; cls.length; i++) &#123;</span><br><span class="line">            if (hasClass(curEle, cls[i])) &#123;</span><br><span class="line">                var reg = new RegExp(&apos;(?:^|\\s)&apos; + cls[i] + &apos;(?:\\s|$)&apos;);</span><br><span class="line">                curEle.className = curEle.className.replace(reg, &apos; &apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        curEle.className = toTrim(curEle.className).replace(/\s+/g, &apos; &apos;);</span><br><span class="line">    &#125;;</span><br><span class="line">    var addEventHandler = function (target, type, fn) &#123;</span><br><span class="line">        if (target.addEventListener) &#123;</span><br><span class="line">            target.addEventListener(type, fn);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            target.attachEvent(&quot;on&quot; + type, fn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    var removeEventHandler = function (target, type, fn) &#123;</span><br><span class="line">        if (target.removeEventListener) &#123;</span><br><span class="line">            target.removeEventListener(type, fn);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            target.detachEvent(&quot;on&quot; + type, fn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    var siblings = function (curEle, tagName) &#123;</span><br><span class="line">        var result = [];</span><br><span class="line">        var previous = curEle.previousSibling;</span><br><span class="line">        var next = curEle.nextSibling;</span><br><span class="line">        if (tagName) &#123;</span><br><span class="line">            tagName = toTrim(tagName);</span><br><span class="line">            if (/\.[\w-]/g.test(tagName)) &#123;</span><br><span class="line">                tagName = tagName.replace(/\./g, &apos;&apos;);</span><br><span class="line">                var reg = new RegExp(&apos;(?:^|\\s+)&apos; + tagName + &apos;(?:\\s+|$)&apos;);</span><br><span class="line">                while (previous) &#123;</span><br><span class="line">                    if (reg.test(previous.className)) &#123;</span><br><span class="line">                        result.unshift(previous);</span><br><span class="line">                    &#125;</span><br><span class="line">                    previous = previous.previousSibling;</span><br><span class="line">                &#125;</span><br><span class="line">                while (next) &#123;</span><br><span class="line">                    if (reg.test(next.className)) &#123;</span><br><span class="line">                        result.push(next)</span><br><span class="line">                    &#125;</span><br><span class="line">                    next = next.nextSibling;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                while (previous) &#123;</span><br><span class="line">                    if (previous.nodeName === tagName.toLocaleUpperCase()) &#123;</span><br><span class="line">                        result.unshift(previous);</span><br><span class="line">                    &#125;</span><br><span class="line">                    previous = previous.previousSibling;</span><br><span class="line">                &#125;</span><br><span class="line">                while (next) &#123;</span><br><span class="line">                    if (next.nodeName === tagName.toLocaleUpperCase()) &#123;</span><br><span class="line">                        result.push(next)</span><br><span class="line">                    &#125;</span><br><span class="line">                    next = next.nextSibling;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            while (previous) &#123;</span><br><span class="line">                if (previous.nodeType === 1) &#123;</span><br><span class="line">                    result.unshift(previous);</span><br><span class="line">                &#125;</span><br><span class="line">                previous = previous.previousSibling;</span><br><span class="line">            &#125;</span><br><span class="line">            while (next) &#123;</span><br><span class="line">                if (next.nodeType === 1) &#123;</span><br><span class="line">                    result.push(next);</span><br><span class="line">                &#125;</span><br><span class="line">                next = next.nextSibling;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;;</span><br><span class="line">    var find = function (curEle, cls) &#123;</span><br><span class="line">        var result = [];</span><br><span class="line">        var nodeList = curEle.getElementsByTagName(&apos;*&apos;);</span><br><span class="line">        if (cls) &#123;</span><br><span class="line">            cls = toTrim(cls);</span><br><span class="line">            if (/\.[\w-]/g.test(cls)) &#123;</span><br><span class="line">                cls = cls.replace(/\./, &apos;&apos;);</span><br><span class="line">                for (var i = 0; i &lt; nodeList.length; i++) &#123;</span><br><span class="line">                    var reg = new RegExp(&apos;(?:^|\\s+)&apos; + cls + &apos;(?:\\s+|$)&apos;);</span><br><span class="line">                    if (reg.test(nodeList[i].className)) &#123;</span><br><span class="line">                        result.push(nodeList[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                for (var j = 0; j &lt; nodeList.length; j++) &#123;</span><br><span class="line">                    if (nodeList[j].nodeName === cls.toLocaleUpperCase()) &#123;</span><br><span class="line">                        result.push(nodeList[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;;</span><br><span class="line">    var getPrevEle = function (curEle) &#123;</span><br><span class="line">        var item = curEle.previousSibling;</span><br><span class="line">        while (item) &#123;</span><br><span class="line">            if (item.nodeType === 1) &#123;</span><br><span class="line">                return item;</span><br><span class="line">            &#125;</span><br><span class="line">            item = item.previousSibling;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    var getPrevAll = function (curEle) &#123;</span><br><span class="line">        var result = [];</span><br><span class="line">        var previous = curEle.previousSibling;</span><br><span class="line">        while (previous) &#123;</span><br><span class="line">            if (previous.nodeName === 1) &#123;</span><br><span class="line">                result.unshift(previous);</span><br><span class="line">            &#125;</span><br><span class="line">            previous = previous.previousSibling;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;;</span><br><span class="line">    var getNextEle = function (curEle) &#123;</span><br><span class="line">        var item = curEle.nextSibling;</span><br><span class="line">        while (item) &#123;</span><br><span class="line">            if (item.nodeType === 1) &#123;</span><br><span class="line">                return item;</span><br><span class="line">            &#125;</span><br><span class="line">            item = item.nextSibling;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    var getNextAll = function (curEle) &#123;</span><br><span class="line">        var result = [];</span><br><span class="line">        var next = curEle.nextSibling;</span><br><span class="line">        while (next) &#123;</span><br><span class="line">            if (next.nodeName === 1) &#123;</span><br><span class="line">                result.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">            next = next.nextSibling;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;;</span><br><span class="line">    var getFirstChild = function(curEle)&#123;</span><br><span class="line">        return getEleTagName(curEle)[0];</span><br><span class="line">    &#125;;</span><br><span class="line">    var getLastChild = function(curEle)&#123;</span><br><span class="line">        return getEleTagName(curEle)[getEleTagName(curEle).length-1];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        toTrim: toTrim,</span><br><span class="line">        toJSON: toJSON,</span><br><span class="line">        toArray: toArray,</span><br><span class="line">        getEleClassName: getEleClassName,</span><br><span class="line">        getEleChildren: getEleChildren,</span><br><span class="line">        css: css,</span><br><span class="line">        offset: offset,</span><br><span class="line">        winBox: winBox,</span><br><span class="line">        hasClass: hasClass,</span><br><span class="line">        addClass: addClass,</span><br><span class="line">        removeClass: removeClass,</span><br><span class="line">        addEventHandler: addEventHandler,</span><br><span class="line">        removeEventHandler: removeEventHandler,</span><br><span class="line">        siblings: siblings,</span><br><span class="line">        find: find,</span><br><span class="line">        getPrevEle:getPrevEle,</span><br><span class="line">        getPrevAll:getPrevAll,</span><br><span class="line">        getNextEle:getNextEle,</span><br><span class="line">        getNextAll:getNextAll,</span><br><span class="line">        getFirstChild:getFirstChild,</span><br><span class="line">        getLastChild:getLastChild</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>封装一些我们常用的方法，可以让我们的开发更具有效率。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 23 2018 18:24:16 GMT+0800 (中国标准时间) --&gt;&lt;blockquote&gt;&lt;p&gt;平时在工作中我们在使用javascript开发的时候会很怀念jQuery，因为Jquery中很多的方法都非常的好用，而且还能兼
      
    
    </summary>
    
      <category term="原生js" scheme="http://yoursite.com/categories/%E5%8E%9F%E7%94%9Fjs/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
</feed>
